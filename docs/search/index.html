<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta property="og:image" content="/resources/img/graalvm.png" />

  <title>
    
      Search
    
  </title>
  <meta
    name="GraalVM website: documentation, tutorials, news and general information."
    content="GraalVM is an ecosystem for programming languages and set of next generation tools for high performance applications."
  >
  <link rel="apple-touch-icon" sizes="180x180" href="/resources/img/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/resources/img/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/resources/img/favicon/favicon-16x16.png">
  <link rel="manifest" href="/resources/img/favicon/site.webmanifest">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="stylesheet" href="/resources/styles/extra.css">
  <link rel="stylesheet" href="https://elocation.oracle.com/mapviewer/jslib/v2.3/css/oraclemapsv2.css>

  <link rel="canonical" href="https://www.graalvm.org/docs/search/">
  <!-- <script src="/resources/lib/jquery/jquery-3.2.1.min.js"></script> -->
  <script src="https://maps.oracle.com/mapviewer/jslib/v2.3/oraclemapsv2.js"></script>
  <link rel="stylesheet" href="https://elocation.oracle.com/mapviewer/jslib/v2.3/css/oraclemapsv2.css">
  <script src="/resources/lib/bootstrap/js/bootstrap.min.js"></script>
  <script src="/resources/lib/sticky-sidebar/resizeSensor.js"></script>
  <script src="/resources/lib/sticky-sidebar/sticky-sidebar.min.js"></script>
  <script src="/resources/lib/highlight/highlight.pack.js"></script>
  <script src="/resources/lib/purl/purl.js"></script>
  <script async defer src="https://buttons.github.io/buttons.js"></script>
</head>


  <body class="preload">
    <!-- Start SiteCatalyst code -->
   <script language="JavaScript" src="https://www.oracle.com/us/assets/metrics/ora_otn.js"></script>
   <!-- End SiteCatalyst code -->
    <svg aria-hidden="true" style="position: absolute; width: 0; height: 0; overflow: hidden;" version="1.1" xmlns="http://www.w3.org/2000/svg"
  xmlns:xlink="http://www.w3.org/1999/xlink">
  <defs>
    <symbol id="icon-social-network" viewBox="0 0 32 32">
      <title>social-network</title>
      <path d="M28.8 0h-25.6c-1.76 0-3.2 1.44-3.2 3.2v25.6c0 1.76 1.44 3.2 3.2 3.2h25.6c1.76 0 3.2-1.44 3.2-3.2v-25.6c0-1.76-1.44-3.2-3.2-3.2zM25.12 11.68c-0.16 7.36-4.8 12.48-11.84 12.8-2.88 0.16-4.96-0.8-6.88-1.92 2.080 0.32 4.8-0.48 6.24-1.76-2.080-0.16-3.36-1.28-4-3.040 0.64 0.16 1.28 0 1.76 0-1.92-0.64-3.2-1.76-3.36-4.32 0.48 0.32 1.12 0.48 1.76 0.48-1.44-0.8-2.4-3.84-1.28-5.76 2.080 2.24 4.64 4.16 8.8 4.48-1.12-4.48 4.96-6.88 7.36-3.84 1.12-0.16 1.92-0.64 2.72-0.96-0.32 1.12-0.96 1.76-1.76 2.4 0.8-0.16 1.6-0.32 2.24-0.64-0.16 0.8-0.96 1.44-1.76 2.080z"></path>
    </symbol>
    <symbol id="icon-algorithm" viewBox="0 0 32 32">
      <title>algorithm</title>
      <path d="M30.109 7.692v-3.943h-3.758v1.875h1.883v2.068c-1.091 0.387-1.875 1.429-1.875 2.651s0.784 2.264 1.875 2.651v2.068h-1.891v1.875h3.766v-3.943c1.091-0.387 1.875-1.429 1.875-2.651s-0.784-2.264-1.875-2.651z"></path>
      <path d="M5.656 16.938v-1.875h-3.766v3.943c-1.091 0.387-1.875 1.429-1.875 2.651s0.784 2.264 1.875 2.651v3.943h3.758v-1.875h-1.883v-2.068c1.091-0.387 1.875-1.429 1.875-2.651s-0.784-2.264-1.875-2.651v-2.068h1.891z"></path>
      <path d="M7.516 0v9.375h17v-9.375h-17zM13.203 5.625h-1.875v-1.875h1.875v1.875zM16.953 5.625h-1.875v-1.875h1.875v1.875zM20.703 5.625h-1.875v-1.875h1.875v1.875z"></path>
      <path d="M7.516 11.313v9.375h17v-9.375h-17zM13.203 16.938h-1.875v-1.875h1.875v1.875zM16.953 16.938h-1.875v-1.875h1.875v1.875zM20.703 16.938h-1.875v-1.875h1.875v1.875z"></path>
      <path d="M7.516 22.625v9.375h17v-9.375h-17zM13.203 28.25h-1.875v-1.875h1.875v1.875zM16.953 28.25h-1.875v-1.875h1.875v1.875zM20.703 28.25h-1.875v-1.875h1.875v1.875z"></path>
    </symbol>
    <symbol id="icon-blogger" viewBox="0 0 32 32">
      <title>blogger</title>
      <path fill="#828282" style="fill: var(--color1, #828282)" d="M31.916 13.508c0-0.788-0.639-1.427-1.427-1.427v-0l-1.435 0c-0.917 0.001-1.86-0.031-2.261-0.394-0.567-0.524-0.652-1.465-0.823-2.737-0.321-2.47-0.524-2.598-0.909-3.432-1.401-2.972-5.196-5.207-7.805-5.517h-7.067c-5.56 0-10.104 4.555-10.104 10.114v11.793c0 5.549 4.544 10.093 10.104 10.093h11.611c5.56 0 10.071-4.544 10.104-10.093 0 0 0.013-8.378 0.013-8.399zM10.316 8.264h5.602c1.069 0 1.935 0.866 1.935 1.925s-0.866 1.935-1.935 1.935h-5.602c-1.069 0-1.935-0.877-1.935-1.935s0.866-1.925 1.935-1.925zM21.703 23.682h-11.386c-1.069 0-1.935-0.877-1.935-1.924 0-1.059 0.866-1.925 1.935-1.925h11.386c1.059 0 1.925 0.866 1.925 1.925 0 1.048-0.866 1.924-1.925 1.924z"></path>
    </symbol>
    <symbol id="icon-cloud-download" viewBox="0 0 32 32">
      <title>cloud-download</title>
      <path fill="#828282" style="fill: var(--color1, #828282)" d="M25.867 13.333c-0.933-4.533-4.933-8-9.867-8-3.867 0-7.2 2.133-8.8 5.333-4.133 0.533-7.2 3.867-7.2 8 0 4.4 3.6 8 8 8h17.333c3.733 0 6.667-2.933 6.667-6.667 0-3.467-2.8-6.4-6.133-6.667zM22.667 17.333l-6.667 6.667-6.667-6.667h4v-5.333h5.333v5.333h4z"></path>
    </symbol>
    <symbol id="icon-computing" viewBox="0 0 32 32">
      <title>computing</title>
      <path d="M25.867 19.577c1.773-0.141 3.106-0.678 4.051-1.634 1.668-1.687 1.975-4.439 1.929-8.332l-0.013-1.097h-12.044c-0.191-1.121-0.796-1.797-1.259-2.314-0.47-0.524-0.753-0.84-0.753-1.572s0.283-1.048 0.753-1.572l-1.654-1.482c-0.557 0.622-1.32 1.473-1.32 3.054s0.763 2.433 1.32 3.054c0.275 0.307 0.485 0.543 0.613 0.832h-2.586c-0.191-1.121-0.796-1.797-1.259-2.314-0.47-0.524-0.753-0.84-0.753-1.572s0.283-1.048 0.753-1.572c0.557-0.622 1.32-1.473 1.32-3.054h-2.221c0 0.732-0.283 1.048-0.753 1.572-0.557 0.622-1.32 1.473-1.32 3.054s0.763 2.433 1.32 3.054c0.275 0.307 0.485 0.543 0.613 0.832h-12.587v4.725c0 2.938 0.913 5.746 2.641 8.122l3.432 4.719h-6.443v2.961c0 1.633 1.328 2.961 2.961 2.961h22.206c1.633 0 2.961-1.328 2.961-2.961v-2.961h-6.443l3.432-4.719c0.415-0.57 0.782-1.166 1.102-1.782zM27.406 13.237v-2.504h2.223c-0.025 2.671-0.3 4.646-1.29 5.648-0.371 0.375-0.865 0.641-1.506 0.806 0.378-1.27 0.573-2.596 0.573-3.95zM25.556 28.299v0.74c0 0.408-0.332 0.74-0.74 0.74h-22.206c-0.408 0-0.74-0.332-0.74-0.74v-0.74h23.687zM18.587 26.078h-9.75l-4.382-6.025c-1.45-1.994-2.216-4.351-2.216-6.816v-2.504h22.947v2.504c0 2.465-0.766 4.822-2.216 6.816l-4.382 6.025z"></path>
      <path d="M17.824 14.908l-1.57 1.57 1.88 1.88-1.88 1.88 1.57 1.57 3.45-3.45z"></path>
      <path d="M11.31 16.478l-1.57-1.57-3.45 3.45 3.45 3.45 1.57-1.57-1.88-1.88z"></path>
      <path d="M13.707 13.324l-2.119 10.067h2.269l2.119-10.067z"></path>
    </symbol>
    <symbol id="icon-conversation" viewBox="0 0 32 32">
      <title>conversation</title>
      <path fill="#828282" style="fill: var(--color1, #828282)" d="M8.467 5.924h-1.891c1.349-0.292 2.36-1.491 2.36-2.928 0-1.655-1.341-2.996-2.996-2.996s-2.996 1.341-2.996 2.996c0 1.436 1.011 2.636 2.36 2.928h-1.891c-1.884 0-3.412 1.528-3.412 3.412v10.365h2.943v12.3h5.992v-12.3h2.943v-10.365c0-1.884-1.528-3.412-3.412-3.412z"></path>
      <path fill="#828282" style="fill: var(--color1, #828282)" d="M28.588 5.923h-1.891c1.349-0.292 2.36-1.491 2.36-2.928 0-1.655-1.341-2.996-2.996-2.996s-2.996 1.341-2.996 2.996c0 1.436 1.011 2.636 2.36 2.928h-1.891c-1.884 0-3.412 1.528-3.412 3.412v10.365h2.943v12.3h5.992v-12.3h2.943v-10.365c0-1.884-1.528-3.412-3.412-3.412z"></path>
      <path fill="#828282" style="fill: var(--color1, #828282)" d="M18.159 0.869l-1.55 1.056 1.309 1.921-1.309 1.921 1.55 1.056 2.028-2.977z"></path>
      <path fill="#828282" style="fill: var(--color1, #828282)" d="M15.391 1.924l-1.55-1.056-2.028 2.977 2.028 2.977 1.55-1.056-1.309-1.921z"></path>
    </symbol>
    <symbol id="icon-document" viewBox="0 0 32 32">
      <title>document</title>
      <path fill="#828282" style="fill: var(--color1, #828282)" d="M16 0c-8.836 0-16 7.164-16 16s7.163 16 16 16 16-7.164 16-16c-0-8.837-7.164-16-16-16zM23.169 23.169c0 1.074-0.87 1.944-1.944 1.944h-10.45c-1.074 0-1.944-0.87-1.944-1.944v-14.338c0-1.074 0.87-1.944 1.944-1.944h8.202v3.888h4.192v12.394zM19.807 9.945v-3.058l3.362 3.058h-3.362z"></path>
    </symbol>
    <symbol id="icon-github-sign" viewBox="0 0 32 32">
      <title>github-sign</title>
      <path d="M11.542 25.729c-0.223 0.041-0.32 0.146-0.292 0.312s0.153 0.222 0.375 0.167c0.223-0.055 0.32-0.153 0.292-0.292-0.028-0.153-0.153-0.215-0.375-0.187z"></path>
      <path d="M10.354 25.896c-0.222 0-0.333 0.076-0.333 0.229 0 0.181 0.118 0.257 0.354 0.229 0.222 0 0.334-0.076 0.334-0.229 0-0.18-0.118-0.257-0.354-0.229z"></path>
      <path d="M8.729 25.833c-0.055 0.153 0.035 0.257 0.271 0.313 0.208 0.083 0.34 0.041 0.396-0.125 0.042-0.153-0.049-0.263-0.271-0.333-0.208-0.055-0.34-0.007-0.396 0.146z"></path>
      <path d="M30.239 1.76c-1.174-1.173-2.587-1.76-4.24-1.76h-20c-1.653 0-3.066 0.587-4.24 1.76s-1.76 2.587-1.76 4.24v20c0 1.653 0.587 3.066 1.76 4.239s2.587 1.76 4.24 1.76h4.667c0.305 0 0.535-0.011 0.687-0.031s0.305-0.111 0.458-0.271c0.153-0.16 0.229-0.392 0.229-0.698 0-0.041-0.004-0.514-0.011-1.417s-0.011-1.618-0.011-2.146l-0.479 0.083c-0.306 0.055-0.691 0.080-1.156 0.073s-0.948-0.055-1.448-0.146c-0.5-0.090-0.965-0.299-1.396-0.625s-0.736-0.754-0.917-1.281l-0.208-0.48c-0.139-0.319-0.357-0.673-0.656-1.062s-0.601-0.653-0.906-0.792l-0.146-0.104c-0.097-0.069-0.187-0.153-0.271-0.25s-0.146-0.195-0.187-0.292c-0.042-0.097-0.007-0.177 0.104-0.24s0.312-0.093 0.604-0.093l0.417 0.062c0.278 0.055 0.621 0.222 1.031 0.5s0.746 0.639 1.010 1.083c0.32 0.57 0.705 1.003 1.156 1.302s0.906 0.448 1.364 0.448 0.854-0.035 1.188-0.104c0.333-0.070 0.646-0.174 0.937-0.313 0.125-0.93 0.465-1.646 1.021-2.146-0.792-0.083-1.503-0.208-2.135-0.375s-1.285-0.437-1.958-0.813c-0.674-0.375-1.233-0.84-1.677-1.396s-0.809-1.285-1.094-2.188c-0.285-0.903-0.427-1.945-0.427-3.125 0-1.68 0.549-3.111 1.646-4.292-0.514-1.264-0.465-2.68 0.146-4.25 0.403-0.125 1-0.031 1.792 0.281s1.371 0.58 1.74 0.802 0.663 0.41 0.886 0.563c1.292-0.361 2.625-0.542 4-0.542s2.708 0.181 4 0.542l0.792-0.5c0.542-0.333 1.181-0.639 1.917-0.917s1.299-0.354 1.688-0.229c0.625 1.57 0.681 2.986 0.166 4.25 1.097 1.181 1.646 2.611 1.646 4.292 0 1.181-0.142 2.226-0.427 3.135s-0.652 1.639-1.104 2.188c-0.451 0.549-1.014 1.010-1.687 1.385s-1.326 0.646-1.959 0.812c-0.632 0.167-1.344 0.292-2.135 0.376 0.722 0.625 1.083 1.611 1.083 2.958v4.979c0 0.236 0.034 0.427 0.104 0.573s0.181 0.246 0.334 0.302c0.153 0.055 0.288 0.090 0.407 0.104s0.288 0.021 0.51 0.021h4.667c1.653 0 3.066-0.587 4.239-1.76s1.76-2.587 1.76-4.24v-19.999c-0-1.653-0.587-3.066-1.76-4.24z"></path>
      <path d="M6.333 23.292c-0.097 0.069-0.083 0.18 0.042 0.333 0.139 0.139 0.25 0.16 0.333 0.062 0.097-0.069 0.083-0.18-0.042-0.333-0.139-0.125-0.25-0.146-0.333-0.062z"></path>
      <path d="M5.646 22.771c-0.042 0.097 0.007 0.181 0.146 0.25 0.111 0.070 0.202 0.056 0.271-0.041 0.042-0.097-0.007-0.181-0.146-0.25-0.139-0.042-0.229-0.028-0.271 0.042z"></path>
      <path d="M6.979 24.104c-0.125 0.069-0.125 0.195 0 0.375s0.243 0.229 0.354 0.146c0.125-0.097 0.125-0.229 0-0.396-0.111-0.18-0.229-0.222-0.354-0.125z"></path>
      <path d="M7.708 25.041c-0.125 0.111-0.097 0.243 0.083 0.396 0.166 0.166 0.305 0.187 0.416 0.062 0.111-0.111 0.083-0.243-0.083-0.396-0.166-0.166-0.305-0.187-0.417-0.063z"></path>
    </symbol>
    <symbol id="icon-home-icon-silhouette" viewBox="0 0 32 32">
      <title>home-icon-silhouette</title>
      <path fill="#828282" style="fill: var(--color1, #828282)" d="M31.463 14.567l-4.85-4.85v-5.602c0-1.013-0.821-1.834-1.835-1.834-1.012 0-1.833 0.821-1.833 1.834v1.934l-3.611-3.611c-1.785-1.784-4.889-1.781-6.671 0.003l-12.126 12.126c-0.716 0.717-0.716 1.878 0 2.594s1.879 0.717 2.595 0l12.125-12.126c0.395-0.393 1.091-0.393 1.484-0.001l12.127 12.127c0.36 0.359 0.828 0.537 1.297 0.537s0.939-0.179 1.298-0.537c0.716-0.716 0.716-1.877-0-2.594z"></path>
      <path fill="#828282" style="fill: var(--color1, #828282)" d="M16.637 8.516c-0.352-0.352-0.923-0.352-1.274 0l-10.666 10.663c-0.168 0.168-0.264 0.398-0.264 0.638v7.777c0 1.825 1.48 3.305 3.305 3.305h5.281v-8.178h5.962v8.178h5.281c1.825 0 3.305-1.48 3.305-3.305v-7.777c0-0.24-0.095-0.47-0.264-0.638l-10.665-10.663z"></path>
    </symbol>
    <symbol id="icon-icon-github" viewBox="0 0 32 32">
      <title>icon-github</title>
      <path d="M15.998 0.862c-8.57 0-15.52 6.948-15.52 15.522 0 6.856 4.446 12.674 10.614 14.726 0.776 0.142 1.060-0.336 1.060-0.748 0-0.368-0.014-1.344-0.020-2.64-4.318 0.938-5.228-2.080-5.228-2.080-0.706-1.792-1.724-2.27-1.724-2.27-1.41-0.962 0.106-0.944 0.106-0.944 1.558 0.11 2.378 1.6 2.378 1.6 1.384 2.372 3.632 1.686 4.516 1.29 0.142-1.004 0.542-1.686 0.986-2.074-3.446-0.394-7.068-1.724-7.068-7.672 0-1.694 0.604-3.080 1.598-4.164-0.16-0.394-0.694-1.972 0.152-4.108 0 0 1.304-0.418 4.268 1.592 1.238-0.346 2.564-0.518 3.884-0.524 1.318 0.006 2.646 0.178 3.886 0.522 2.964-2.008 4.264-1.592 4.264-1.592 0.846 2.136 0.314 3.714 0.154 4.108 0.994 1.084 1.596 2.47 1.596 4.164 0 5.962-3.628 7.274-7.086 7.658 0.558 0.48 1.054 1.426 1.054 2.874 0 2.074-0.020 3.748-0.020 4.258 0 0.416 0.28 0.898 1.068 0.746 6.162-2.056 10.604-7.87 10.604-14.724 0-8.57-6.95-15.52-15.522-15.52z"></path>
    </symbol>
    <symbol id="icon-icon-twitter" viewBox="0 0 32 32">
      <title>icon-twitter</title>
      <path fill="#828282" style="fill: var(--color1, #828282)" d="M31.938 6.116c-1.172 0.52-2.434 0.872-3.756 1.030 1.35-0.81 2.388-2.090 2.876-3.618-1.264 0.75-2.664 1.294-4.152 1.586-1.192-1.272-2.892-2.066-4.774-2.066-3.612 0-6.54 2.928-6.54 6.54 0 0.512 0.058 1.012 0.17 1.49-5.436-0.27-10.256-2.874-13.482-6.83-0.562 0.966-0.884 2.088-0.884 3.286 0 2.268 1.154 4.27 2.91 5.444-1.074-0.034-2.082-0.328-2.964-0.818 0 0.028 0 0.054 0 0.082 0 3.168 2.254 5.812 5.246 6.412-0.548 0.15-1.126 0.23-1.722 0.23-0.422 0-0.832-0.042-1.23-0.118 0.832 2.598 3.248 4.49 6.11 4.542-2.238 1.754-5.058 2.8-8.122 2.8-0.528 0-1.048-0.030-1.56-0.092 2.894 1.856 6.332 2.938 10.026 2.938 12.030 0 18.608-9.966 18.608-18.608 0-0.284-0.006-0.566-0.018-0.846 1.272-0.92 2.382-2.072 3.258-3.384z"></path>
    </symbol>
    <symbol id="icon-logo" viewBox="0 0 92 32">
      <title>logo</title>
      <path fill="#00758f" style="fill: var(--color2, #00758f)" d="M11.654 23.706c-3.31 0-5.268-2.365-5.268-7.44 0-5.206 2.537-7.895 5.847-7.895 1.634 0.026 3.080 0.81 4.004 2.015l0.009 0.012-1.034 1.014c-0.768-0.669-1.764-1.094-2.858-1.144l-0.010-0c-2.117 0-3.489 1.875-3.489 5.578 0 4.282 1.262 5.937 3.199 5.937 0.026 0.001 0.057 0.001 0.088 0.001 0.717 0 1.378-0.242 1.905-0.648l-0.007 0.005v-4.213h-1.931v-1.765h4.303v6.792c-1.229 1.088-2.854 1.752-4.635 1.752-0.043 0-0.086-0-0.129-0.001l0.006 0zM24.59 14.57c-0.275-0.086-0.593-0.143-0.922-0.158l-0.009-0c-0.641 0-1.234 0.49-2.317 1.834v7.24h-2.268v-10.991h1.875l0.193 1.875c1.193-1.544 1.944-2.069 2.758-2.069 0.356 0.005 0.691 0.096 0.984 0.254l-0.011-0.006zM32.595 23.485l-0.179-1.193c-0.882 0.841-2.075 1.363-3.389 1.379l-0.003 0c-2.165 0-3.31-1.103-3.31-3.048 0-2.248 1.744-3.751 5.599-3.751h0.793v-0.958c0-1.324-0.689-1.965-2.275-1.965-1.166 0.032-2.268 0.265-3.286 0.664l0.066-0.023-0.331-1.379c1.215-0.561 2.636-0.893 4.133-0.903l0.004-0c2.758 0 3.93 1.324 3.93 3.33v7.86zM32.105 18.362h-0.945c-2.503 0-3.192 0.834-3.192 1.986-0.005 0.048-0.008 0.103-0.008 0.159 0 0.857 0.695 1.551 1.551 1.551 0.054 0 0.107-0.003 0.16-0.008l-0.007 0.001c0.955-0.079 1.802-0.485 2.442-1.104l-0.001 0.001zM43.31 23.485l-0.172-1.193c-0.885 0.84-2.080 1.362-3.396 1.379l-0.003 0c-2.165 0-3.31-1.103-3.31-3.048 0-2.248 1.744-3.751 5.606-3.751h0.793v-0.958c0-1.324-0.69-1.965-2.275-1.965-1.166 0.032-2.268 0.265-3.286 0.664l0.066-0.023-0.331-1.379c1.215-0.56 2.636-0.892 4.133-0.903l0.004-0c2.758 0 3.923 1.324 3.923 3.33v7.86zM42.827 18.362h-0.945c-2.537 0-3.199 0.841-3.199 1.986-0.005 0.045-0.007 0.098-0.007 0.152 0 0.861 0.698 1.558 1.558 1.558 0.051 0 0.102-0.002 0.152-0.007l-0.006 0c0.958-0.076 1.808-0.482 2.449-1.104l-0.001 0.001zM49.722 23.637c-1.379 0-2.006-0.4-2.006-2.186v-13.611h2.317v12.735c0 1.282 0.159 1.482 0.793 1.482 0.2 0 0.441 0 0.6 0l0.11 1.379c-0.461 0.13-0.99 0.205-1.536 0.205-0.083 0-0.165-0.002-0.247-0.005l0.012 0z"></path>
      <path fill="#f29111" style="fill: var(--color3, #f29111)" d="M59.472 23.485h-2.827c-1.514-4.012-2.988-8.994-4.133-14.101l-0.149-0.792h2.606c0.772 3.972 2.027 8.184 3.289 12.411 1.067-3.33 2.092-7.508 2.857-11.776l0.094-0.635h2.365c-1.116 5.758-2.534 10.753-4.322 15.568l0.219-0.675zM77.675 23.485c-0.090-4.33-0.4-8.805-0.689-11.873v0l-3.751 11.873h-1.965l-3.792-11.873c-0.283 3.289-0.483 7.543-0.552 11.873h-2.268c0.131-4.827 0.483-10.039 1.076-14.893h3.137l3.572 10.942 3.579-10.942h2.972c0.572 4.827 1.014 10.060 1.145 14.893zM81.867 21.968h-0.538v-0.303h1.469v0.29h-0.538v1.517h-0.393zM83.184 21.665h0.634l0.386 1.324 0.414-1.324h0.621v1.82h-0.393v-1.531l-0.49 1.558h-0.324l-0.483-1.558v1.558h-0.365z"></path>
    </symbol>
    <symbol id="icon-screwdriver-and-wrench-crossed" viewBox="0 0 43 32">
      <title>screwdriver-and-wrench-crossed</title>
      <path d="M6.204 26.885c-1.171 1.171-1.171 3.067 0 4.238 0.585 0.585 1.353 0.877 2.12 0.877s1.535-0.292 2.12-0.877l9.841-9.843-4.24-4.236-9.841 9.841z"></path>
      <path d="M30.799 8.646l4.286-2.216 2.244-4.338-2.092-2.092-4.336 2.246-2.22 4.282-5.213 5.219 2.114 2.118z"></path>
      <path d="M31.738 20.021l-0.404-0.040c-0.731 0-1.425 0.15-2.072 0.39l-12.303-12.304c0.24-0.647 0.39-1.341 0.39-2.072l-0.040-0.404c-0.212-3.119-2.781-5.591-5.954-5.591-0.923 0-1.788 0.226-2.57 0.599l3.982 3.982c0.21 0.21 0.354 0.458 0.45 0.719 0.262 0.707 0.12 1.535-0.45 2.106-0.39 0.39-0.901 0.585-1.413 0.585-0.236 0-0.47-0.052-0.693-0.136-0.262-0.1-0.51-0.24-0.719-0.452l-3.982-3.98c-0.374 0.781-0.599 1.646-0.599 2.57 0 3.173 2.472 5.743 5.591 5.954l0.404 0.040c0.731 0 1.425-0.15 2.072-0.388l12.3 12.302c-0.236 0.647-0.386 1.341-0.386 2.072l0.042 0.404c0.208 3.121 2.779 5.591 5.952 5.591 0.923 0 1.79-0.222 2.57-0.599l-3.982-3.982c-0.208-0.208-0.354-0.458-0.454-0.717-0.262-0.707-0.12-1.537 0.454-2.108 0.386-0.39 0.901-0.585 1.413-0.585 0.236 0 0.468 0.050 0.695 0.136 0.262 0.098 0.511 0.238 0.717 0.45l3.982 3.982c0.376-0.783 0.599-1.646 0.599-2.57-0.002-3.173-2.474-5.743-5.593-5.954z"></path>
    </symbol>
    <symbol id="icon-speed-meter" viewBox="0 0 43 32">
      <title>speed-meter</title>
      <path d="M12.212 11.373c0.009-0.137-0.037-0.272-0.128-0.375l-4.101-4.666c-0.091-0.103-0.218-0.166-0.356-0.175s-0.272 0.037-0.375 0.128c-1.884 1.657-3.449 3.61-4.649 5.806-0.066 0.121-0.081 0.262-0.043 0.394s0.128 0.243 0.248 0.309l5.451 2.98c0.079 0.043 0.164 0.064 0.248 0.064 0.183 0 0.361-0.097 0.455-0.269 0.794-1.452 1.828-2.743 3.075-3.839 0.103-0.090 0.166-0.218 0.175-0.355z"></path>
      <path d="M14.042 9.645c0.093 0.175 0.272 0.275 0.458 0.275 0.082 0 0.165-0.019 0.242-0.060 1.461-0.775 3.033-1.28 4.672-1.503 0.283-0.038 0.482-0.299 0.443-0.583l-0.835-6.156c-0.038-0.283-0.3-0.482-0.583-0.443-2.489 0.338-4.875 1.105-7.093 2.282-0.252 0.134-0.349 0.447-0.215 0.7l2.911 5.488z"></path>
      <path d="M7.373 17.976l-5.995-1.627c-0.132-0.036-0.274-0.018-0.393 0.051s-0.206 0.181-0.242 0.314c-0.493 1.817-0.743 3.7-0.743 5.596 0 0.325 0.008 0.65 0.024 0.996 0.013 0.277 0.242 0.494 0.517 0.494 0.008 0 0.016-0 0.024-0.001l6.205-0.287c0.137-0.006 0.266-0.067 0.359-0.168s0.141-0.236 0.135-0.373c-0.011-0.233-0.016-0.449-0.016-0.661 0-1.256 0.165-2.5 0.49-3.699 0.075-0.276-0.088-0.56-0.364-0.635z"></path>
      <path d="M30.579 3.088c-2.259-1.089-4.673-1.764-7.174-2.006-0.137-0.014-0.273 0.028-0.379 0.116s-0.173 0.213-0.186 0.35l-0.599 6.183c-0.028 0.285 0.181 0.538 0.465 0.565 1.649 0.16 3.238 0.604 4.726 1.321 0.071 0.034 0.148 0.051 0.225 0.051 0.058 0 0.115-0.010 0.171-0.029 0.13-0.045 0.236-0.14 0.296-0.264l2.697-5.596c0.124-0.257 0.016-0.567-0.241-0.691z"></path>
      <path d="M39.704 11.772c0.033-0.133 0.013-0.274-0.058-0.392-1.285-2.149-2.923-4.041-4.868-5.624-0.107-0.087-0.243-0.127-0.38-0.113s-0.262 0.082-0.349 0.188l-3.92 4.819c-0.087 0.107-0.127 0.243-0.113 0.38s0.082 0.262 0.188 0.349c1.287 1.047 2.371 2.298 3.22 3.72 0.097 0.162 0.269 0.252 0.445 0.252 0.090 0 0.182-0.024 0.265-0.073l5.332-3.187c0.118-0.070 0.203-0.185 0.236-0.318z"></path>
      <path d="M41.684 15.926c-0.086-0.273-0.376-0.425-0.649-0.339l-5.928 1.857c-0.273 0.085-0.425 0.376-0.339 0.649 0.425 1.358 0.641 2.777 0.641 4.216 0 0.212-0.005 0.428-0.016 0.661-0.006 0.137 0.042 0.271 0.135 0.373s0.221 0.162 0.359 0.168l6.205 0.287c0.008 0 0.016 0.001 0.024 0.001 0.275 0 0.504-0.216 0.517-0.494 0.016-0.345 0.024-0.671 0.024-0.996-0-2.176-0.327-4.323-0.973-6.383z"></path>
      <path d="M21.31 21.21c-0.089 0-0.178 0.003-0.267 0.008l-8.409-4.962c-0.206-0.122-0.467-0.091-0.64 0.074s-0.214 0.425-0.101 0.636l4.587 8.598c-0.017 0.166-0.026 0.333-0.026 0.501 0 1.297 0.505 2.516 1.422 3.433s2.136 1.422 3.433 1.422 2.516-0.505 3.433-1.422c0.917-0.917 1.422-2.136 1.422-3.433s-0.505-2.516-1.422-3.433c-0.917-0.917-2.136-1.422-3.433-1.422z"></path>
    </symbol>
    <symbol id="icon-linux" viewBox="0 0 32 32">
      <title>linux</title>
      <path d="M28.817 25.693c-0.938-0.384-1.34-0.894-1.301-1.655 0.040-0.888-0.464-1.539-0.703-1.796 0.145-0.552 0.567-2.463 0-4.122-0.609-1.776-2.468-4.489-4.386-7.156-0.785-1.095-0.822-2.286-0.865-3.664-0.041-1.315-0.087-2.805-0.821-4.462-0.797-1.804-2.397-2.838-4.389-2.838-1.185 0-2.402 0.37-3.338 1.016-1.917 1.323-1.663 4.207-1.496 6.116 0.023 0.261 0.045 0.508 0.057 0.719 0.112 1.869 0.010 2.854-0.123 3.154-0.086 0.196-0.509 0.753-0.957 1.342-0.463 0.61-0.988 1.301-1.418 1.945-0.513 0.775-0.928 1.96-1.329 3.105-0.293 0.838-0.57 1.63-0.84 2.103-0.511 0.91-0.384 1.759-0.278 2.151-0.193 0.134-0.473 0.399-0.709 0.898-0.285 0.609-0.864 0.936-2.067 1.167-0.553 0.113-0.934 0.346-1.134 0.691-0.29 0.503-0.132 1.134 0.012 1.566 0.213 0.635 0.080 1.036-0.161 1.765-0.056 0.168-0.119 0.359-0.183 0.569-0.101 0.332-0.064 0.633 0.108 0.896 0.454 0.695 1.78 0.94 3.145 1.101 0.815 0.097 1.707 0.423 2.57 0.738 0.845 0.309 1.719 0.628 2.514 0.725 0.121 0.015 0.24 0.023 0.356 0.023 1.2 0 1.742-0.796 1.914-1.123 0.431-0.088 1.917-0.37 3.449-0.407 1.529-0.044 3.009 0.258 3.428 0.352 0.132 0.252 0.479 0.828 1.033 1.125 0.304 0.166 0.728 0.262 1.162 0.262 0 0 0 0 0 0 0.463 0 1.345-0.11 2.042-0.843 0.696-0.737 2.434-1.679 3.704-2.366 0.283-0.153 0.548-0.297 0.781-0.427 0.713-0.395 1.102-0.96 1.068-1.55-0.029-0.49-0.353-0.919-0.846-1.121zM13.030 25.551c-0.089-0.625-0.893-1.245-1.825-1.964-0.762-0.587-1.625-1.253-1.863-1.816-0.492-1.163-0.104-3.207 0.572-4.26 0.334-0.527 0.607-1.326 0.87-2.1 0.285-0.835 0.579-1.698 0.909-2.076 0.522-0.59 1.004-1.738 1.089-2.642 0.488 0.466 1.246 1.058 1.946 1.058 0.108 0 0.212-0.014 0.312-0.042 0.479-0.138 1.183-0.545 1.864-0.939 0.587-0.339 1.311-0.758 1.584-0.796 0.467 0.671 3.182 6.679 3.459 8.608 0.22 1.527-0.012 2.789-0.129 3.283-0.094-0.013-0.206-0.023-0.323-0.023-0.756 0-0.956 0.413-1.008 0.659-0.134 0.64-0.148 2.688-0.15 3.148-0.273 0.347-1.656 1.983-3.641 2.277-0.809 0.117-1.564 0.177-2.244 0.177-0.582 0-0.953-0.045-1.107-0.068l-0.998-1.141c0.393-0.194 0.787-0.604 0.683-1.343zM14.296 6.73c-0.031 0.013-0.062 0.028-0.092 0.043-0.003-0.068-0.010-0.136-0.021-0.205-0.109-0.627-0.525-1.082-0.988-1.082-0.034 0-0.069 0.003-0.107 0.008-0.276 0.046-0.492 0.253-0.611 0.547 0.104-0.645 0.469-1.122 0.902-1.122 0.509 0 0.939 0.686 0.939 1.497 0 0.102-0.007 0.204-0.023 0.313zM18.25 7.214c0.047-0.148 0.072-0.309 0.072-0.476 0-0.736-0.467-1.312-1.063-1.312-0.582 0-1.056 0.589-1.056 1.312 0 0.049 0.002 0.099 0.007 0.148-0.031-0.012-0.061-0.023-0.090-0.035-0.067-0.203-0.101-0.415-0.101-0.631 0-0.88 0.562-1.596 1.254-1.596s1.254 0.716 1.254 1.596c0 0.366-0.101 0.715-0.276 0.993zM17.74 8.927c-0.010 0.044-0.031 0.064-0.266 0.186-0.118 0.062-0.266 0.138-0.45 0.251l-0.123 0.075c-0.495 0.3-1.654 1.003-1.969 1.044-0.214 0.029-0.346-0.054-0.643-0.256-0.067-0.046-0.138-0.094-0.214-0.143-0.536-0.352-0.88-0.739-0.919-0.89 0.175-0.135 0.608-0.473 0.829-0.673 0.45-0.418 0.903-0.7 1.127-0.7 0.012 0 0.023 0.001 0.034 0.003 0.263 0.046 0.913 0.306 1.387 0.495 0.219 0.088 0.409 0.163 0.542 0.211 0.42 0.144 0.639 0.329 0.665 0.398zM21.511 28.48c0.237-1.068 0.51-2.521 0.465-3.378-0.010-0.195-0.027-0.406-0.044-0.611-0.031-0.383-0.077-0.952-0.030-1.121 0.009-0.004 0.020-0.008 0.032-0.011 0.002 0.49 0.108 1.467 0.89 1.807 0.233 0.102 0.499 0.153 0.791 0.153 0.783 0 1.651-0.384 2.007-0.74 0.209-0.209 0.386-0.466 0.509-0.669 0.027 0.079 0.044 0.182 0.035 0.315-0.046 0.722 0.305 1.681 0.973 2.034l0.097 0.051c0.238 0.125 0.87 0.457 0.88 0.614-0 0-0.005 0.019-0.041 0.051-0.158 0.145-0.716 0.429-1.254 0.704-0.956 0.488-2.039 1.041-2.526 1.553-0.685 0.721-1.46 1.205-1.928 1.205-0.056 0-0.108-0.007-0.153-0.022-0.508-0.158-0.927-0.892-0.702-1.937zM4.188 25.755c-0.052-0.243-0.093-0.434-0.049-0.62 0.032-0.137 0.71-0.285 1-0.348 0.407-0.088 0.829-0.18 1.104-0.347 0.373-0.226 0.574-0.642 0.752-1.009 0.129-0.266 0.262-0.54 0.42-0.63 0.009-0.005 0.023-0.011 0.049-0.011 0.297 0 0.919 0.624 1.278 1.182 0.091 0.141 0.259 0.423 0.454 0.749 0.583 0.976 1.381 2.312 1.798 2.759 0.376 0.403 0.984 1.177 0.834 1.84-0.11 0.515-0.693 0.934-0.83 1.027-0.050 0.011-0.112 0.017-0.184 0.017-0.798 0-2.378-0.664-3.226-1.021l-0.126-0.053c-0.474-0.199-1.248-0.324-1.996-0.445-0.595-0.096-1.411-0.228-1.546-0.348-0.11-0.123 0.018-0.522 0.13-0.875 0.081-0.253 0.164-0.515 0.21-0.789 0.065-0.437-0.011-0.793-0.072-1.079z"></path>
    </symbol>
    <symbol id="icon-mac-os-logo" viewBox="0 0 32 32">
      <title>mac-os-logo</title>
      <path d="M24.734 17.002c-0.042-4.055 3.306-5.996 3.455-6.093-1.88-2.747-4.806-3.125-5.852-3.167-2.488-0.255-4.86 1.465-6.125 1.465-1.261 0-3.213-1.431-5.279-1.393-2.717 0.042-5.219 1.581-6.619 4.011-2.822 4.897-0.723 12.149 2.026 16.125 1.345 1.943 2.949 4.125 5.052 4.048 2.026-0.081 2.791-1.312 5.242-1.312s3.139 1.312 5.282 1.273c2.182-0.042 3.561-1.982 4.894-3.93 1.544-2.256 2.179-4.442 2.219-4.551-0.051-0.028-4.25-1.635-4.294-6.476z"></path>
      <path d="M20.704 5.11c1.115-1.352 1.871-3.234 1.665-5.11-1.611 0.065-3.557 1.069-4.714 2.423-1.036 1.199-1.938 3.111-1.697 4.95 1.795 0.141 3.631-0.913 4.746-2.263z"></path>
    </symbol>

    <symbol id="icon-icon" viewBox="0 0 32 32">
      <title>icon</title>
      <path d="M9.502 25.749c0 1.795-1.455 3.251-3.251 3.251s-3.251-1.455-3.251-3.251c0-1.795 1.455-3.251 3.251-3.251s3.251 1.455 3.251 3.251z"></path>
      <path d="M7.894 19.253c2.689 0 4.875 2.186 4.875 4.878h3.252c0-4.482-3.646-8.131-8.126-8.131v3.253z"></path>
      <path d="M7.872 12.75c6.272 0 11.376 5.107 11.376 11.381h3.252c0-8.068-6.561-14.631-14.628-14.631v3.25z"></path>
      <path d="M7.872 6.25c9.858 0 17.878 8.020 17.878 17.881h3.25c0-11.654-9.476-21.131-21.127-21.131v3.25z"></path>
    </symbol>
    <symbol id="icon-customer-review" viewBox="0 0 32 32">
      <title>customer-review</title>
      <path d="M28.848 8.872c-1.942-1.409-4.504-2.184-7.214-2.184s-5.272 0.776-7.213 2.184c-2.032 1.474-3.151 3.46-3.151 5.593 0 1.99 1.003 3.884 2.825 5.332 1.681 1.336 3.926 2.179 6.345 2.386 2.611 1.899 6.441 2.97 6.727 3.048 0.141 0.040 0.288 0.060 0.435 0.060 0.597 0 1.145-0.325 1.428-0.843 0.364-0.66 0.229-1.479-0.333-1.991-0.712-0.647-1.092-1.154-1.294-1.518 1.269-0.631 2.338-1.467 3.12-2.444 0.966-1.207 1.477-2.6 1.477-4.030 0-2.132-1.119-4.118-3.152-5.593zM25.102 17.108h-6.935c-0.518 0-0.938-0.42-0.938-0.938s0.42-0.938 0.938-0.938h6.935c0.518 0 0.938 0.42 0.938 0.938s-0.42 0.938-0.938 0.938zM25.102 13.968h-6.935c-0.518 0-0.938-0.42-0.938-0.938s0.42-0.938 0.938-0.938h6.935c0.518 0 0.938 0.42 0.938 0.938s-0.42 0.938-0.938 0.938z"></path>
      <path d="M9.402 14.319c0-1.488 0.42-2.922 1.217-4.227-0.67-0.125-1.362-0.19-2.065-0.19-2.228 0-4.335 0.639-5.934 1.799-1.689 1.226-2.62 2.882-2.62 4.664 0 1.194 0.425 2.357 1.228 3.363 0.613 0.767 1.437 1.428 2.411 1.939-0.17 0.26-0.45 0.602-0.913 1.023-0.513 0.469-0.638 1.22-0.305 1.824 0.262 0.48 0.765 0.778 1.313 0.778 0.136 0 0.271-0.019 0.401-0.055 0.261-0.072 3.326-0.934 5.45-2.461 1.453-0.13 2.811-0.534 3.967-1.164-0.162-0.117-0.322-0.236-0.477-0.36-2.368-1.883-3.673-4.345-3.673-6.933z"></path>
    </symbol>
    <symbol id="icon-newspaper" viewBox="0 0 32 32">
      <title>newspaper</title>
      <path d="M26.359 3.25h-17.531c-1.32 0-2.391 1.069-2.391 2.391v1.594h-0.797c-1.32 0-2.391 1.069-2.391 2.391v15.938c0 1.76 1.427 3.188 3.188 3.188h19.125c1.76 0 3.188-1.427 3.188-3.188v-19.922c0-1.321-1.071-2.391-2.391-2.391zM27.156 25.563c0 0.878-0.716 1.594-1.594 1.594h-19.125c-0.879 0-1.594-0.716-1.594-1.594v-15.938c0-0.44 0.357-0.797 0.797-0.797h0.797v15.938c0 0.441 0.356 0.797 0.797 0.797s0.797-0.356 0.797-0.797v-19.125c0-0.44 0.357-0.797 0.797-0.797h17.531c0.439 0 0.797 0.357 0.797 0.797v19.922z"></path>
      <path d="M18.787 13.613h6.375c0.221 0 0.398-0.178 0.398-0.398s-0.178-0.398-0.398-0.398h-6.375c-0.219 0-0.398 0.178-0.398 0.398s0.179 0.398 0.398 0.398z"></path>
      <path d="M18.787 11.223h6.375c0.221 0 0.398-0.178 0.398-0.398s-0.178-0.398-0.398-0.398h-6.375c-0.219 0-0.398 0.178-0.398 0.398s0.179 0.398 0.398 0.398z"></path>
      <path d="M18.787 8.832h6.375c0.221 0 0.398-0.178 0.398-0.398s-0.178-0.398-0.398-0.398h-6.375c-0.219 0-0.398 0.178-0.398 0.398s0.179 0.398 0.398 0.398z"></path>
      <path d="M16.398 24.769h-6.375c-0.22 0-0.398 0.179-0.398 0.398 0 0.221 0.178 0.398 0.398 0.398h6.375c0.219 0 0.398-0.178 0.398-0.398 0-0.219-0.178-0.398-0.398-0.398z"></path>
      <path d="M16.398 22.378h-6.375c-0.22 0-0.398 0.179-0.398 0.398 0 0.221 0.178 0.398 0.398 0.398h6.375c0.219 0 0.398-0.178 0.398-0.398 0-0.219-0.178-0.398-0.398-0.398z"></path>
      <path d="M16.398 19.988h-6.375c-0.22 0-0.398 0.179-0.398 0.398 0 0.221 0.178 0.398 0.398 0.398h6.375c0.219 0 0.398-0.178 0.398-0.398 0-0.219-0.178-0.398-0.398-0.398z"></path>
      <path d="M25.164 24.769h-6.375c-0.221 0-0.398 0.179-0.398 0.398 0 0.221 0.178 0.398 0.398 0.398h6.375c0.219 0 0.398-0.178 0.398-0.398 0-0.219-0.179-0.398-0.398-0.398z"></path>
      <path d="M25.164 22.378h-6.375c-0.221 0-0.398 0.179-0.398 0.398 0 0.221 0.178 0.398 0.398 0.398h6.375c0.219 0 0.398-0.178 0.398-0.398 0-0.219-0.179-0.398-0.398-0.398z"></path>
      <path d="M25.164 19.988h-6.375c-0.221 0-0.398 0.179-0.398 0.398 0 0.221 0.178 0.398 0.398 0.398h6.375c0.219 0 0.398-0.178 0.398-0.398 0-0.219-0.179-0.398-0.398-0.398z"></path>
      <path d="M25.164 15.206h-15.141c-0.22 0-0.398 0.178-0.398 0.398s0.178 0.398 0.398 0.398h15.141c0.219 0 0.398-0.178 0.398-0.398s-0.179-0.398-0.398-0.398z"></path>
      <path d="M25.164 17.597h-15.141c-0.22 0-0.398 0.179-0.398 0.398 0 0.221 0.178 0.398 0.398 0.398h15.141c0.219 0 0.398-0.178 0.398-0.398 0-0.219-0.179-0.398-0.398-0.398z"></path>
      <path d="M10.422 13.609h5.578c0.441 0 0.797-0.356 0.797-0.797v-5.575c0-0.441-0.356-0.797-0.797-0.797h-5.578c-0.441 0-0.797 0.356-0.797 0.797v5.575c0 0.44 0.356 0.797 0.797 0.797zM11.219 8.031h3.984v3.984h-3.984v-3.984z"></path>
    </symbol>
    <symbol id="icon-megaphone" viewBox="0 0 32 32">
      <title>megaphone</title>
      <path d="M3.535 12.756v4.826c-0.007 1.083 0.866 1.966 1.948 1.973h0.42v-8.788h-0.395c-1.091 0.001-1.974 0.885-1.974 1.976z"></path>
      <path d="M12.064 20.552h-5.029l1.958 6.392c0.155 0.515 0.513 0.945 0.993 1.189 0.477 0.243 1.033 0.28 1.538 0.101 0.972-0.347 1.515-1.381 1.249-2.378-0.424-1.558-0.672-3.434-0.709-5.304z"></path>
      <path d="M6.9 10.767h5.173v8.788h-5.173z"></path>
      <path d="M13.071 10.751v8.836c3.054 0.129 6.003 1.412 7.964 2.497 0.998 0.554 1.961 1.17 2.881 1.846v-17.544c-0.959 0.682-1.958 1.306-2.991 1.871-2.85 1.553-5.486 2.391-7.854 2.495z"></path>
      <path d="M26.689 3.659c-0.983 0.002-1.778 0.8-1.776 1.783v19.449c0 0.981 0.795 1.776 1.776 1.776s1.776-0.795 1.776-1.776v-19.446c0.004-0.983-0.79-1.783-1.773-1.787z"></path>
    </symbol>
  </defs>
</svg>

    <div  class="wrapper wrapper--nofooter" >

      <header  class="header header--content"  role="banner">

  

  

  <nav class="menu">
    <div class="menu__logo">
      <a href="/">
        <img src="/resources/img/logo-colored.svg" alt="">
      </a>
    </div>

    <ul class="menu__list">
      <li class="menu__item">
        <a href="/"  class="menu__link"  >Home</a>
      </li>

        
      <li class="menu__item">
        <a  class="menu__link"   href="/docs/">
          Docs
        </a>
      </li>

         
      <li class="menu__item">
        <a  class="menu__link"   href="/downloads/">
          Downloads
        </a>
      </li>

         
      <li class="menu__item">
        <a  class="menu__link"   href="/community/">
          Community
        </a>
      </li>

       
      <li class="menu__item">
        <a class="menu__link menu__link--iconed" href="https://twitter.com/graalvm">
          <svg class="icon icon-social-network"><use xlink:href="#icon-social-network"></use></svg>
        </a>

        <a class="menu__link menu__link--iconed" href="https://github.com/oracle/graal">
          <svg class="icon icon-github-sign"><use xlink:href="#icon-github-sign"></use></svg>
        </a>
      </li>

      <li class="menu__item"  tabindex="0">
        <span class="github-widget">
          <!-- Place this tag where you want the button to render. -->
          <a tabindex="-1" class="github-button" href="https://github.com/oracle/graal" data-icon="octicon-star" data-show-count="true" aria-label="Star oracle/graal on GitHub">Star</a>
        </span>
      </li>

      <li class="menu__item" tabindex="-1">
        <a href="/downloads/" class="btn btn-try btn-primary">Try graalvm</a>
      </li>
    </ul>

    <div role="button" class="menu-btn menu-btn--menu js-show-menu" tabindex="-1" title="sweet hamburger">
      <div class="hamburger"><div class="inner"></div></div>
    </div>

    <!--<button class="btn btn-mobile-menu js-show-menu"><div class="inner"></div></button>-->
  </nav>
  
</header>


      <main  class="content"   aria-label="Content">
        <div class="wrapper wrapper-content">
  <article class="docs">

  <div class="container-fluid container-fluid--custom-sm">
    <div class="row">
      <div class="col-12 col-sm-12 col-md-12 col-lg-10 offset-lg-1">
          <div class="row d-flex flex-wrap">
            <div class="col-sm-3 col-bg">
              <div class="sidebar-wrap">
                <div class="sidebar">
                  
<div class="toc-floating">


<script>
var sidebar = document.currentScript.parentElement;

// 
//   $(document).ready(function(){
//     $('.sidebar-wrap').stickySidebar({
//       topSpacing: 74,
//       bottomSpacing: 40
//     });
//   });
//
// 


$(document).ready(function(){
  var header = $('.header').height();
  var invisibleBlock;

  $("#content-wrapper h1, #content-wrapper h2").each(function() {
    invisibleBlock = $(this).before("<div class='anchor' id="+ $(this).attr("id") +"></div>");
  });

  $(window).scroll(function() {
    var lastitem = null;
    $("#content-wrapper h1, #content-wrapper h2").each(function() {
      var heading = $(this);
      var position = (heading.position().top - heading.height()) - $(window).scrollTop();
      var listitem = $(sidebar).find("li").filter(function() {
        return $(this).find("a").attr("href") == "#" + heading.attr("id");
      });
      listitem.removeClass("toc-bullets-focused");
      if (position <= 0) {
        lastitem = listitem;
      }
    });
    if (lastitem != null) lastitem.addClass("toc-bullets-focused");
  });
});

</script>

<ul class="toc-bullets">

  
    

    
      
        
          <li class="toc-bullets-main">
        
          
          <a href="/docs/why-graal/">
            Why GraalVM?
          </a>
        </li>


        


        
      
    
      
        
          <li class="toc-bullets-main">
        
          
          <a href="/docs/getting-started/">
            Getting Started
          </a>
        </li>


        


        
      
    
      
        
          <li class="toc-bullets-main">
        
          
          <a href="/docs/examples/">
            Examples
          </a>
        </li>


        


        
      
    
      
        
          <li class="toc-bullets-main">
        
          
          <a href="/docs/reference-manual/compatibility/">
            Compatibility
          </a>
        </li>


        


        
      
    
      
        
          <li class="toc-bullets-main">
        
          
          <a href="/docs/release-notes/">
            Release Notes
          </a>
        </li>


        


        
      
    
      
        
          <li class="toc-bullets-main">
        
          
          <a href="/docs/reference-manual/">
            Reference Manual
          </a>
        </li>


        


        
      
    
      
        
          <li class="toc-bullets-main">
        
          
          <a href="/docs/graalvm-as-a-platform/">
            GraalVM as a Platform
          </a>
        </li>


        


        
      
    
      
        
          <li class="toc-bullets-main">
        
          
          <a href="/docs/support/">
            Support
          </a>
        </li>


        


        
      
    
      
        
          <li class="toc-bullets-main">
        
          
          <a href="/docs/faq/">
            FAQ
          </a>
        </li>


        


        
      
    
  

  

  

  

  

  

  

  

  

</ul>
<!-- Search form -->
<form class="search-container" action="/docs/search" autocomplete="on" method="get">
  <input type="text" id="search-box" name="query" placeholder="Search">
  <button type="submit" class="searchbttn"></button>
</form>

</div>

                </div>
              </div>
            </div>

            <div class="col-sm-9">
              <div id="content-wrapper" class="docs-content docs-content--with-sidebar">
                <h2 class="additional-item__title">Search Results</h2>

                <!-- Placeholder for displaying results -->
                <div class="search-results">
                  <ul id="search-results"></ul>
                </div>
              </div>
              <!-- JSON output of all the content we want to search on  -->
              <script>
                window.store = {
                  
                  "docs-release-notes-19-0":  {
                    "title": "GraalVM 19.0.x",
                    "content": "19.0.0(2019-05-09)Early Adopter Windows SupportThe early adopter builds for Windows are available for GraalVM. These includethe JDK with the GraalVM compiler enabled, the Native Image capabilities,GraalVM’s JavaScript engine and the developer tools: Chrome inspector baseddebugger, Profiler etc.. Currently there is no gu utility or the ability toadd support for the other GraalVM languages.Java  We updated the base JDK to 8u212. You can find the JDK release notes at the Oracle Technology Network website.Native ImageNative Image was extracted from the base GraalVM distribution. Currently it isavailable as an early adopter plugin. To install it, run: gu installnative-image. After this additional step, the native-image executable will bein the bin directory, as for the previous releases.There was a change in how classes are initialized in a native-image. Now, we initialize application classes at run time by default. The policy for initialization is as follows:  All JDK classes are initialized at build time.  We prove the safety of application static initializers after the analysis and initialize the safe classes.  We provide the following flags to control class initialization in a fine-grained way: --initialize-at-build-time and --initialize-at-run-time.The performance and startup impact of this change is negligible on all benchmarks that we have.This change was made to improve user experience: there is no need to writesubstitutions and to deal with instances of unsupported classes ending up in theimage heap. Their applications, given the right configuration for reflection,proxies, etc., should work without performance degradation.To allow framework authors and end users to keep the startup time at minimum weimproved functionality of --initialize-at-build-time and--initialize-at-run-time. These flags allow to specify a policy for wholepackages or individual classes. For example, if we have classes p.C1, p.C2,… , p.Cn, we can eagerly initialize this package with--initalize-at-build-time=p. If we want to delay one of the classes in packagep we can simply add --initialize-at-run-time=p.C1.The whole class hierarchy can be initialized at build time by simply passing --initalize-at-build-time on the command line.We also introduced the flag -H:+PrintClassInitialization which allows you to track what class initialization does during the image build. This flag will help you configure the build to work as intended.What should I do if I am a library author?  To get your tests back in check you can use --intialize-at-build-time which will revert to the previous behaviour.  Then use the flag -H:+PrintClassInitialization to see when classes get initialized. Based on this output you can make the proper configuration.  Configure your native-image.properties by passing --intialize-at-build-time=&amp;lt;csv-of-classes-or-packages&amp;gt; to it.  Submit a pull request to the downstream libraries with the configuration you believe works well. That way your native-image.properties will be concerned only with the classes from your framework.  There is a known issue with lambdas being initialized at build time. If your lambda inherits an interface with a default method and static fields, those fields will get pulled into the image. We will provide a fix to this bug in the next two weeks.JavaScript  Fixed various bugs that address compilation problems.R  Fixed a fatal error on Linux platforms when sending SIGINT during long computations.  Fixed issues with the installation to protected locations: the default Renviron file sets the R_LIBS_USER to a directory inside the current user’s home. Users still have to create this directory manually. Alternatively, the configure_fastr script creates the directory, but for the current user only.  Implemented missing C API: S_realloc.Ruby  Various bug fixes. Most notably fixes around OpenSSL C extension compilation.  Renamed methods in the TruffleRuby object.Ideal Graph Visualizer (IGV)  Fixed the issue with the ASTs and call trees not showing up.19.0.2(2019-06-13)This is a bug fix release for 19.0 and we recommend upgrading for all 19.0.x users.Java  Improved compilation performance of scheduler phase.  Support retrieving annotations from class initializers (see 1320).  Fixed problems related to the freetype library: 1269, 1270, 1305.  Fixed Version string reporting (it was missing 64-Bit in the string).Native image  Fixed IllegalArgumentException: Cannot create Method for class initializer (see 1320).  Fixed an issue when the build would loop forever if META-INF/native-image/native-image.properties contains --force-fallback.  Fixed the issue where fallback image generation would not respect the --no-server argument.  Fix native-image-agent=restrict configuration detection.  Added -agentlib:native-image-agent=build configuration option.LLVM interpreterAllow LLVM interpreter Context to run without allowIO(true).",
                    "url": " /docs/release-notes/19_0/"
                  },
                  
                  "docs-release-notes-19-1":  {
                    "title": "GraalVM 19.1.x",
                    "content": "19.1.0(2019-07-02)This is a feature release, we recommend upgrading to it from the 19.0.x releases.Java  Improved speed of just-in-time (JIT) compilation in GraalVM, which significantlyimproves the performance on medium length workloads.  Applied profile-guided optimization (PGO) when building the ahead-of-time (AOT) image of the compiler. This enables more aggressive optimization of the compiler itself providing better compilation throughput.Native imageWe fixed many issues that were reported on GitHub. You can browse the full list here.JavaScript  Added an experimental option js.locale to set the default locale for locale-sensitive operations.  Allow making evaluated sources internal using the sourceURL directive by prefixing the URL with internal:, e.g. //# sourceURL=internal:myname.js.  Improved code sharing across threads. Prior to this one context had to be closed before the code in it could be reused in another context , now for JavaScript contexts one can share code using ContextPolicy.SHARED without closing the context.In the following example the source code is shared between context1 and context2:public static void main(String[] args) {        try (Engine engine = Engine.create()) {            Source source = Source.create(&quot;js&quot;, &quot;21 + 21&quot;);            try (              Context context1 = Context.newBuilder().engine(engine).build();              Context context2 = Context.newBuilder().engine(engine).build()) {                context1.eval(source).asInt();                context2.eval(source).asInt();            }        }    }LLVM interpreter  Calling exit(...) in an embedded context is now a catchable PolyglotException.  Skip source path entries that we are not allowed to access. Previously, whenrunning in an embedded context with restricted access to the file system, theLLVM engine threw an exception when it could not read the source files, even ifno debugger was attached. Now it will still run. Only when a debugger isattached, an error is reported when the source file can’t be accessed.RubyThe GraalVM Ruby implementation in this version targets performance and compatibility improvements, new features implementations and multiple bug fixes. The most notable include:  Interactive sources (like the GraalVM polyglot shell) now all share the same binding (#1695).  Hash code calculation has been improved to reduce hash collisions for Hash and other cases.  eval(code, binding) for a fixed code containing blocks is now much faster. This improves the performance of rendering ERB templates containing loops.  rb_str_cat is faster due to the C string now being concatenated without first being converted to a Ruby string or having its encoding checked.A complete changelog for the Ruby component is available on GitHub.R  Strings -Inf, +NaN, and -NaN are correctly parsed to doubles including ignoring leading and trailing whitespaces.  For loop creates and initializes the control variable even if there are no iterations (#77).  Updated the output of the capabilities builtin (#78).  is.function returns true for foreign executables.The complete project changelog is available on GitHub.Python  Updated Python standard library files from 3.7.0 to 3.7.3.  Improved performance of exceptions that do not escape.  Fixed caching of core sources in a native image with a preinitialized contextfor pre-built images and libpolyglot fast startup.  Implemented support for pwd.getpwuid, os.exec, os.execv, and os.execl modules.To see a complete list of changes, please refer to the project changelog.19.1.1(2019-07-16)This is a Critical Patch Update (CPU) release for the 19.1.0 GraalVM releaseinduced by the update to OracleJDK 8u221 and OpenJDK 8u222 as the base JDKs.More details can be foundhereand here. We recommend upgradingto it from the 19.1.x and older releases.This CPU release includes fixes for the following CVEs:  CVE-2019-2813  CVE-2019-2862For more information please see the Oracle July 2019 Security Advisory.Critical fixes to GraalVM Native Image listed below went also into this version:      Fixed Reflection.getCallerClass methods sometimes failing to acquire the correct frame in the native images (#1479).        Fixed an issue that could cause header files not being generated in the working directory when compiling shared libraries ahead-of-time.  ",
                    "url": " /docs/release-notes/19_1/"
                  },
                  
                  "docs-release-notes-19-2":  {
                    "title": "GraalVM 19.2.x",
                    "content": "19.2.0(2019-08-20)This is a GraalVM feature release, we recommend upgrading to it from the 19.1.x or older releases.Native ImageWe simplified the process of collecting data for profile-guided optimizations (PGO) for GraalVM Enterprise native images. PGO allows to optimize performance of native images by analyzing collected profiles during the image generation process. Since 19.2.0 you can collect data for PGO while running your application in a just-in-time (JIT) compiled mode:$ /graal-ee-19.2.0/bin/java -Dgraal.PGOInstrument=myclass.iprof MyClass$ /graal-ee-19.2.0/bin/native-image --pgo=myclass.iprof MyClass$ ./myclassPerformanceWe improved throughput for native image in GraalVM Enterprise when no profiles are available. Running the Micronaut GraalVM example shows spending ~10% less CPU time and achieving a ~10% higher throughput of requests per CPU second in 19.2.We also solved a common usability problem when a class marked forinitialization at runtime gets inadvertently initialized at build time. The flag -H:+TraceClassInitialization was introduced to help tracing what classes got initialized at runtime.JavaScript  We added support for date, time, timezone, instant and duration interoperabilitytypes to distinguish date-like objects from multiplelanguages in polyglot contexts (see changes to GraalVM SDK and Truffle APIs).  Added Context.Builder.timeZone to set the time zone.  We implemented the Numeric separators TC39 proposal. It isavailable in ECMAScript 2020 mode (--js.ecmascript-version=2020).  We moved ICU data for internationalization APIs, e.g. date and time formatting, number formatting, collation for each individual supported language, previously distributed as separate files in &amp;lt;GRAALVM_HOME&amp;gt;/jre/languages/js/icu4j/icudt to the executable of JavaScript (js).More changes are listed in the JavaScript component changelog.LLVM InterpreterWe added preliminary support for compiling native programs to bitcode usingthe LLVM toolchain. The LLVM toolchain is a set of tools and APIs for compilingnative projects, such as C and C++, to bitcode that can be executed with theGraalVM LLVM runtime. It is aimed to simplify ahead-of-time compilation forusers and language implementers who want to use the GraalVM LLVM runtime. To doso, we provide launchers that invoke the C/C++ compiler with special flags toproduce results that can be executed by the GraalVM LLVM runtime. For moredetails, please consult the LLVM reference documentation.The toolchain is an experimental feature in this release.A complete list of changes to GraalVM LLVM runtime can be found in thechangelog.RubyA comprehensive list of changes to Ruby language component is available on GitHub. Major changes include:  Implemented support for Fiddle – an extension to translate a foreign function interface (FFI) and libffi wrapper for Ruby.  In terms of compatibility, Thread.report_on_exception is now true by defaultlike MRI 2.5+; BigDecimal compatibility has been generally improved in severalways.  Improved the performance by optimizing String methods to use the vectorinstructions when searching for a single-byte character in a String.  Fixed several bugs reported by community:          Set RbConfig::CONFIG[&#39;ruby_version&#39;] to the same value as the TruffleRuby version. This fixes reusing C extensions between different versions of TruffleRuby with Bundler (#1715).      Improved errors when interacting with single-threaded languages (#1709).      R  Added a new fastRCluster package that allows to run FastR inside GNU-R:          install in GNU-R or RStudio with: devtools::install_github(&#39;oracle/fastr/com.oracle.truffle.r.pkgs/fastRCluster&#39;);      use ?fastRCluster to learn more.        The problem that SET_ATTRIB does not validate the attributes as expected was resolved.The changelog is available on GitHub.PythonThe GraalVM Python implementation is still experimental and we are working towards improving completeness.  Implemented PyStructSequence_* C API – standard structured prediction functions.  Added support for more C API functions as PyEval_InitThreads and PyEval_ThreadsInitialized, type attributes i.e. nb_remainder, nb_subtract, overflowed and recursion_depth thread state fields.  Fixed printing of errors in the REPL and full paths in tracebacks.More details are available in the project changelog on GitHub.API Changes for GraalVM Integrators (SDK + Truffle)We implemented the ability to configure custom polyglot access configuration withPolyglotAccess.newBuilder(). It allows to configure fine-grained accesscontrol for polyglot bindings and between polyglot languages. For example, givena TruffleObject as a value, there is a need to determine language and type ofthat object. This feature is significant for GraalVM execution inside OracleRDBMS.GraalVM 19.2.0 release also added support for date, time, timezone, durationvalues in polyglot APIs, and introduced the Context.Builder.timeZone(ZoneId)class to configure the default timezone of polyglot contexts.The major GraalVM SDK and Truffle APIs changes between the versions are summarized in:  GraalVM SDK changelog  GraalVM Truffle changelogToolsA preview version of Java Flight Recorder (JFR) support has been released as a plugin for the VisualVM tool bundled with GraalVM 19.2.0. The plugin reads all JFR snapshots created from Java 7 and newer and presents the data in typical VisualVM views familiar for its users.To install the JFR support, download GraalVM 19.2.0 from graalvm.org/downloads, unzip it and run /bin/jvisualvm to start VisualVM.Use `Tools | Plugins | Available Plugins` to list all available plugins and install the VisualVM-JFR and VisualVM-JFR-Generic modules.The JFR snapshots can be opened using either the File | Load… action or by double-clicking the JFR Snapshots node and adding the snapshot into the JFR repository permanently.Please follow the documentation of your Java installation how to create JFR snapshots.JFR support is currently anexperimentalfeature. Some advanced features like analyzing JVM internals, showing eventstack traces or support for creating JFR snapshots from live processes are notavailable in the preview version and will be addressed incrementally in thefollowing releases.GraalVM Updater UtilityWe fixed an issue where GraalVM Enterprise would by default download the GraalVM Community components from GitHub. If you are using GraalVM Community – nothing changes, you can still install the components as before, and the gu will locate the necessary jar files on GitHub and correctly install them:gu install native-image ruby R pythonIf you are using GraalVM Enterprise, you can install R and llvm-toolchain components from GitHub, for example:gu install RThe other components are available from the OTN page, and can be installed from a manually downloaded file, for example to install native-image support run:gu -L install native-image-installable-svm-svmee-darwin-amd64-19.2.0.jarVersion CalendarYou can now refer to GraalVM version calendar to learn more about the GraalVM release model and prepare for upcoming releases.",
                    "url": " /docs/release-notes/19_2/"
                  },
                  
                  "docs-reference-manual-aot-compilation":  {
                    "title": "Native Image",
                    "content": "GraalVM Native ImageGraalVM Native Image allows you to ahead-of-time compile Java code to a standalone executable, called a native image. This executable includes the application, the libraries, the JDK and does not run on the Java VM, but includes necessary components like memory management and thread scheduling from a different virtual machine, called “Substrate VM”. Substrate VM is the name for the runtime components (like the deoptimizer, garbage collector, thread scheduling etc.). The resulting program has faster startup time and lower runtime memory overhead compared to a Java VM.Native Image Generator or native-image is a utility that processes all the classes of your application and their dependencies, including those from the JDK. It statically analyses these classesto determine which classes and methods are reachable and used during applicationexecution. Then it passes all this reachable code as the input to the GraalVMcompiler which ahead-of-time compiles it to the native binary.GraalVM native-image supports JVM-based languages, e.g., Java, Scala,Clojure, Kotlin. The resulting native image can, optionally, execute dynamiclanguages like Ruby, R, or Python, but it does not pre-compile their codeitself. Polyglot embeddings can also be compiled ahead-of-time. To informnative-image of guest languages used by an application, specify--language:&amp;lt;languageId&amp;gt; for each guest language used (e.g., --language:js).Warning: GraalVM Native Image isavailable as an Early Adopter technology, meaning it can be used in productionand will be supported by Oracle as part of the Oracle GraalVM Enterprise Editionsubscription, but is not covered by Oracle’s standardwarranty.Install Native ImageStarting from GraalVM 19.0, Native Image was extracted from the base distribution.This functionality can be added to the core installation with GraalVM Updater tool in a similar way as other additional components by running:gu install native-imageAfter this additional step, the native-image executable will be in the bindirectory, as for the previous releases.Take a look at the native image generation or compiling a Java and Kotlin app ahead-of-time samples.PrerequisitesFor compilation native-image depends on the local toolchain, so please makesure: glibc-devel, zlib-devel (header files for the C library and zlib)and gcc are available on your system.Another prerequisite to consider is the maximum heap size. Physical memory forrunning a JVM-based application may be insufficient to build a native image. Forserver-based image building we allow to use 80% of the reported physical RAM forall servers together, but never more than 14GB per server (for exact detailsplease consult the native-image source code). If you run with --no-serveroption, you will get the whole 80% of what is reported as physical RAM as thebaseline. This mode respects -Xmx arguments additionally.Image Generation OptionsThe native-image command line needs to provide the class path for all classesusing the familiar option from the java launcher: -cp is followed by a listof directories or .jar files, separated by :. The name of the class containingthe main method is the last argument; or you can use -jar and provide a .jarfile that specifies the main method in its manifest. The syntax of the native-image command is:      native-image [options] class to build an executable file for a class in thecurrent working directory. Invoking it executes the native-compiled code of thatclass.        native-image [options] -jar jarfile to build an image for a jar file.  There is a command-line help available. Run native-image --help to getcommands overview and native-image --help-extra to print help on non-standardoptions.You may provide additional options to the native image building:      -cp and --class-path &amp;lt;class search path of directories and zip/jar files&amp;gt;help to search for class files through separated list of directories, JAR archives, and ZIP archives;        -D&amp;lt;name&amp;gt;=&amp;lt;value&amp;gt; sets a system property for the JVM running the image generator;        -J&amp;lt;flag&amp;gt; passes &amp;lt;flag&amp;gt; directly to the JVM running the image generator;        -O&amp;lt;level&amp;gt; 0 – no optimizations, 1 – basic optimizations (default);        -ea and -da enables or disables assertions in the generated image;        --allow-incomplete-classpath allows image building with an incomplete class path and reports type resolution errors at run time when they are accessed the first time, instead of during image building;        --auto-fallback builds a stand-alone image if possible, which is a default setting, --no-fallback builds a stand-alone image or reports a failure, and --force-fallback forces building of a fallback image;        --enable-all-security-services adds all security service classes to the generated image;        --enable-http or --enable-https enables http or https support in the generated image;        --enable-url-protocols provides  a list of comma separated URL protocols to enable;        --features=&amp;lt;fqcn&amp;gt; provides a comma-separated list of fully qualified feature implementation classes;        --initialize-at-build-time=&amp;lt;comma separated list of class/package names&amp;gt; initializes classes and implicitly all of their superclasses during image building;        --initialize-at-run-time=&amp;lt;comma separated list of class/package names&amp;gt; initializes classes and implicitly all of their superclasses at run time and not during image building;        --report-unsupported-elements-at-runtime reports usage of unsupported methodsand fields at run time when they are accessed the first time, instead of as an error during image building;        --shared  builds shared library;        --static  builds statically linked executable (requires static libc and zlib) (since 1.0-rc2);        --verbose enables verbose output;        -g enables the debugging info generation. Warning: The option is available only with GraalVM Enterprise Edition.  Macro OptionsMacro-options are mainly helpful for polyglot capabilities of native images:      --language:nfi to make Truffle Native Function Interface language available;        --language:regex to make Truffle Regular Expression engine available that  exposes regular expression functionality in GraalVM supported languages;        --language:python to make sure Python is available as a language for the image;        --language:llvm to make sure LLVM bitcode is available for the image;        --language:js to make sure JavaScript is available as a language for the image;        --language:ruby to make sure Ruby is available as a language for the image;        --language:R  to make sure R is available as a language for the image;        --tool:chromeinspector  adds debugging support to a Truffle framework based language image;        --tool:profiler adds profiling support to a Truffle framework based language image.  Please note, the --language:python, --language:ruby and --language:R polyglot macro options become available once the corresponding languages engines are added to the base GraalVM installation with GraalVM Updater tool:gu install pythongu install rubygu install RNon-standard OptionsGet acquainted with the non-standard native image building options, that are subject to change through a deprecation cycle:      --no-server tells to not use server-based image building;        --server-list lists current image-build servers;        --server-list-details lists current image-build servers with more details;        --server-cleanup removes stale image-build servers entries;        --server-shutdown shuts down image-build servers under current session ID;        --server-shutdown-all shuts down all image-build servers;        --server-session=&amp;lt;custom-session-name&amp;gt; uses custom session name instead   of system provided session ID of the calling process;        --verbose-server enables verbose output for image-build server handling.  Server-side Options      --debug-attach[=&amp;lt;port&amp;gt;] attaches to debugger during image building (default  port is 8000);        --dry-run outputs the command line that would be used for image building;        --expert-options lists image build options for experts;        --expert-options-all  lists all image build options for experts (to be used at your own risk);        --configurations-path &amp;lt;search path of option-configuration directories&amp;gt; a separated list of directories to be treated as option-configuration directories;        -V&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; provides values for placeholders in native-image.properties files.  If the environment variable NATIVE_IMAGE_CONFIG_FILE is set to a Javaproperties file, a native image will use the defaults defined in there on eachinvocation.Here is an example of configuration file (saved as ~/.native-image/default.properties) :NativeImageArgs = --configurations-path /home/user/custom-image-configs                   -O1If the user has a configuration file and export NATIVE_IMAGE_CONFIG_FILE=$HOME/.native-image/default.properties in ~/.bash_profile, every time the native image gets used, it will implicitly use the argumentsspecified as NativeImageArgs, plus the arguments specified on command line.For a more comprehensive list of options please check the documentation on Github.Warning:Python source code or LLVM bitcode interpreted or compiled with GraalVMCommunity Edition will not have the same security characteristics as the samecode interpreted or compiled using GraalVM Enterprise Edition. There is aGraalVM string embedded in each image that allows to figure out the version andvariant of the base (Community or Enterprise) used to build an image.The following command will query that information from an image:strings &amp;lt;path to native-image exe or shared object&amp;gt; | grep com.oracle.svm.core.VMAssuming you have a Java class file EmptyHello.class containing an empty main methodand have generated an empty shared object emptyhello with GraalVM Native Image Generator utility of it:$ native-image -cp hello EmptyHelloBuild on Server(pid: 11228, port: 41223)[emptyhello:11228]    classlist:     149.59 ms...If you do not know what GraalVM distribution is set to the PATH environmentvariable, how to determine if a native image was compiled with Community orEnterprise Edition? Run this command:$ strings emptyhello | grep com.oracle.svm.core.VMThe expected output should match the following:com.oracle.svm.core.VM GraalVM 19.2.0 CEProfile-guided OptimizationsFor additional performance gain and higher throughput in GraalVMahead-of-time (AOT) mode, make use of profile-guided optimizations (PGO). WithPGO, you can collect the profiling data in advance and then feed it to theGraalVM native-image utility, which will use this information to optimize theperformance of the resulting binary.Warning: Profile-guided optimizations (PGO) is a GraalVM Enterprise feature.In GraalVM versions prior to 19.2.0, a commonly used technique to mitigate themissing just-in-time (JIT) optimization is to gather the execution profiles at one runand then use them to optimize subsequent compilation(s). In other words, oneneeds to create a native image with the --pgo-instrument option to collect theprofile information. The --pgo-instrument builds an instrumented native imagewith profile-guided optimization data collected of AOT compiled codein the default.iprof file, if nothing else is specified. Then you run anexample program, saving the result in default.iprof. Finally, you create asecond native image with --pgo profile.iprof flag that should be significantlyfaster.Starting from 19.2.0, you can collect profiles while running yourapplication in JIT mode and then use this information to generatea highly-optimized native binary. This maximizes the performance even more.  Run a java program in JIT mode with a -Dgraal.PGOInstrument flag to gather the profiling information:    $ java -Dgraal.PGOInstrument=myclass.iprof MyClass    Use the collected data to generate a native image:    $ native-image --pgo=myclass.iprof MyClass    Run the resulting binary:    $ ./myclass  Generating Heap DumpsGraalVM also supports monitoring and generating heap dumps of the Native Image processes.Warning: This functionality is available in the Enterprise Edition of GraalVM.To find out more about generating heap dumps of the native image processes,refer to the step-by-step documentation.Limitations of AOT CompilationTo achieve such aggressive ahead-of-time optimizations, we run an aggressive static analysis that requires a closed-world assumption.We need to know all classes and all bytecodes that are reachable at run time.Therefore, it is not possible to load new classes that have not been available during ahead-of-time-compilation.For a more detailed description of which features of Java are not supported by the native images or supported partially please refer to the documentation on the GitHub. And if you are interested in learning about the support for Java reflection, there is a separate document for Java reflection support.Operational Information for Native ImagesWhen does it make sense to run in a Native Image instead of the JVM?  When startup time and memory footprint is important.  When you want to embed Java code with existing C/C++ applicationsWhat tools work with Native Image: debugger, profilers? How to use them?  The community version does not support DWARF information. The enterprise version supports all native tools that rely on DWARF information, like debuggers (gdb) and profilers (VTune).",
                    "url": " /docs/reference-manual/aot-compilation/"
                  },
                  
                  "blog":  {
                    "title": "GraalVM Blog",
                    "content": "",
                    "url": " /blog/"
                  },
                  
                  "blog":  {
                    "title": "Blog",
                    "content": "Yay! We’re super excited to see people who love to read!Reading is underrated and, in general, everyone should read more.The blog posts by the GraalVM team are published on Medium.",
                    "url": " /blog/"
                  },
                  
                  "community":  {
                    "title": "GraalVM Community",
                    "content": "The GraalVM project embraces an open and inclusive community. We welcome users and contributors alike. Also, we support projects that extend the platform with new tools, languages, or embeddings.Stay Connected  Subscribe to low traffic graalvm-announce@oss.oracle.com for important news about GraalVM.  Follow @graalvm on Twitter and use the #GraalVM hashtag to tweet about the project or to see what others are tweeting.Community SupportWe provide free community support via public channels and always appreciate your feedback or questions.  Subscribe and post to graalvm-users@oss.oracle.com for user questions about GraalVM.  Create GitHub issues for bug reports, questions, or requests for enhancements.  Report a security vulnerability to secalert_us@oracle.com. For additional information see Reporting Vulnerabilities guide.  Join the conversation at our Gitter rooms to directly connect with the GraalVM team.ContributeGraalVM welcomes contributors to the core platform and projects that extend the platform. Please let us know about such efforts such that we can support and mention such projects on our website.  Subscribe and post to graalvm-dev@oss.oracle.com for questions related to working with GraalVM sources or extending the GraalVM ecosystem by creating new languages, tools, or embeddings.  Create GitHub pull requests for source contributions.",
                    "url": " /community/"
                  },
                  
                  "docs-reference-manual-compatibility":  {
                    "title": "GraalVM Compatibility",
                    "content": "GraalVM Language CompatibilityA key concern when evaluating a new runtime to execute your application is whether theruntime is functionally complete. We run a comprehensive set of language specification testson each push to any of the GraalVM language repositories. Sometimes those test suites areincomplete, in which case we work with third parties to improve the overall ecosystem.We also run regular tests against a subset of popular packages for each of the supportedGraalVM languages. If you are interested in checking if your package is supported, use oneof the two tools below. Specify the name of the module or package you are interested in, or drop in your package.json, Gemfile.lock, or other files containing the list of your dependencies.Note that all the processing is done on the client-side in the browser, no information is sent to any servers.We run tests on the modules from their respective repositories: NPM for node modules, RubyGems for Ruby gems, etc. We try to download the module and run its tests. If the tests pass, the compatibility checker will report the amount of passed tests for the module, for example “100.00% tests pass”. If the tests are not using the testing framework we support running, you will see the “installs but not yet tested” message. Please use the compatibility checker as the initial tool to check the compatibility and assess it further yourself. In general, unless the tests clearly fail, there is a good chance the module will run on GraalVM.            Quickly check if an NPM module, Ruby gem, or R  package is compatible with GraalVM.                                                            &amp;times;                        Check!                  Sorry, there are no compatibility results found for .        This doesn&#39;t mean  won&#39;t work with GraalVM. We just haven&#39;t had a chance to add it to our regular testing process.          We currently test:            More than 95,000 NPM modules based on mocha, jest, ava, tape, and other test frameworks.      The top 1,000 most popular Ruby gems.      The top 200 most popular R packages on CRAN.          If there is an untested module you&#39;d love to see tested by us, please let us know.            Upload your package dependency lock file to  check all your dependencies at once!                                          Drag your file here  or                                          upload                                                                      Name          Version          Status                              ",
                    "url": " /docs/reference-manual/compatibility/"
                  },
                  
                  "community-conduct":  {
                    "title": "Code of Conduct",
                    "content": "Contributor Covenant Code of ConductOur PledgeIn the interest of fostering an open and welcoming environment, we ascontributors and maintainers pledge to making participation in our project andour community a harassment-free experience for everyone, regardless of age, bodysize, disability, ethnicity, gender identity and expression, level of experience,nationality, personal appearance, race, religion, or sexual identity andorientation.Our StandardsExamples of behavior that contributes to creating a positive environmentinclude:  Using welcoming and inclusive language  Being respectful of differing viewpoints and experiences  Gracefully accepting constructive criticism  Focusing on what is best for the community  Showing empathy towards other community membersExamples of unacceptable behavior by participants include:  The use of sexualized language or imagery and unwelcome sexual attention oradvances  Trolling, insulting/derogatory comments, and personal or political attacks  Public or private harassment  Publishing others’ private information, such as a physical or electronicaddress, without explicit permission  Other conduct which could reasonably be considered inappropriate in aprofessional settingOur ResponsibilitiesProject maintainers are responsible for clarifying the standards of acceptablebehavior and are expected to take appropriate and fair corrective action inresponse to any instances of unacceptable behavior.Project maintainers have the right and responsibility to remove, edit, orreject comments, commits, code, wiki edits, issues, and other contributionsthat are not aligned to this Code of Conduct, or to ban temporarily orpermanently any contributor for other behaviors that they deem inappropriate,threatening, offensive, or harmful.ScopeThis Code of Conduct applies both within project spaces and in public spaceswhen an individual is representing the project or its community. Examples ofrepresenting a project or community include using an official project e-mailaddress, posting via an official social media account, or acting as an appointedrepresentative at an online or offline event. Representation of a project may befurther defined and clarified by project maintainers.EnforcementInstances of abusive, harassing, or otherwise unacceptable behavior may bereported by contacting the project team. Allcomplaints will be reviewed and investigated and will result in a response thatis deemed necessary and appropriate to the circumstances. The project team isobligated to maintain confidentiality with regard to the reporter of an incident.Further details of specific enforcement policies may be posted separately.Project maintainers who do not follow or enforce the Code of Conduct in goodfaith may face temporary or permanent repercussions as determined by othermembers of the project’s leadership.AttributionThis Code of Conduct is adapted from the Contributor Covenant, version 1.4,available here.",
                    "url": " /community/conduct/"
                  },
                  
                  "community-contributors":  {
                    "title": "GraalVM Contributors",
                    "content": "GraalVM ContributorsWe welcome contributions to the GraalVM project from the community and are thankful for past contributions both big and small. There have already been significant contributions to the GraalVM project from both industry and academia. Among the key academic collaborators are Johannes Kepler University Linz, TU Berlin, University of Edinburgh, LaBRI, University of California (Irvine), Purdue University, TU Dortmund, University of California (Davis), and the University of Lugano. Notable industrial contributors have been Intel, AMD, and RedHat.We want to grow the GraalVM community both in terms of language-agnostic tooling as well as new supported languages. Only a large community can make this project into a strong language virtualization technology.We offer summer internships for master or PhD students who want to join us in the mission to build a universal polyglot virtual machine. Please send your CV and preferred location (Zurich, Linz, Prague, or California) tograalvm-internships_ww_grp@oracle.com if you are interested in such an opportunity.Want to Become a GraalVM Contributor?GraalVM is an open source Oracle project community where people from all over the world contribute their work, help each other, and make GraalVM innovative. We welcome you and look forward to your contributions!Open issues or contribute your code on GitHub. Note that to submit pull requests to the GraalVM, you need to sign the Oracle Contributor Agreement.Abide by our Contributor Covenant Code of Conduct.",
                    "url": " /community/contributors/"
                  },
                  
                  "downloads":  {
                    "title": "Downloads",
                    "content": "",
                    "url": " /downloads/"
                  },
                  
                  "docs-reference-manual-embed":  {
                    "title": "Embed Languages with the GraalVM Polyglot API",
                    "content": "IntroductionThe GraalVM Polyglot API lets you embed and run code from guest languages in JVM-based host applications.Throughout this section, you learn how to create a host application in Java thatruns on GraalVM and directly calls a guest language. You can use the tabsbeneath each code example to choose between JavaScript, R, Ruby and Python.Ensure you set up GraalVM before you begin. SeeGet Started.Alternatively, you can have a look at the reference documentation in Javadoc:  The Polyglot Package allows you to configure and run polyglot applications.  The Proxy Package allows you to mimic guest language objects using proxies.  The IO Package allows you to customize the file system access of languages.Compile and Run a Polyglot ApplicationPolyglot applications run code written in any language implemented with the Truffle Language Implementation Framework.These languages are henceforth referenced as guests languages.Complete the steps in this section to create a sample polyglotapplication that runs on GraalVM and demonstrates programming languageinteroperability.1. Create a hello-polyglot project directory.2. In your project directory, add a HelloPolyglot.java file that includesthe following code:                                  // COMPILE-CMD: javac {file}// RUN-CMD: java {file}// BEGIN-SNIPPETimport org.graalvm.polyglot.*;import org.graalvm.polyglot.proxy.*;// END-SNIPPETpublic class hello_polyglot_js {static// BEGIN-SNIPPETpublic class HelloPolyglot {    public static void main(String[] args) {        System.out.println(&quot;Hello Java!&quot;);        try (Context context = Context.create()) {            context.eval(&quot;js&quot;, &quot;print(&#39;Hello JavaScript!&#39;);&quot;);        }    }}// END-SNIPPET    public static void main(String[] args) {        HelloPolyglot.main(null);    }}                                            // COMPILE-CMD: javac {file}// RUN-CMD: java {file}// BEGIN-SNIPPETimport org.graalvm.polyglot.*;import org.graalvm.polyglot.proxy.*;// END-SNIPPETpublic class hello_polyglot_R {static// BEGIN-SNIPPETpublic class HelloPolyglot {    public static void main(String[] args) {        System.out.println(&quot;Hello Java!&quot;);        try (Context context = Context.newBuilder()                                   .allowAllAccess(true)                               .build()) {            context.eval(&quot;R&quot;, &quot;print(&#39;Hello R!&#39;);&quot;);        }    }}// END-SNIPPET    public static void main(String[] args) {        HelloPolyglot.main(null);    }}                                            // COMPILE-CMD: javac {file}// RUN-CMD: java {file}// BEGIN-SNIPPETimport org.graalvm.polyglot.*;import org.graalvm.polyglot.proxy.*;// END-SNIPPETpublic class hello_polyglot_ruby {static// BEGIN-SNIPPETpublic class HelloPolyglot {    public static void main(String[] args) {        System.out.println(&quot;Hello Java!&quot;);        try (Context context = Context.create()) {            context.eval(&quot;ruby&quot;, &quot;puts &#39;Hello Ruby!&#39;&quot;);        }    }}// END-SNIPPET    public static void main(String[] args) {        HelloPolyglot.main(null);    }}                                            // COMPILE-CMD: javac {file}// RUN-CMD: java {file}// BEGIN-SNIPPETimport org.graalvm.polyglot.*;import org.graalvm.polyglot.proxy.*;// END-SNIPPETpublic class hello_polyglot_python {static// BEGIN-SNIPPETpublic class HelloPolyglot {    public static void main(String[] args) {        System.out.println(&quot;Hello Java!&quot;);        try (Context context = Context.create()) {            context.eval(&quot;python&quot;, &quot;print(&#39;Hello Python!&#39;)&quot;);        }    }}// END-SNIPPET    public static void main(String[] args) {        HelloPolyglot.main(null);    }}                JavaScript      R      Ruby      Python       In this code:  import org.graalvm.polyglot.* imports the base API for the Polyglot API.  import org.graalvm.polyglot.proxy.* imports the proxy classes of the Polyglot API, needed in later examples.  Context provides an execution environment for guest languages.R currently requires the allowAllAccess flag to be set to true to run the example.  eval evaluates the specified snippet of guest language code.  The try with resource statement initializes the Context and ensures that itis closed after use. Closing the context ensures that all resources includingpotential native resources are freed eagerly. Closing a context is optional butrecommended. Even if a context is not closed and no longer referenced it will befreed by the garbage collector automatically.3. Run javac HelloPolyglot.java to compile HelloPolyglot.java withGraalVM.4. Run java HelloPolyglot to run the application on GraalVM.You now have a polyglot application that consists of a Java host applicationand guest language code that run on GraalVM. You can use this application withother code examples to demonstrate more advanced capabilities of thePolyglot API.To use other code examples in this section, you simply need to do the following:1. Add the code snippet to the main method of HelloPolyglot.java.2. Compile and run your polyglot application.Define Guest Language Functions as Java ValuesPolyglot applications let you take values from one programming language anduse them with other languages.Use the code example in this section with your polyglot application to showhow the Polyglot API can return JavaScript, R, Ruby or Python functions asJava values.                                  // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.*;public class function_js {    public static void main(String[] args) {// BEGIN-SNIPPETtry (Context context = Context.create()) {    Value function = context.eval(&quot;js&quot;, &quot;x =&amp;gt; x+1&quot;);    assert function.canExecute();    int x = function.execute(41).asInt();    assert x == 42;}// END-SNIPPET    }}                                            // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.*;public class function_R {    public static void main(String[] args) {// BEGIN-SNIPPETtry (Context context = Context.newBuilder()                           .allowAllAccess(true)                       .build()) {    Value function = context.eval(&quot;R&quot;, &quot;function(x) x + 1&quot;);    assert function.canExecute();    int x = function.execute(41).asInt();    assert x == 42;}// END-SNIPPET    }}                                            // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.*;public class function_ruby {    public static void main(String[] args) {// BEGIN-SNIPPETtry (Context context = Context.create()) {    Value function = context.eval(&quot;ruby&quot;, &quot;proc { |x| x + 1 }&quot;);    assert function.canExecute();    int x = function.execute(41).asInt();    assert x == 42;} // END-SNIPPET    }}                                            // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.*;public class function_python {    public static void main(String[] args) {// BEGIN-SNIPPETtry (Context context = Context.create()) {    Value function = context.eval(&quot;python&quot;, &quot;lambda x: x + 1&quot;);    assert function.canExecute();    int x = function.execute(41).asInt();    assert x == 42;} // END-SNIPPET    }}                JavaScript      R      Ruby      Python       In this code:  Value function is a Java value that refers to a function.  The eval call parses the script and returns the guest language function.  The first assertion checks that the value returned by the code snippet can beexecuted.  The execute call executes the function with the argument 41.  The asInt call converts the result to a Java int.  The second assertion verifies that the result was incremented by one as expected.Access Guest Languages Directly from JavaPolyglot applications can readily access most language types and are notlimited to functions. Host languages, such as Java, can directly access guestlanguage values embedded in the polyglot application.Use the code example in this section with your polyglot application to showhow the Polyglot API can access objects, numbers, strings, and arrays.                                  // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.*;public class access_js_from_java {    public static void main(String[] args) {// BEGIN-SNIPPETtry (Context context = Context.create()) {    Value result = context.eval(&quot;js&quot;,                     &quot;({ &quot;                   +                        &quot;id   : 42, &quot;       +                        &quot;text : &#39;42&#39;, &quot;     +                        &quot;arr  : [1,42,3] &quot;  +                    &quot;})&quot;);    assert result.hasMembers();    int id = result.getMember(&quot;id&quot;).asInt();    assert id == 42;    String text = result.getMember(&quot;text&quot;).asString();    assert text.equals(&quot;42&quot;);    Value array = result.getMember(&quot;arr&quot;);    assert array.hasArrayElements();    assert array.getArraySize() == 3;    assert array.getArrayElement(1).asInt() == 42;}// END-SNIPPET    }}                                            // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.*;public class access_R_from_java {    public static void main(String[] args) {// BEGIN-SNIPPETtry (Context context = Context.newBuilder()                           .allowAllAccess(true)                       .build()) {    Value result = context.eval(&quot;R&quot;,                     &quot;list(&quot;                +                        &quot;id   = 42, &quot;      +                        &quot;text = &#39;42&#39;, &quot;    +                        &quot;arr  = c(1,42,3)&quot; +                    &quot;)&quot;);    assert result.hasMembers();        int id = result.getMember(&quot;id&quot;).asInt();    assert id == 42;        String text = result.getMember(&quot;text&quot;).asString();    assert text.equals(&quot;42&quot;);        Value array = result.getMember(&quot;arr&quot;);    assert array.hasArrayElements();    assert array.getArraySize() == 3;    assert array.getArrayElement(1).asInt() == 42;}// END-SNIPPET    }}                                            // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.*;public class access_ruby_from_java {    public static void main(String[] args) {// BEGIN-SNIPPETtry (Context context = Context.create()) {    Value result = context.eval(&quot;ruby&quot;,                     &quot;o = Struct.new(:id, :text, :arr).new(&quot; +                        &quot;42, &quot;       +                        &quot;&#39;42&#39;, &quot;     +                        &quot;[1,42,3] &quot;  +                    &quot;)&quot;);    assert result.hasMembers();        int id = result.getMember(&quot;id&quot;).asInt();    assert id == 42;        String text = result.getMember(&quot;text&quot;).asString();    assert text.equals(&quot;42&quot;);        Value array = result.getMember(&quot;arr&quot;);    assert array.hasArrayElements();    assert array.getArraySize() == 3;    assert array.getArrayElement(1).asInt() == 42;}// END-SNIPPET    }}                                            // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.*;public class access_python_from_java {    public static void main(String[] args) {// BEGIN-SNIPPETtry (Context context = Context.create()) {    Value result = context.eval(&quot;python&quot;,                     &quot;type(&#39;obj&#39;, (object,), {&quot; +                        &quot;&#39;id&#39;  : 42, &quot;         +                        &quot;&#39;text&#39;: &#39;42&#39;, &quot;       +                        &quot;&#39;arr&#39; : [1,42,3]&quot;     +                    &quot;})()&quot;);    assert result.hasMembers();        int id = result.getMember(&quot;id&quot;).asInt();    assert id == 42;        String text = result.getMember(&quot;text&quot;).asString();    assert text.equals(&quot;42&quot;);        Value array = result.getMember(&quot;arr&quot;);    assert array.hasArrayElements();    assert array.getArraySize() == 3;    assert array.getArrayElement(1).asInt() == 42;}// END-SNIPPET    }}                JavaScript      R      Ruby      Python       In this code:  Value result is an Object that contains three members: a number named id,a string named text, and an array named arr.  The first assertion verifies that the return value can contain members, whichindicates that the value is an object-like structure.  The id variable is initialized by reading the member with the name id fromthe resulting object. The result is then converted to a Java intusing asInt().  The next assert verifies that result has a value of 42.  The text variable is initialized using the value of the member text, which is also converted to a Java String using asString().  The following assertion verifies the result value is equal to theJava String &quot;42&quot;.  Next the arr member that holds an array is read.  Arrays return true for hasArrayElements. R array instances can havemembers and array elements at the same time.  The next assertion verifies that the size of the array equals three. ThePolyglot API supports big arrays, so the array length is of type long.  Finally we verify that the array element at index 1 equals 42. Arrayindexing with polyglot values is always zero-based, even for languages such asR where indices start with one.Access Java from Guest LanguagesPolyglot applications offer bi-directional access between guest languages andhost languages. As a result, you can pass Java objects to guest languages.Use the code example in this section with your polyglot application to show howguest languages can access primitive Java values, objects, arrays, andfunctional interfaces.To permit guest languages to access any public method or field of a Javaobject, set allowAllAccess(true) when the context is built. In this mode, the guestlanguage code must be fully trusted, as it can access other not explicitly exported Java methodsusing reflection. A later section describes how to run less trusted code with the Polyglot API.                                  // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import java.util.concurrent.Callable;import org.graalvm.polyglot.*;public class access_java_from_js {// BEGIN-SNIPPETpublic static class MyClass {    public int               id    = 42;    public String            text  = &quot;42&quot;;    public int[]             arr   = new int[]{1, 42, 3};    public Callable&amp;lt;Integer&amp;gt; ret42 = () -&amp;gt; 42;}public static void main(String[] args) {    try (Context context = Context.newBuilder()                               .allowAllAccess(true)                           .build()) {        context.getBindings(&quot;js&quot;).putMember(&quot;javaObj&quot;, new MyClass());        boolean valid = context.eval(&quot;js&quot;,               &quot;    javaObj.id         == 42&quot;          +               &quot; &amp;amp;&amp;amp; javaObj.text       == &#39;42&#39;&quot;        +               &quot; &amp;amp;&amp;amp; javaObj.arr[1]     == 42&quot;          +               &quot; &amp;amp;&amp;amp; javaObj.ret42()    == 42&quot;)           .asBoolean();        assert valid == true;    }}// END-SNIPPET}                                            // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import java.util.concurrent.Callable;import org.graalvm.polyglot.*;public class access_java_from_R {// BEGIN-SNIPPETpublic static class MyClass {    public int               id    = 42;    public String            text  = &quot;42&quot;;    public int[]             arr   = new int[]{1, 42, 3};    public Callable&amp;lt;Integer&amp;gt; ret42 = () -&amp;gt; 42;}public static void main(String[] args) {    try (Context context = Context.newBuilder()                               .allowAllAccess(true)                           .build()) {        context.getBindings(&quot;R&quot;).putMember(&quot;javaObj&quot;, new MyClass());        boolean valid = context.eval(&quot;R&quot;,               &quot;    javaObj$id         == 42&quot;   +               &quot; &amp;amp;&amp;amp; javaObj$text       == &#39;42&#39;&quot; +               &quot; &amp;amp;&amp;amp; javaObj$arr[[2]]   == 42&quot;   +               &quot; &amp;amp;&amp;amp; javaObj$ret42()    == 42&quot;)           .asBoolean();        assert valid == true;    }}// END-SNIPPET}                                            // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import java.util.concurrent.Callable;import org.graalvm.polyglot.*;public class access_java_from_ruby {// BEGIN-SNIPPETpublic static class MyClass {    public int               id    = 42;    public String            text  = &quot;42&quot;;    public int[]             arr   = new int[]{1, 42, 3};    public Callable&amp;lt;Integer&amp;gt; ret42 = () -&amp;gt; 42;}public static void main(String[] args) {    try (Context context = Context.newBuilder()                               .allowAllAccess(true)                           .build()) {        context.getPolyglotBindings().putMember(&quot;javaObj&quot;, new MyClass());        boolean valid = context.eval(&quot;ruby&quot;,               &quot;javaObj = Polyglot.import(&#39;javaObj&#39;)n&quot; +               &quot;    javaObj[:id]         == 42&quot;         +               &quot; &amp;amp;&amp;amp; javaObj[:text]       == &#39;42&#39;&quot;       +               &quot; &amp;amp;&amp;amp; javaObj[:arr][1]     == 42&quot;         +               &quot; &amp;amp;&amp;amp; javaObj[:ret42].call == 42&quot;)           .asBoolean();        assert valid == true;    }}// END-SNIPPET}                                             // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import java.util.concurrent.Callable;import org.graalvm.polyglot.*;public class access_java_from_python {// BEGIN-SNIPPETpublic static class MyClass {    public int               id    = 42;    public String            text  = &quot;42&quot;;    public int[]             arr   = new int[]{1, 42, 3};    public Callable&amp;lt;Integer&amp;gt; ret42 = () -&amp;gt; 42;}public static void main(String[] args) {    try (Context context = Context.newBuilder()                               .allowAllAccess(true)                           .build()) {        context.getPolyglotBindings().putMember(&quot;javaObj&quot;, new MyClass());        boolean valid = context.eval(&quot;python&quot;,               &quot;import polyglot n&quot;                            +               &quot;javaObj =  polyglot.import_value(&#39;javaObj&#39;)n&quot; +               &quot;javaObj[&#39;id&#39;]                == 42&quot;            +               &quot; and javaObj[&#39;text&#39;]         == &#39;42&#39;&quot;          +               &quot; and javaObj[&#39;arr&#39;][1]       == 42&quot;            +               &quot; and javaObj[&#39;ret42&#39;].call() == 42&quot;)           .asBoolean();        assert valid == true;    }}// END-SNIPPET}                JavaScript      R      Ruby      Python       In this code:  The Java class MyClass has four public fields id, text, arr andret42. The fields are initialized with 42, &quot;42&quot;, new int[]{1, 42, 3} andlambda () -&amp;gt; 42 that always returns an int value of 42.  The Java class MyClass is instantiated and exported with the name javaObjinto the polyglot scope, which allows the host and guest languages to exchangesymbols.  A guest language script is evaluated that imports the javaObj symbol andassigns it to the local variable which is also named javaObj. To avoidconflicts with variables, every value in the polyglot scope must be explicitlyimported and exported in the top-most scope of the language.  The next two lines verify the contents of the Java object by comparing itto the number 42 and the string &#39;42&#39;.  The third verification reads from the second array position and compares itto the number 42. Whether arrays are accessed using 0-based or 1-based indicesdepends on the guest language. Independently of the language, the Java arraystored in field arr is always accessed using translated 0-based indices. Forexample, in the R language, arrays are 1-based so the second array element isaccessible using index 2. In the JavaScript and Ruby languages, the secondarray element is at index 1. In all language examples, the Java array is readfrom using the same index 1.  The last line invokes the Java lambda that is contained in the field ret42and compares the result to the number value 42.  After the guest language script executes, validation takes place to ensurethat the script returns a boolean value of true as a result.Lookup Java Types from Guest LanguagesIn addition to passing Java objects to the guest language, it is possibleto allow the lookup of Java types in the guest language.Use the code example in this section with your polyglot application to show howguest languages lookup Java types and instantiate them.                                  // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.Context;public class lookup_java_from_js {public static void main(String[] args) {// BEGIN-SNIPPETtry (Context context = Context.newBuilder()                           .allowAllAccess(true)                       .build()) {    java.math.BigDecimal v = context.eval(&quot;js&quot;,            &quot;var BigDecimal = Java.type(&#39;java.math.BigDecimal&#39;);&quot; +            &quot;BigDecimal.valueOf(10).pow(20)&quot;)        .asHostObject();    assert v.toString().equals(&quot;100000000000000000000&quot;);}// END-SNIPPET}}                                            // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.Context;public class lookup_java_from_R {public static void main(String[] args) {// BEGIN-SNIPPETtry (Context context = Context.newBuilder()                           .allowAllAccess(true)                       .build()) {    java.math.BigDecimal v = context.eval(&quot;R&quot;,            &quot;BigDecimal = java.type(&#39;java.math.BigDecimal&#39;);n&quot; +             &quot;BigDecimal$valueOf(10)$pow(20)&quot;)        .asHostObject();    assert v.toString().equals(&quot;100000000000000000000&quot;);}// END-SNIPPET}}                                            // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.Context;public class lookup_java_from_ruby {public static void main(String[] args) {// BEGIN-SNIPPETtry (Context context = Context.newBuilder()                           .allowAllAccess(true)                       .build()) {    java.math.BigDecimal v = context.eval(&quot;ruby&quot;,            &quot;BigDecimal = Java.type(&#39;java.math.BigDecimal&#39;)n&quot; +             &quot;BigDecimal.valueOf(10).pow(20)&quot;)        .asHostObject();    assert v.toString().equals(&quot;100000000000000000000&quot;);}// END-SNIPPET}}                                             // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.Context;public class lookup_java_from_python {public static void main(String[] args) {// BEGIN-SNIPPETtry (Context context = Context.newBuilder()                           .allowAllAccess(true)                       .build()) {    java.math.BigDecimal v = context.eval(&quot;python&quot;,            &quot;import javan&quot; +            &quot;BigDecimal = java.type(&#39;java.math.BigDecimal&#39;)n&quot; +             &quot;BigDecimal.valueOf(10).pow(20)&quot;)        .asHostObject();    assert v.toString().equals(&quot;100000000000000000000&quot;);}// END-SNIPPET}}                JavaScript      R      Ruby      Python       In this code:  A new context is created with all access enabled (allowAllAccess(true)).  A new context is created with all access enabled (allowAllAccess(true)).  A guest language script is evaluated.  The script looks the Java type java.math.BigDecimal up and stores it in a variable named BigDecimal.  The static method BigDecimal.valueOf(long) is invoked to create newBigDecimals with value 10. In addition to looking up static Java methods, itis also possible to directly instantiate the returned Java type., e.g. inJavaScript using the new keyword.  The new decimal is used to invoke the pow instance method with 20 which calculates  10^20.  The result of the script is converted to a host object by calling asHostObject(). The return value is automatically cast to the BigDecimal type.  The result decimal string is asserted to equal to &quot;100000000000000000000&quot;.Computed Arrays Using Polyglot ProxiesThe Polyglot API includes polyglot proxy interfaces that let youcustomize Java interoperability by mimicking guest language types, such asobjects, arrays, native objects, or primitives.Use the code example in this section with your polyglot application to see howyou can implement arrays that compute their values lazily.Note: The Polyglot API supports polyglot proxies either on the JVM orin a native image executable.                                  // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.*;import org.graalvm.polyglot.proxy.*;public class proxy_js {// BEGIN-SNIPPETstatic class ComputedArray implements ProxyArray {    public Object get(long index) {        return index * 2;    }    public void set(long index, Value value) {        throw new UnsupportedOperationException();    }    public long getSize() {        return Long.MAX_VALUE;    }}public static void main(String[] args) {    try (Context context = Context.create()) {        ComputedArray arr = new ComputedArray();        context.getBindings(&quot;js&quot;).putMember(&quot;arr&quot;, arr);        long result = context.eval(&quot;js&quot;,                    &quot;arr[1] + arr[1000000000]&quot;)                .asLong();        assert result == 2000000002L;    }}// END-SNIPPET}                                            // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.Context;import org.graalvm.polyglot.Value;import org.graalvm.polyglot.proxy.ProxyArray;public class proxy_R {// BEGIN-SNIPPETstatic class ComputedArray implements ProxyArray {    public Object get(long index) {        return index * 2;    }    public void set(long index, Value value) {        throw new UnsupportedOperationException();    }    public long getSize() {        return Long.MAX_VALUE;    }}public static void main(String[] args) {    try (Context context = Context.newBuilder()                               .allowAllAccess(true)                           .build()) {        ComputedArray arr = new ComputedArray();        context.getPolyglotBindings().putMember(&quot;arr&quot;, arr);        long result = context.eval(&quot;R&quot;,               &quot;arr &amp;lt;- import(&#39;arr&#39;);&quot; +               &quot;arr[2] + arr[1000000001]&quot;)           .asLong();        assert result == 2000000002L;    }}// END-SNIPPET}                                            // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.Context;import org.graalvm.polyglot.Value;import org.graalvm.polyglot.proxy.ProxyArray;public class proxy_ruby {// BEGIN-SNIPPETstatic class ComputedArray implements ProxyArray {    public Object get(long index) {        return index * 2;    }    public void set(long index, Value value) {        throw new UnsupportedOperationException();    }    public long getSize() {        return Long.MAX_VALUE;    }}public static void main(String[] args) {    try (Context context = Context.newBuilder()                               .allowAllAccess(true)                           .build()) {        ComputedArray arr = new ComputedArray();        context.getPolyglotBindings().putMember(&quot;arr&quot;, arr);        long result = context.eval(&quot;ruby&quot;,               &quot;arr = Polyglot.import(&#39;arr&#39;) n&quot; +               &quot;arr[1] + arr[1000000000]&quot;)           .asLong();        assert result == 2000000002L;    }}// END-SNIPPET}                                            // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.Context;import org.graalvm.polyglot.Value;import org.graalvm.polyglot.proxy.ProxyArray;public class proxy_python {// BEGIN-SNIPPETstatic class ComputedArray implements ProxyArray {    public Object get(long index) {        return index * 2;    }    public void set(long index, Value value) {        throw new UnsupportedOperationException();    }    public long getSize() {        return Long.MAX_VALUE;    }}public static void main(String[] args) {    try (Context context = Context.newBuilder()                               .allowAllAccess(true)                           .build()) {        ComputedArray arr = new ComputedArray();        context.getPolyglotBindings().putMember(&quot;arr&quot;, arr);        long result = context.eval(&quot;python&quot;,               &quot;import polyglotn&quot; +               &quot;arr = polyglot.import_value(&#39;arr&#39;) n&quot; +               &quot;arr[1] + arr[1000000000]&quot;)           .asLong();        assert result == 2000000002L;    }}// END-SNIPPET}                JavaScript      R      Ruby      Python       In this code:  The Java class ComputedArray implements the proxy interface ProxyArray sothat guest languages treat instances of the Java class like arrays.  ComputedArray array overrides the method get and computes the valueusing an arithmetic expression.  The array proxy does not support write access. For this reason, it throwsan UnsupportedOperationException in the implementation of set.  The implementation for getSize returns Long.MAX_VALUE for its length.  The main method creates a new polyglot execution context.  A new instance of the ComputedArray class is then exported using the name arr.  The guest language script imports the arr symbol, which returns theexported proxy.  The second element and the 1000000000th element is accessed, summed up, andthen returned. Note that array indices from 1-based languages such as R areconverted to 0-based indices for proxy arrays.  The result of the language script is returned as a long value and verified.For more information about the polyglot proxy interfaces, see thePolyglot API JavaDoc.Run Less Trusted CodeThe Polyglot API supports running less trusted code from a third-party source.By default a polyglot context evaluates code in a less trusted mode.If the code is fully trusted, then allowAllAccess can be set to true in order to avoid any further configuration.Important: Running less trusted code is currently only supported with JavaScript.Configuring Host AccessRunning less trusted applications requires special attention to which hostmethods are exposed to the guest application. For example, if a Java method isexposed that calls System.exit then the guest application will be able to exitthe host process.In order to avoid accidentally exposed methods, no host access is allowed bydefault and every public method or field needs to be annotated with@HostAccess.Export explicitly.                                  // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import org.graalvm.polyglot.Context;import org.graalvm.polyglot.HostAccess;import org.graalvm.polyglot.PolyglotException;public class explicit_access_java_from_js {static// BEGIN-SNIPPETpublic class Employee {    private final String name;    Employee(String name) {this.name = name;}    @HostAccess.Export    public String getName() {        return name;    }}//END-SNIPPETstatic//BEGIN-SNIPPETpublic class Services {    @HostAccess.Export    public Employee createEmployee(String name) {        return new Employee(name);    }        public void exitVM() {        System.exit(1);    }}public static void main(String[] args) {    try (Context context = Context.create()) {        Services services = new Services();        context.getBindings(&quot;js&quot;).putMember(&quot;services&quot;, services);        String name = context.eval(&quot;js&quot;,                &quot;let emp = services.createEmployee(&#39;John Doe&#39;);&quot; +                 &quot;emp.getName()&quot;).asString();        assert name.equals(&quot;John Doe&quot;);                try {            context.eval(&quot;js&quot;, &quot;services.exitVM()&quot;);            assert false;        } catch (PolyglotException e) {            assert e.getMessage().endsWith(                    &quot;Unknown identifier: exitVM&quot;);        }    }}// END-SNIPPET}                      JavaScript             In this code:  The class Employee is declared with a field name of type String. Access to the getName method is explicitly allowed by annotating the method with @HostAccess.Export.  The Services class exposes two methods createEmployee and exitVM. The createEmployee method takes the name of the employee as an argument and creates a new Employee instance. The createEmployee method is annotated with @HostAccess.Export and therefore accessible to the guest application. The exitVM method is not explicitly exported and therefore not accessible.  The main method first creates new polyglot context in default configuration. It therefore evaluates code in less trusted mode.  A new Services instance is created and put into the context as global variable services.  The first evaluated script creates a new employee using the services object and returns its name.  The returned name is asserted to equal the expected name John Doe.  A second script is evaluated that calls the exitVM method on the services object. This fails with a PolyglotException as the exitVM method is not exposed to the guest application.Host access is fully customizable by creating a custom HostAccess policy.Access Privilege ConfigurationIt is possible to configure fine-grained access privileges for guest applications.The configuration can be provided using the Context.Builder class when constructing a new context.The following access parameters may be configured:  Allow access to other languages using allowPolyglotAccess.  Allow and customize access to host objects using allowHostAccess.  Allow and customize host lookup to host types using allowHostLookup.  Allow host class loading using allowHostClassLoading.  Allow the creation of threads using allowCreateThread.  Allow access to native APIs using allowNativeAccess.  Allow access to IO using allowIO and proxy file accesses using fileSystem.Important: Allowing access to class loading, native APIs or host IO must not be enabled for less trusted code as these privileges effectively allow all access.Reliable TimeoutsThe Polyglot API lets you reliably cancel guest language execution after atimeout interval. Use the code example in this section with your polyglotapplication to see how less trusted code, e.g. an infinite while loop, can be reliably canceled.                                  // COMPILE-CMD: javac {file}// RUN-CMD: java -ea {file}import java.util.Timer;import java.util.TimerTask;import java.util.concurrent.Callable;import org.graalvm.polyglot.*;public class timeout_js {public static void main(String[] args) {// BEGIN-SNIPPETtry (Context context = Context.create()) {    context.initialize(&quot;js&quot;);    Timer timer = new Timer(true);    timer.schedule(new TimerTask() {        @Override        public void run() {            context.close(true);        }    }, 1000);    try {        String lessTrustedCode = &quot;while(true);&quot;;        context.eval(&quot;js&quot;, lessTrustedCode);        assert false;    } catch (PolyglotException e) {        assert e.isCancelled();    }}// END-SNIPPET}}                      JavaScript             In this code:  The first line of code creates a new context for any language.  The second line of code ensures the language is initialized. This preventsthe execution from being canceled during context initialization.  A new java.util.Timer instance is created.  To close the context, a new TimerTask is scheduled to run after onesecond. The true parameter to close indicates that the execution should becanceled if it is currently running.  An infinite while loop is evaluated. This code willnever complete. For this reason, the timer task closes and cancels theexecution. This scenario causes a PolyglotException to be thrown.  Finally, in the exception catch block, the exception is verified asoriginating from a cancel event.Build Native Images from Polyglot ApplicationsPolyglot embeddings can also be compiled using GraalVM Native Image.By default, no language is included if the polyglot API is used.To enable guest languages the --language:&amp;lt;languageId&amp;gt; (e.g. --language:js) native image option needs to be specified.All examples on this page are also supported when compiled using Native Image Generator – the native-image utility.Currently it is required to set the --initialize-at-build-time option when building with a polyglot language. We plan to lift this restriction in future versions.The following example shows how a simple HelloWorld JavaScript application can be built using native-image:$ javac HelloPolyglot.java$ native-image --language:js --initialize-at-build-time -cp . HelloPolyglot$ ./HelloPolyglotConfiguring Native Host ReflectionAccessing host Java code from the guest application requires Java reflection in order to work.When reflection is used within a native image, the reflection configuration file is required.For this example we use JavaScript to show host access with native images.Copy the following code in a new file named AccessJavaFromJS.java.import org.graalvm.polyglot.*;import org.graalvm.polyglot.proxy.*;import java.util.concurrent.*;public class AccessJavaFromJS {    public static class MyClass {        public int               id    = 42;        public String            text  = &quot;42&quot;;        public int[]             arr   = new int[]{1, 42, 3};        public Callable&amp;lt;Integer&amp;gt; ret42 = () -&amp;gt; 42;    }    public static void main(String[] args) {        try (Context context = Context.newBuilder()                                   .allowAllAccess(true)                               .build()) {            context.getBindings(&quot;js&quot;).putMember(&quot;javaObj&quot;, new MyClass());            boolean valid = context.eval(&quot;js&quot;,                   &quot;    javaObj.id         == 42&quot;          +                   &quot; &amp;amp;&amp;amp; javaObj.text       == &#39;42&#39;&quot;        +                   &quot; &amp;amp;&amp;amp; javaObj.arr[1]     == 42&quot;          +                   &quot; &amp;amp;&amp;amp; javaObj.ret42()    == 42&quot;)               .asBoolean();            System.out.println(&quot;Valid &quot; + valid);        }    }}Next, copy the following code into reflect.json:[  { &quot;name&quot;: &quot;AccessJavaFromJS$MyClass&quot;, &quot;allPublicFields&quot;: true },  { &quot;name&quot;: &quot;java.util.concurrent.Callable&quot;, &quot;allPublicMethods&quot;: true }]Now the a native image can be created that supports host access:$ javac AccessJavaFromJS.java$ native-image --language:js --initialize-at-build-time -H:ReflectionConfigurationFiles=reflect.json -cp . AccessJavaFromJS$ ./accessjavafromjsNote that in case assertions are needed in the image the -H:+RuntimeAssertions option can be passed to native-image.For production deployments, this option should be omitted.Code Caching Across Multiple ContextsThe GraalVM Polyglot API allows enabling code caching across multiple contexts.Code caching allows compiled code to be reused and allows sources to be parsed only once.Often, code caching can reduce memory consumption and warmup time of the application.By default, code is cached within a single context instance only.In order to enable code caching between multiple contexts an explicit engine needs to be specified.The engine is specified when creating the context using the context builder.The scope of code sharing is determined by the engine instance.Code is only shared between contexts associated with one engine instance.All sources are cached by default.Caching may be disabled explicitly by setting cached(boolean cached) to false. Disabling caching may be useful in case the source is known to only be evaluated once.Consider the following code snippet as an example.import org.graalvm.polyglot.*;public class Main {    public static void main(String[] args) {        try (Engine engine = Engine.create()) {            Source source = Source.create(&quot;js&quot;, &quot;21 + 21&quot;);            try (Context context = Context.newBuilder()                                              .engine(engine)                                          .build()) {                int v = context.eval(source).asInt();                assert v == 42;            }            try (Context context = Context.newBuilder()                                              .engine(engine)                                          .build()) {                int v = context.eval(source).asInt();                assert v == 42;            }        }    }}In this code:   import org.graalvm.polyglot.* imports the base API for the Polyglot API.  Engine.create() creates a new engine instance with the default configuration.  Source.create() creates a source object for the expression “21 + 21”with “js” language, which is the language identifier for JavaScript.  Context.newBuilder().engine(engine).build() builds a new context withan explicit engine assigned to it. All contexts associated with an engine share the code.  context.eval(source).asInt() evaluates the source and returns the result as Value instance.Build a Shell for Many LanguagesWith just a few lines of code, the GraalVM Polyglot API lets you buildapplications that integrate with any guest language that is available bydefault with GraalVM.This shell implementation is agnostic to any particular guest language.BufferedReader input = new BufferedReader(new InputStreamReader(System.in));PrintStream output = System.out;Context context = Context.newBuilder().allowAllAccess(true).build();Set&amp;lt;String&amp;gt; languages = context.getEngine().getLanguages().keySet();output.println(&quot;Shell for &quot; + languages + &quot;:&quot;);String language = languages.iterator().next();for (;;) {    try {        output.print(language + &quot;&amp;gt; &quot;);        String line = input.readLine();        if (line == null) {            break;        } else if (languages.contains(line)) {            language = line;            continue;        }        Source source = Source.newBuilder(language, line, &quot;&amp;lt;shell&amp;gt;&quot;)                        .interactive(true).buildLiteral();        context.eval(source);    } catch (PolyglotException t) {        if(t.isExit()) {            break;        }        t.printStackTrace();    }}Step through with Execution ListenersGraalVM Polyglot API allows to instrument the execution of guest languages through ExecutionListener class. For example, it lets you attach an execution listener that is invoked for every statement of the guest language program. Execution listenersare designed as simple API for polyglot embedders and may become handy in, e.g., single-stepping through the program to detect less trusted code by counting the number of statements executed.import org.graalvm.polyglot.*;import org.graalvm.polyglot.management.*;public class ExecutionListenerTest {    public static void main(String[] args) {        try (Context context = Context.create(&quot;js&quot;)) {            ExecutionListener listener = ExecutionListener.newBuilder()                      .onEnter((e) -&amp;gt; System.out.println(                              e.getLocation().getCharacters()))                      .statements(true)                      .attach(context.getEngine());            context.eval(&quot;js&quot;, &quot;for (var i = 0; i &amp;lt; 2; i++);&quot;);            listener.close();        }    }}In this code:  The Context.create() call creates a new context for the guest language.  Create an execution listener builder by invoking ExecutionListeners.newBuilder().  Set onEnter event to notify when element’s execution is entered and consumed. At least one event consumer and one filtered source element needs to be enabled.  To complete the listener attachment, attach() needs to be invoked.  The statements(true) filters execution listeners to statements only.  The context.eval() call evaluates a specified snippet of guest language code.  The listener.close() closes a listener earlier, however execution listeners are automatically closed with the engine.",
                    "url": " /docs/reference-manual/embed/"
                  },
                  
                  "docs-graalvm-as-a-platform-embed":  {
                    "title": "Embed Languages with the GraalVM Polyglot API",
                    "content": "",
                    "url": " /docs/graalvm-as-a-platform/embed/"
                  },
                  
                  "community-events":  {
                    "title": "Events",
                    "content": "",
                    "url": " /community/events/"
                  },
                  
                  "docs-examples":  {
                    "title": "Examples",
                    "content": "GraalVM offers different things to different developers: high performance, polyglot aspect, embeddability, common tools for all languages, etc.On this page we have collected the applications that you can easily download, inspect, run and modify to see diverse abilities of GraalVM.Currently, you can take a look at the following demo applications:  Java Performance Examples  Simple Java Stream Benchmark  JavaScript, Java, R Polyglot Application  Building Simple Native Images of Apps  Ahead-of-time Compilation of an Application using Java and Kotlin  Running JavaScript Functions as Stored Procedures in Database",
                    "url": " /docs/examples/"
                  },
                  
                  "docs-faq":  {
                    "title": "GraalVM FAQ",
                    "content": "How is GraalVM licensed?GraalVM is distributed as Community and Enterprise editions.GraalVM Community Edition is open source software built from the sourcesavailable on GitHub and distributed underversion 2 of the GNU General Public  License with the “Classpath” Exception, which are the same terms as for Java. We alsorecommend checking the licenses ofthe individual GraalVM components (which are generally derivative of the license of a particular language). GraalVM Community is free to use for any purpose and comes with no strings attached, but also no guarantees orsupport.Oracle GraalVM Enterprise Edition is licensed under either the GraalVM OTN License Agreement, which is free for testing, evaluation, or for developing non-production applications, or under the terms of the Oracle Master License Agreement for customers.The Native Image plugin is available as an Early Adopter technology. It can be used in production and is supported by Oracle as part of your GraalVM Enterprise subscription. However, it is not covered by Oracle’s standard warranty as Oraclereserves the right to force you to migrate to newer versions in order to get support.If you have a question about your license rights and obligations, please consult the Licensing Information User Manual, contact your sales representative or send an email to graalvm_enterprise_ww_grp@oracle.com.How much does a GraalVM Enterprise subscription cost?Please consult the Oracle global price list for more information on GraalVM Enterprise offerings and pricing. Alternatively, contact your salesrepresentative to discuss subscription licensing and support terms.What does GraalVM Enterprise subscription include?GraalVM Enterprise subscription provides licensing and support for on-premises environments and includes:  Oracle premier support (24x7x365) by the Oracle GraalVM team  Access to My Oracle Support (MOS)  Improved performance and security over GraalVM Community (see GraalVM Enterprise Announcement)For Oracle Cloud customers, GraalVM Enterprisesupport is included in the Oracle Cloud subscription.Where should bugs, security issues, or enhancement requests be reported?Any security vulnerabilities in either GraalVM Community or GraalVM Enterpriseshould only be reported via email tosecalert_us@oracle.com. Please consult ourReporting Vulnerabilities guidefor more information on reporting security vulnerabilities. Do not reportsecurity issues on GitHub Issues.Please report any bugs or enhancement requests for GraalVM Community usingGitHub Issues. GraalVM Enterprise bugsor enhancement requests should be reported using My Oracle Support.We always listen to input and feedback from the community and will address issues there time permitting.How do I contribute to GraalVM?We welcome contributions to GraalVM from the community and are thankful for past contributions both big and small. We are happy to accept pull requests at GitHub Pulls. We require contributors to sign the Oracle Contributor Agreement.How can I receive updates about GraalVM?We maintain three mailing lists:  graalvm-announce@oss.oracle.com – a low traffic announcement list used by the project maintainers;  graalvm-users@oss.oracle.com – an open source user mailing list for general questions and discussions;  graalvm-dev@oss.oracle.com – a list for contributors and language implementors.Additional ways to stay up-to-date with GraalVM development is to track GraalVMat Medium blogging platform, follow the @graalvmTwitter handle, watch thegithub.com/oracle/graal repository, or see posts on GraalVM at Oracle Developers Blog and at the Oracle GraalVM Enterprise Edition Blog.How do I get support updates?Comprehensive GraalVM Enterprise support is provided by the Oracle GraalVM team via My Oracle Support.Please verify if support services are activated with your account.What is the “readiness” level of GraalVM Windows support?GraalVM Windows support is currently under development and released as“experimental” in GraalVM 19.x. The Windows preview package includes the JDKwith the GraalVM compiler enabled, Native Image capabilities, GraalVM’sJavaScript engine and the developer tools (e.g. Chrome inspector based debugger,Profiler, etc.). Currently, there is no GraalVM Updater utilitynor the ability to add support for other GraalVM languages. The GraalVM team isactively working on it, and you can follow our progress onGitHub.Can I run my existing application with GraalVM?The team behind GraalVM aims for compatibility with existing languageimplementations. Java and JavaScript programs are expected to run fullycompatible out-of-the-box. This includes the code written in other JVMlanguages, such as Scala or Kotlin, and GraalVM treats Node.js as if it is a JVMlanguage. LLVM-based languages are fully supported via the LLVM bitcodeexecution environment. For Ruby, R, and Python we are working on improvedcompatibility. Specific applications may run. Several third parties have startedtheir own development of GraalVM-based language implementations. We continue togrow the ecosystem of GraalVM languages such that GraalVM can truly run ‘anylanguage’.What makes GraalVM a true ‘polyglot’ VM?GraalVM can not only run individual languages with competitive performance, italso enables high-performance language interoperability. Languages can accesseach other’s data structures and call each other’s methods. We avoid costlyconversions of data structures and instead allow data structures to be sharedbetween languages. Our tooling is built in language-agnostic ways to unify taskslike debugging or profiling. This simplifies deployment and configurationof the runtime environment. Important VM components like thejust-in-time-compiler and garbage collector are all fully shared across alllanguages.What does it mean to run any language ‘anywhere’?GraalVM can run embedded in OpenJDK, Oracle Java or Node.js platforms,standalone, or embedded in data stores like the Oracle Database. In all scenarios, the sameunderlying compilation and language execution technology runs in-process andwith direct access to data structures of the surrounding system. Separation oflogical and physical data layout is a first class principle for GraalVM andenables flexible use of data structures without marshalling costs. We encouragethe embedding of GraalVM in other projects and publish APIs for that purpose. Weenvision a future where high-performance and standardized language executiontechnology is available without the need for provisioning separate VMdeployments.Can I use GraalVM with a microservices framework?Several Java microservices frameworks have already accepted the GraalVM Native Image technology as a platform. Examples include: Helidon, Quarkus, Micronaut.For these frameworks GraalVM Native Image significantly reduces the startup timeand runtime memory requirements.Can GraalVM run Spring applications?GraalVM can run Spring applications, compiled with OpenJDK, OracleJDK or other JVMs.Here is a Spring application example thatnot only runs on GraalVM, but also applies the R language to visualize a plot of the data, usingGraalVM polyglot capabilities.Spring Framework support of GraalVM Native Imagetechnology is in its initial stages. The ability of GraalVM to create executable native images of Spring applications is not currently supported. GraalVM Native Image has limitations on what Java functionality it can compile ahead-of-time. The GraalVM team is investigating what can be done to fully support compiling Spring applications to native images.What is the status of IDE integration?GraalVM supports major IDEs, as well as major debugging protocols. Eclipse,NetBeans, IntelliJ IDEA, Visual Studio Code are possible IDEs since they supportall languages within one environment. IntelliJ Enterprise edition has strongsupport for all languages even within one file. GraalVM provides a built-inimplementation of Chrome DevTools Protocol that, in addition to debuggingJavaScript, even enables debugging of R and Ruby applications, separately oracross languages. You can get a multilingual stacktrace that way.What are existing real-world production deployments of GraalVM?Several production deployments of GraalVM exist today. For example, Christian Thalinger from Twitter describes the production deployment ofGraalVM at Twitter and how it can help save money via improved performance inhis interview Accelerating Processing at Twitter  and how they save money using GraalVM. We thank early adopters of our technology who give us feedback on the project and help us develop new features.Does GraalVM support Java 11?Currently, GraalVM does not support Java 11. We are actively working on gettingJava 11 support completed. This is being performed in parallel with continueddevelopment on Java 8. Here is a sample Maven project that shows how to run theGraalVM JavaScript engine on JDK11 boththrough the scripting API and the polyglot API.",
                    "url": " /docs/faq/"
                  },
                  
                  "docs-reference-manual-languages-scala-getting-started":  {
                    "title": "Scala",
                    "content": "Running Scala on GraalVMGraalVM is a JVM, so you can run Java and Scala programs normally using the java command:export GRAALVM_HOME=&amp;lt;path to GraalVM&amp;gt;/Content/Homeexport PATH=$GRAALVM_HOME/bin:$PATH$GRAALVM_HOME/bin/java -versionjava version &quot;1.8.0_221&quot;Java(TM) SE Runtime Environment (build 1.8.0_221-b11)Java HotSpot(TM) 64-Bit GraalVM EE 19.2.0 (build 25.221-b11-jvmci-19.2-b02, mixed mode)If you’re using sbt as the build tool, you can specify JAVA_HOME it will use from the command line:sbt -java-home $GRAALVM_HOMEGraalVM performs really well on the Scala benchmarks, for example you can look at Renaissance benchmarks suite. Note that Scala compiler is a Scala application as well, and it benefits from GraalVM runtime and runs faster too.Native Image of Scala CompilerIn this guide, you will learn how to get started with running Scala programs ontop of GraalVM and build a native image of scalac – the Scala compiler.  Make SCALA_HOME and GRAALVM_HOME environment variables resolve to Scala 2.12.x and GraalVM respectivelyon macOS:    export GRAALVM_HOME=&amp;lt;path to GraalVM&amp;gt;/Content/Homeexport SCALA_HOME=/usr/local/opt/scala    and on Linux platforms:    export GRAALVM_HOME=&amp;lt;path to GraalVM&amp;gt;export SCALA_HOME=/usr/local/share    Clone or download the repository and navigate to the scalac-native directory:    git clone https://github.com/graalvm/graalvm-demoscd graalvm-demos/scala-days-2018/scalac-native    Build the sbt project from the scalac-substitutions directory:    cd scalac-substitutionssbt packagecd ../    Build the native image of the Scala compiler by running:    ./scalac-image.sh    The script scalac-native.sh calls the generated compiler and passes all the required parameters.If you check the directory, the produced native image, called scalac, with no dependencies on the JDK, should have appeared.    Compare the execution time to the JVM:$ time $SCALA_HOME/bin/scalac HelloWorld.scalareal0m2.315suser0m5.868ssys0m0.248s&amp;amp; time ./scalac-native HelloWorld.scalareal0m0.177suser0m0.129ssys0m0.034sWhen the Scala compiler is ahead-of-time compiled with the profile-guidedoptimization (PGO) enabled, the native scalac is as fast as the one running onthe JVM (the C2 compiler).Important: Profile-guided optimizations are available with GraalVM Enterprise Edition.Support for Scala MacrosTo support macros – functions that are called by the compiler during compilation –the macro classes must be known to the native image builder of the Scala compiler.To build a scalac native image that includes macros run:./scalac-native macros/GreetingMacros.scala -d macros/./scalac-image-macros.shNow you can compile a project that uses macros from GreetingMacros.scala:./scalac-native -cp macros/ HelloMacros.scalaRun the compiled program with:$ scala HelloMacrosHello, World!",
                    "url": " /docs/reference-manual/languages/scala/getting-started/"
                  },
                  
                  "docs-getting-started":  {
                    "title": "Getting started with GraalVM",
                    "content": "Get started with GraalVM and configure it to run programs written in Java (orother JVM-based languages), JavaScript and Node.js, Ruby, R, or Python. Thispage guides you through downloading and installing GraalVM and adding supportfor additional languages, and shows you how to run simple programs on GraalVM.Install GraalVMGraalVM is a standalone Java Development Kit to execute Java or JVM-basedlanguages (e.g. Scala, Kotlin), dynamic languages (e.g. JavaScript, R, Ruby, R,Python), LLVM-based languages (e.g. C and C++) in one shared runtime, andsupports Linux and macOS platforms on x86 64-bit systems. It is available asCommunity Edition (CE) and Enterprise Edition (EE). GraalVM Community Edition isbased on the OpenJDK 8. GraalVM Enterprise Edition is developed on top of theJava SE 1.8.0_221. Proceed to the Downloadspage and make your choice depending on your operating system and use case.In this getting started guide we will focus on working with GraalVMEnterprise Edition, obtained from the Oracle Technology Network.The base installation includes the JVM, the GraalVM compiler, the LLVM bitcodeinterpreter, and the JavaScript runtime with Node.js support – all in onepackage. GraalVM environment can be extended with:  GraalVM Native Image – a technology to compile an application ahead-of-time into a binary that runs natively on the system. Warning: GraalVM Native Image isavailable as an Early Adopter technology, meaning it can be used in productionand will be supported by Oracle as part of the Oracle GraalVM Enterprise Editionsubscription, but is not covered by Oracle’s standardwarranty.  R, Ruby and Python languages interpreters. Warning: The support for Ruby, R and Python languages is  experimental. Experimental features might never be included in a production version, or might change significantly before being considered production-ready.Getting GraalVM installed and ready-to-go should only take a few minutes. Pleasenote, unlike Java HotSpot VM or OpenJDK distributions for macOS that come as a.dmg file, GraalVM does not provide the installation wizard.  Navigate to Oracle Technology Network Downloads page and accept the license agreement.  Select and download Oracle GraalVM Enterprise Edition based on JDK8 for macOS (19.2.0).  Extract the archive to your file system. To extract the file to the current directory from the console, type:$ tar -xvf archive.tar.gz  There can be multiple JDKs installed on the macOS system and the final step is to configure the runtime environment.          Add the GraalVM bin folder to the PATH environment variable: $ export PATH=&amp;lt;path to GraalVM&amp;gt;/Contents/Home/bin:$PATH. Verify whether you are using GraalVM with the echo command: $ echo $PATH.      Set the JAVA_HOME environment variable to resolve to the GraalVM installation directory:  $ export JAVA_HOME=&amp;lt;path to GraalVM&amp;gt;/Contents/Home.        You can also specify GraalVM as the JRE or JDK installation in your Java IDE.Optionally set the JAVA_HOME environment variable to resolve to the GraalVM installation directory. You can also specify GraalVM as the JRE or JDK installation in your Java IDE.Note on macOS java_home commandThe information property file, Info.plist, is in the top level Contentsfolder. This means that GraalVM participates in the macOS specific/usr/libexec/java_home mechanism. Depending on other JDK 8 installation(s)available, it is now possible that /usr/libexec/java_home -v1.8 returns/Library/Java/JavaVirtualMachines/graalvm-ee-19.2.0/Contents/Home.You can run /usr/libexec/java_home -v1.8 -V to see the complete list of 1.8JVMs available to the java_home command. This command appears to sort the JVMsin decreasing version order and chooses the top one as the default for thespecified version. Within a specific version, the sort order appears to bestable but is unspecified.Since the executables of all language runtimes in GraalVM emulate thebehavior of the languages’ default runtimes, setting GraalVM on your PATHshould be enough to run an application with GraalVM.GraalVM’s /bin directory is similar to that of a standard JDK, but includes a set of additional launchers:  js runs a JavaScript console with GraalVM.  node is a drop-in replacement for Node.js, using GraalVM’s JavaScript engine.  lli is a high-performance LLVM bitcode interpreter integrated with GraalVM.  gu (GraalVM Updater) can be used to install language packs for Python, R, and Ruby.Notably, java runs the JVM with GraalVM’s default compiler.The Ruby, Python and R executables become available only if you install the corresponding language engines.For example, running the following command will install Ruby support:gu install rubyFor more information on using GraalVM Updater please refer to its documentation.Once the PATH environment variable is set properly, it is easy to check language versions with GraalVM launchers:$ java -version$ java -versionjava version &quot;1.8.0_221&quot;Java(TM) SE Runtime Environment (build 1.8.0_221-b11)Java HotSpot(TM) 64-Bit GraalVM EE 19.2.0 (build 25.221-b11-jvmci-19.2-b02, mixed mode)$ node -vv10.15.2$ lli --versionLLVM (GraalVM EE Native 19.2.0)If you have, e.g., the Ruby language component installed, you can check its version as well:$ ruby -vtruffleruby 19.2.0, like ruby 2.6.2, GraalVM CE Native [x86_64-darwin]Docker ContainersThe official Docker images for GraalVM CE are available from the Docker Hub:https://hub.docker.com/r/oracle/graalvm-ce/.If you want to use the Docker container with GraalVM CE, use the docker pull command:docker pull oracle/graalvm-ce:19.2.0The image is based on Oracle Linux and has GraalVM CE downloaded, unzipped and made available.It means that Java, JavaScript, Node and the LLVM interpreter are available out of the box.You can start a container and enter the bash session with the following run command:docker run -it oracle/graalvm-ce:19.2.0 bashCheck that java, js and other commands work as expected.→ docker run -it oracle/graalvm-ce:19.2.0 bashbash-4.2# java -versionopenjdk version &quot;1.8.0_222&quot;OpenJDK Runtime Environment (build 1.8.0_222-20190711112007.graal.jdk8u-src-tar-gz-b08)OpenJDK 64-Bit GraalVM CE 19.2.0 (build 25.222-b08-jvmci-19.2-b02, mixed mode)bash-4.2# node&amp;gt; 1 + 12&amp;gt; process.exit()bash-4.2# lli --versionLLVM (GraalVM CE Native 19.2.0)bash-4.2#Please note that the image contains only the components immediately available in the GraalVM CE distribution.However, the GraalVM Updater utility is on the PATH.You can install the support for additional languages like Ruby, R, or Python at will.For example, the following command installs the Ruby support (the output below is truncated for brevity):docker run -it oracle/graalvm-ce:19.2.0 bashbash-4.2# gu install rubyDownloading: Component catalogProcessing component archive: Component rubyDownloading: Component ruby[######              ]...If you want to mount a directory from the host system to have it locally available in the container,use Docker volumes.Here is a sample command that maps the /absolute/path/to/dir/no/trailing/slash directory from the host system to the /path/inside/container inside the container.docker run -it -v /absolute/path/to/dir/no/trailing/slash:/path/inside/container oracle/graalvm-ce:19.2.0 bashIf you want to create docker images that contain GraalVM Ruby, R, or Python implementation, you can use dockerfiles like the example below, which uses oracle/graalvm-ce:19.2.0 as the base image, installs Ruby support using the gu utility, then creates and runs a sample Ruby program.FROM oracle/graalvm-ce:19.2.0RUN gu install rubyWORKDIR /workdirRUN echo &#39;puts &quot;Hello from Truffleruby!nVersion: #{RUBY_DESCRIPTION}&quot;&#39; &amp;gt; app.rbCMD ruby app.rbIf you put the above snippet in the Dockerfile in the current directory,you can build and run it with the following commands.docker build -t truffleruby-demo ....$ docker run -it --rm truffleruby-demoHello from Truffleruby!Version: truffleruby 19.2.0, like ruby 2.6.2, GraalVM CE Native [x86_64-darwin]Running ApplicationsSince the executables of all language runtimes in GraalVM emulate the behavior of the languages’ default runtimes, putting GraalVM on your PATH should be enough to run your applications with GraalVM.Running JavaTake a look at this typical HelloWorld class:public class HelloWorld {  public static void main(String[] args) {    System.out.println(&quot;Hello, World!&quot;);  }}Run the following command to compile this class to bytecode and then run it on GraalVM:$ javac HelloWorld.java$ java HelloWorldHello World!You can find a collection of larger examples of Java applications you can try running with GraalVM on the examples page.Running JavaScriptGraalVM can execute plain JavaScript code, both in REPL mode and by executing script files directly.$ js&amp;gt; 1 + 23GraalVM also supports running Node.js applications. More than 95,000 npm modulesare tested and are fully compatible with GraalVM, including modules likeexpress, react, async, request, browserify, grunt, mocha, and underscore. Toinstall a Node.js module, use the npm executable in the /bin folder of theGraalVM package. The npm command is equivalent to the default Node.js commandand supports all Node.js APIs.1. Install the colors and ansispan modules using npm install:npm install colors ansispanAfter the modules are installed, you can use them from your application.2. Add the following code snippet to a file named app.js and save it in the same directory where you installed the Node.js modules:                          // RUN-CMD: rm -rf node_modules// RUN-CMD: npm install ansispan colors// RUN-CMD: node {file}// RUN-CMD: rm -r node_modules// BEGIN-SNIPPETconst http = require(&quot;http&quot;);const span = require(&quot;ansispan&quot;);require(&quot;colors&quot;);http.createServer(function (request, response) {    response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/html&quot;});    response.end(span(&quot;Hello Graal.js!&quot;.green));}).listen(8000, function() { console.log(&quot;Graal.js server running at http://127.0.0.1:8000/&quot;.red); });// END-SNIPPETsetTimeout(function() { console.log(&quot;DONE!&quot;); process.exit(); }, 2000);      3. Execute it on GraalVM using the node command:node app.jsMore information on compatibility with the Node.js and configuring GraalVM read the reference manual on JavaScript in GraalVM.Running LLVM InterpreterThe LLVM interpreter in GraalVM executes LLVM bitcode, and therefore any programming language that can be compiled to LLVM bitcode.Put this C HelloWorld into a file named hello.c:#include &amp;lt;stdio.h&amp;gt;int main() {    printf(&quot;Hello from GraalVM!n&quot;);    return 0;}You can compile hello.c to an LLVM bitcode file named hello.bc using the following command:$ clang -c -O1 -emit-llvm hello.cYou can then run hello.bc on GraalVM like this:$ lli hello.bcHello from GraalVM!More examples and information on what languages and runtimes are supported can be found in the reference manual for LLVM.Running RubyThe Ruby engine is not installed by default, but it can easily be added using GraalVM Updater:gu install rubyThis makes Ruby commands like ruby, gem, irb, rake, rdoc and ri available:$ ruby [options] program.rbGraalVM Ruby implementation uses thesame options as the standard implementation of Ruby,with some additions.$ gem install chunky_png$ ruby -r chunky_png -e &quot;puts ChunkyPNG::Color.to_hex(ChunkyPNG::Color(&#39;mintcream @ 0.5&#39;))&quot;#f5fffa80Using BundlerGraalVM implementation of Ruby ships with the Bundler environment.Therefore its installation, gem install bundler, is not needed.$ bundle exec ...More examples and additional information on Ruby support in GraalVM can be found in the reference manual for Ruby.Running RThe R engine is not installed by default, but it can easily be added using GraalVM Updater:gu install RWhen the R engine is installed, you can execute R scripts and use the R REPL with GraalVM:$ RR version 3.5.1 (FastR)...&amp;gt; 1 + 1[1] 2More examples and additional information on R support in GraalVM can be found in the reference manual for R.Running PythonGraalVM implementation of Python 3.7 has recently been started.The Python engine is not installed by default, but it can easily be added using GraalVM Updater:gu install pythonOnce the Python engine is installed, GraalVM can execute Python programs:$ graalpython...&amp;gt;&amp;gt;&amp;gt; 1 + 23&amp;gt;&amp;gt;&amp;gt; exit()More examples and additional information on Python support in GraalVM can be found in the reference manual for Python.Combine LanguagesIf enabled, using the --polyglot flag, scripts executed on GraalVM can use interoperability features to call into other languages and exchange data with them.For example, running js --jvm --polyglot example.js executes example.js in a polyglot context.If the program calls any code in other supported languages, GraalVM executes that code inthe same runtime as the example.js application. For more information on polyglot applications see the polyglot documentation.Native ImagesGraalVM can compile Java bytecode into native images to achieve faster startup and smaller footprint for your applications.The Native Image functionality is not available by default, but it can easily be added using gu install native-image command. Let’s use the HelloWorld example from above to demonstrate how to compile Java bytecode into a native image:// HelloWorld.javapublic class HelloWorld {  public static void main(String[] args) {    System.out.println(&quot;Hello, World!&quot;);  }}Run the following to compile the class to bytecode and then build a native image:$ javac HelloWorld.java$ native-image HelloWorldThis builds an executable file named helloworld in the current working directory.Invoking it executes the natively compiled code of the HelloWorld class as follows:$ ./helloworldHello, World!Polyglot Capabilities of Native ImagesGraalVM Native Image Generator also makes it easy to use polyglot capabilities.Take this example of a JSON pretty-printer using the GraalVM implementation of JavaScript:// PrettyPrintJSON.javaimport java.io.*;import java.util.stream.*;import org.graalvm.polyglot.*;public class PrettyPrintJSON {  public static void main(String[] args) throws java.io.IOException {    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));    String input = reader.lines().collect(Collectors.joining(System.lineSeparator()));    try (Context context = Context.create(&quot;js&quot;)) {      Value parse = context.eval(&quot;js&quot;, &quot;JSON.parse&quot;);      Value stringify = context.eval(&quot;js&quot;, &quot;JSON.stringify&quot;);      Value result = stringify.execute(parse.execute(input), null, 2);      System.out.println(result.asString());    }  }}The --language:js argument ensures that the JavaScript engine is available in the generated image:$ javac PrettyPrintJSON.java$ native-image --language:js --initialize-at-build-time PrettyPrintJSONThe native image generation will take several minutes as it does not just buildthe PrettyPrintJSON class, but includes building a JavaScript engine(along with the support for partial evaluation). Additionally, the image buildingrequires large amounts of physical memory, especially if you build an image withTruffle Language Implementation Framework included, which is exactly the casehere. Memory  requirements and some other limitations of ahead-of-timecompilation with GraalVM are listedhere.The resulting executable can now perform JSON pretty printing:$ ./prettyprintjson &amp;lt;&amp;lt;EOF{&quot;GraalVM&quot;:{&quot;description&quot;:&quot;Language Abstraction Platform&quot;,&quot;supports&quot;:[&quot;combining languages&quot;,&quot;embedding languages&quot;,&quot;creating native images&quot;],&quot;languages&quot;: [&quot;Java&quot;,&quot;JavaScript&quot;,&quot;Node.js&quot;, &quot;Python&quot;, &quot;Ruby&quot;,&quot;R&quot;,&quot;LLVM&quot;]}}EOFHere is the JSON output from the native executable:{  &quot;GraalVM&quot;: {    &quot;description&quot;: &quot;Language Abstraction Platform&quot;,    &quot;supports&quot;: [      &quot;combining languages&quot;,      &quot;embedding languages&quot;,      &quot;creating native images&quot;    ],    &quot;languages&quot;: [      &quot;Java&quot;,      &quot;JavaScript&quot;,      &quot;Node.js&quot;,      &quot;Python&quot;,      &quot;Ruby&quot;,      &quot;R&quot;,      &quot;LLVM&quot;    ]  }}The native image is much faster than running the same code on the JVM directly:$ time bin/java PrettyPrintJSON &amp;lt; test.json &amp;gt; /dev/nullreal0m1.101suser0m2.471ssys0m0.237s$ time ./prettyprintjson &amp;lt; test.json &amp;gt; /dev/nullreal0m0.037suser0m0.015ssys0m0.016sWhat to read next?If you want to learn what GraalVM offers to different types of teams, read the Why GraalVM page. Some of the diverse features of GraalVM are disclosed and supported with examples in Top 10 Things To Do With GraalVM article.Or, you can examine different supported languages in action by looking atexample applications. If you want to learn about the common tools GraalVM enables for the supported languages, proceed to the tools section of the reference manual.And if you are mostly interested in a specific language, more extensive documentation is available in the reference manual as well.",
                    "url": " /docs/getting-started/"
                  },
                  
                  "docs-reference-manual-glossary":  {
                    "title": "GraalVM Glossary",
                    "content": "GraalVM glossaryThis page gives you a short list of words that might need additional explanations.Polyglot API – the API to embed and run code from guest languages in JVM-based host applications.FastR – the GraalVM implementation of R compatible with GNU R.GraalVM Compiler – the just-in-time compiler for Java bytecode and managed languages implemented with Truffle Framework.GraalVM – a high performance embeddable polyglot virtual machine. When we talk about GraalVM it typically either refers to the whole project or to the virtual machine running your applications.GraalVM JavaScript – JavaScript engine and Node.js implementation on GraalVM.SimpleLanguage – a demonstration language built using the Truffle API, demonstrates most of the available Truffle features and documents their use with inline source documentation.Native Image – the native virtual machine written in Java that is used when creating native images of your applications.LLVM Runtime – the LLVM bitcode interpreter built on the GraalVM; it allows one to execute native applications with GraalVM and is used as a mechanism to run native extensions for GraalVM languages like JavaScript or Ruby.Truffle Framework – a Language Implementation Framework. Truffle Framework provides APIs to create abstract syntax trees (AST) for the semantics of your language. The GraalVM Compiler understands the Truffle trees and is able to optimize them very well.Language API – the API for building interpreters of managed languages.TruffleRuby – an implementation of the Ruby programming language on top of GraalVM.",
                    "url": " /docs/reference-manual/glossary/"
                  },
                  
                  "docs-reference-manual-graal-updater":  {
                    "title": "GraalVM Updater",
                    "content": "Component InstallationSome languages and functionalities are not part of the GraalVM core distribution and must bedownloaded and installed separately. These include:  GraalVM Native Image – a technology to compile an application ahead-of-time into a binary that runs natively on the system.  Polyglot capabilities – support for Ruby, R and Python.To assist you with this installation, these features are pre-packaged asComponents. The GraalVM installation contains the GraalVM Updaterutility, gu, that can be used to manage components. GraalVM Updater alsoverifies whether the version of the component is appropriate for your GraalVMinstallation. Component packages are released for each GraalVM release withrespective updates. Component packages downloaded for previous release(s) cannotbe used with newer ones. Add the GraalVM /bin folder to your PATHenvironment variable in order to deploy the gu installer tool.There is a command-line help available.Run gu or gu -h to get commands overview.Run gu &amp;lt;command&amp;gt; -h to get help specific for the particular command, for example gu install -h.Component Installation ModesTwo modes of a component installation are supported:Manual InstallationYou download the component package yourself and GraalVM Updater will install it.The following pre-built language packages are at your disposal:  native-image.jar  python-installable.jar  ruby-installable.jar  r-installable.jarWith the already downloaded component package archive, component.jar,the component can be installed asgu -L install component.jarwhere -L option, equivalent to --local-file, tells to install from a downloaded component archive.Installation from CatalogThere is a list of components maintained by Oracle, from which you can install acomponent just by its name. GraalVM Updater first downloads the list of components, then uses theinformation in the list to download the actual component package for you andinstall it. This is the default mode of operation.To see which components are available in the catalog, usegu availableto get a list of available components, their IDs, and descriptive names. Then,the ComponentId (for example ruby) can be used asgu install rubyand that is all!If you want to see more verbose messages during installation, you may use the-v or --verbose switch to see the download progress bar and verbose messages.Components ListInstalled components can be printed bygu listGraalVM Updater can list components in the component catalog (not necessarily installed on your machine):gu availableRebuilding ImagesGraalVM components used to create guest language implementations may change overtime, requiring a Native Image to be rebuilt. Polyglot native image and polyglotnative C library may be out of sync, particularly:  new languages may not be accessible;  removed languages may cause the native binary to fail on missing resources or libraries.To rebuild and refresh the native binaries, use the following command:gu rebuild-images [--verbose] polyglot|libpolyglot|js|llvm|python|ruby [custom native-image args]UninstallationComponents may be uninstalled from the GraalVM environment when you no longerneed them. To uninstall a specific component you need to know its ComponentId,which can be ruby, or r or python. The command to uninstall the componentis:gu remove rubyIf more components end with, for example, ruby, the installer will print anerror message that you need to use component’s full names (org.graalvm.ruby).The uninstallation removes the files created during the installation. If a filebelongs to multiple components, it will be removed when the last component usingit is removed.ProxiesIf GraalVM Updater needs to reach the component catalog, or download acomponent package, it may need to pass through your HTTP proxy, if your networkuses one. On macOS, the proxy settings are automatically obtained from the OS.On Linux, you must ensure that the http_proxy and https_proxy environmentvariables are set appropriately before you launch gu. Please refer to yourdistribution and/or desktop environment documentation for the details.Replacing Components and FilesA component may be only installed once. GraalVM Updater refuses to install acomponent if a component with the same ID is already installed. But theinstalled component may be replaced. GraalVM Updater first uninstalls thecomponent and then installs the new package. To replace a component, use the-r option. The -L option tells to treat parameters as local filename of a packaged component.gu install -L -r component.jargu install -r rubyThe process is the same as if gu remove is run first and gu install next.GraalVM Updater also refuses to overwrite existing files if the to-be-installedand existing versions differ. There are cases when you may need to refresh filecontents, if they were modified or damaged. Use the -o option:gu install -L -o component.jargu install -o rubyGraalVM Updater will just instruct to replace the contained files of acomponent. By default, it will not alter anything. You can also use -f(--force) option, which disables most of the checks and allows you to installnon-matching versions.TroubleshootingIf a language component is not installed running the code that tries to initialize the language context can result in an exception like this:java.lang.ExceptionInInitializerErrorCaused by: com.oracle.truffle.polyglot.PolyglotIllegalArgumentException: A language with id &#39;$language&#39; is not installed. Installed languages are: [js, llvm].If you see a problem like that, install the language component as explained on this page above.",
                    "url": " /docs/reference-manual/graal-updater/"
                  },
                  
                  "docs-graalvm-as-a-platform":  {
                    "title": "GraalVM as a Platform",
                    "content": "GraalVM as a PlatformThis page targets developers who would like to extend it by implementing their own language or tool.GraalVM is an open ecosystem and we invite third party systems to participate via connecting their own programming languages, tools, or platforms.For that purpose we have developed Truffle, a languages and tools development framework.Implement your own languageThe Truffle framework allows you to run programming languages efficiently on GraalVM.It simplifies language implementation by automatically deriving high-performance code from interpreters.Find details about the approach in this research paper.Implementing your own language using GraalVM will not only give you high performance.More importantly, it allows your language to connect with the rich tooling provided by the GraalVM ecosystem.To get started please see our Language Implementation section.Implement your own toolGraalVM provides a framework for creating language-agnostic tools like debuggers, profilers, or other instrumentations.In general, GraalVM provides a standardized way to express and run program code enabling cross-language research and the development of tools that are developed once and then can be applied to any language.To get started please see our Instrument Implementation section.",
                    "url": " /docs/graalvm-as-a-platform/"
                  },
                  
                  "docs-graalvm-as-a-platform-implement-instrument":  {
                    "title": "Implement Your Tools for GraalVM",
                    "content": "Getting started with Instruments in GraalVMTools are also called Instruments within the GraalVM platform.The Truffle Instrument API is used to implement such instruments.Instruments can track very fine-grained VM-level runtime events to profile, inspect, and analyze the runtime behavior of applications running on GraalVM.ExamplesThe following simple examples are intended show common use-cases that can be solved with the Instrumentation framework.  Coverage Instrument: The coverage tool that is explained in more detail below.  Debugger Instrument: A sketch on how a debugger can be implemented. Please note that Truffle already provides a Debugger Instrument that can be used directly.  Statement Profiler: A profiler that is able to profile the execution of statements.Instrumentation Event ListenersThe Truffle Instrument application programming interface is defined in the com.oracle.truffle.api.instrumentation package. Instrumentation agents can be developed by extending the TruffleInstrument class, and can be attached to a running GraalVM instance using in the Instrumenter class. Once attached to a running language runtime, instrumentation agents remain usable as long as the language runtime is not disposed. Instrumentation agents on GraalVM can monitor a variety of VM-level runtime events, including any of the following:  Source code-related events: the agent can be notified every time a new Source or SourceSection element is loaded by the monitored language runtime.  Allocation events: the agent can be notified every time a new object is allocated in the memory space of the monitored language runtime.  Language runtime and thread creation events: the agent can be notified as soon as a new execution context or a new thread for a monitored language runtime is created.  Application execution events: the agent gets notified every time a monitored application executes a specific set of language operations. Examples of such operations include language statements and expressions, thus allowing an instrumentation agent to inspect running applications with very high precision.For each execution event, instrumentation agents can define filtering criteria that will be used by the GraalVM instrumentation runtime to monitor only the relevant execution events. Currently, GraalVM instruments accept one of the following two filter types:  AllocationEventFilter to filter allocation events by allocation type.  SourceSectionFilter to filter source code locations in an application.Filters can be created using the provided builder object. For example, the following builder creates a SourceSectionFilter:SourceSectionFilter.newBuilder()                   .tagIs(StandardTag.StatementTag)                   .mimeTypeIs(&quot;x-application/js&quot;)                   .build()The filter in the example can be used to monitor the execution of all JavaScript statements in a given application. Other filtering options such as line numbers or file extensions can also be provided.Source section filters like the one in the example can use Tags to specify a set of execution events to be monitored. Language-agnostic tags such as statements and expressions are defined in the com.oracle.truffle.api.instrumentation.Tag class, and are supported by all GraalVM languages. In addition to standard tags, GraalVM languages may provide other, language-specific, tags to enable fine-grained profiling of language-specific events (as an example, the GraalVM JavaScript engine provides JavaScript-specific tags to track the usages of ECMA builtin objects such as Array, Map, or Math).Monitoring execution eventsApplication execution events enable very precise and detailed monitoring. GraalVM supports two different types of instrumentation agents to profile such events, namely:  Execution listener: an instrumentation agent that can be notified every time a given runtime event happens. Listeners implement the ExecutionEventListener interface, and cannot associate any state with source code locations.  Execution event node: an instrumentation agent that can be expressed using Truffle Framework AST nodes. Such agents extend the ExecutionEventNode class and have the same capabilities of an execution listener, but can associate state with source code locations.Simple Instrumentation AgentA simple example of a custom instrumentation agent to perform runtime code coverage can be found in the CoverageExample class. What follows is an overview of the agent, of its design, and of its capabilities.All instruments extend the TruffleInstrument abstract class, and are registered in the GraalVM runtime through the @Registration annotation:@Registration(id = CoverageExample.ID, services = Object.class)public final class CoverageExample extends TruffleInstrument {  @Override  protected void onCreate(final Env env) {  }  /* Other methods omitted... */}Instruments override the onCreate(Env env) method to perform custom operations at instrument loading time. Typically, an instrument would use this method to register itself in the existing GraalVM execution environment. As an example, an instrument using AST nodes can be registered in the following way:@Overrideprotected void onCreate(final Env env) {  SourceSectionFilter.Builder builder = SourceSectionFilter.newBuilder();  SourceSectionFilter filter = builder.tagIs(EXPRESSION).build();  Instrumenter instrumenter = env.getInstrumenter();  instrumenter.attachExecutionEventFactory(filter, new CoverageEventFactory(env));}The instrument connects itself to the running GraalVM using the attachExecutionEventFactory method, providing the following two arguments:  SourceSectionFilter: a source section filter used to inform the GraalVM about specific code sections to be tracked.  ExecutionEventNodeFactory: a Truffle Framework AST factory that provides instrumentation AST nodes to be executed by the agent every time a runtime event (as specified by the source filter) is executed.A basic ExecutionEventNodeFactory that instruments the AST nodes of an application can be implemented in the following way:public ExecutionEventNode create(final EventContext ec) {  return new ExecutionEventNode() {    @Override    public void onReturnValue(VirtualFrame vFrame, Object result) {      /*       * Code to be executed every time a filtered source code       * element is evaluated by the guest language.       */        }  };}Execution event nodes can implement certain callback methods to intercept runtime execution events. Examples include:  onEnter: executed before an AST node corresponding to a filtered source code element (e.g., a language statement or an expression) is evaluated.  onReturnValue: executed after a source code element returns a value.  onReturnExceptional: executed in case the filtered source code element throws an exception.Execution event nodes are created on a per code location basis. Therefore, they can be used to store data specific to a given source code location in the instrumented application. As an example, an instrumentation node can simply keep track of all code locations that have already been visited using a node-local flag. Such a node-local boolean flag can be used to track the execution of AST nodes in the following way:// To keep track of all source code locations executedprivate final Set&amp;lt;SourceSection&amp;gt; coverage = new HashSet&amp;lt;&amp;gt;();public ExecutionEventNode create(final EventContext ec) {  return new ExecutionEventNode() {    // Per-node flag to keep track of execution for this node    @CompilationFinal private boolean visited = false;    @Override    public void onReturnValue(VirtualFrame vFrame, Object result) {      if (!visited) {        CompilerDirectives.transferToInterpreterAndInvalidate();        visited = true;        SourceSection src = ec.getInstrumentedSourceSection();        coverage.add(src);      }    }  };}As the above code shows, an ExecutionEventNode is a valid AST node. This implies that the instrumentation code will be optimized by the GraalVM together with the instrumented application, resulting in minimal instrumentation overhead. Furthermore, this allows instrument developers to use Truffle Framework compiler directives directly from instrumentation nodes. In the example, compiler directives are used to inform the GraalVM compiler that visited can be considered compilation-final.Each instrumentation node is bound to a specific code location. Such locations can be accessed by the agent using the provided EventContext object.The context object gives instrumentation nodes access to a variety of information about the current AST nodes being executed. Examples of query APIs available to instrumentation agents through EventContext include:  hasTag to query an instrumented node for a certain node Tag (e.g., to check if a statement node is also a conditional node).  getInstrumentedSourceSection to access the SourceSection associated with the current node.  getInstrumentedNode to access the Node corresponding to the current instrumentation event.Fine-grained expression profilingInstrumentation agents can profile even fractional events such as language expressions. To this end, an agent needs to be initialized providing two source section filters:// What source sections are we interested in?SourceSectionFilter sourceSectionFilter = SourceSectionFilter.newBuilder().tagIs(JSTags.BinaryOperation.class).build();// What generates input data to track?SourceSectionFilter inputGeneratingLocations = SourceSectionFilter.newBuilder().tagIs(                        StandardTags.ExpressionTag.class).build();instrumenter.attachExecutionEventFactory(sourceSectionFilter, inputGeneratingLocations, factory);The first source section filter (sourceSectionFilter, in the example) is a normal filter equivalent to other filters described before, and is used to identify the source code locations to be monitored. The second section filter, inputGeneratingLocations, is used by the agent to specify the intermediate values that should be monitored for a certain source section. Intermediate values correspond to all observable values that are involved in the execution of a monitored code element, and are reported to the instrumentation agent by means of the onInputValue callback. As an example, let us assume an agent needs to profile all operand values provided to sum operations (i.e., +) in JavaScript:var a = 3;var b = 4;// the &#39;+&#39; expression is profiledvar c = a + b;By filtering on JavaScript Binary expressions, an instrumentation agent would be able to detect the following runtime events for the above code snippet:  onEnter() for the binary expression at line 3.  onInputValue() for the first operand of the binary operation at line 3. The value reported by the callback will be 3, that is, the value of the a local variable.  onInputValue() for the second operand of the binary operation. The value reported by the callback will be 4, that is, the value of the b local variable.  onReturnValue() for the binary expression. The value provided to the callback will be the value returned by the expression after it has completed its evaluation, that is, the value 7.By extending the source section filters to all possible events, an instrumentation agent will observe something equivalent to the following execution trace (in pseudocode):// First variable declarationonEnter - VariableWrite    onEnter - NumericLiteral    onReturnValue - NumericLiteral  onInputValue - (3)onReturnValue - VariableWrite// Second variable declarationonEnter - VariableWrite    onEnter - NumericLiteral    onReturnValue - NumericLiteral  onInputValue - (4)onReturnValue - VariableWrite// Third variable declarationonEnter - VariableWrite    onEnter - BinaryOperation        onEnter - VariableRead        onReturnValue - VariableRead      onInputValue - (3)        onEnter - VariableRead        onReturnValue - VariableRead      onInputValue - (4)          onReturnValue - BinaryOperation  onInputValue - (7)onReturnValue - VariableWriteThe onInputValue method can be used in combination with source section filters to intercept very fine-grained execution events such as intermediate values used by language expressions. The intermediate values that are accessible to the Instrumentation framework greatly depend on the instrumentation support provided by each language. Moreover, languages may provide additional metadata associated with language-specific Tag classes.Altering the execution flow of an applicationThe instrumentation capabilities that we have presented so far enable users to observe certain aspects of a running application. In addition to passive monitoring of an application’s behavior, the Instrument API features support for actively altering the behavior of an application at runtime. Such capabilities can be used to write complex instrumentation agents that affect the behavior of a running application to achieve specific runtime semantics. For example, one could alter the semantics of a running application to ensure that certain methods or functions are never executed (e.g., by throwing an exception when they are called).Instrumentation agents with such capabilities can be implemented by leveraging the onUnwind callback in execution event listeners and factories. As an example, let’s consider the following JavaScript code:function inc(x) {  return x + 1}var a = 10var b = a;// Let&#39;s call inc() with normal semanticswhile (a == b &amp;amp;&amp;amp; a &amp;lt; 100000) {  a = inc(a);  b = b + 1;}c = a;// Run inc() and alter it&#39;s return type using the instrumentreturn inc(c)An instrumentation agent that modifies the return value of inc to always be 42 can be implemented using an ExecutionEventListener, in the following way:ExecutionEventListener myListener = new ExecutionEventListener() {  @Override  public void onReturnValue(EventContext context, VirtualFrame frame, Object result) {    String callSrc = context.getInstrumentedSourceSection().getCharacters();    // is this the function call that we want to modify?    if (&quot;inc(c)&quot;.equals(callSrc)) {      CompilerDirectives.transferToInterpreter();      // notify the runtime that we will change the current execution flow      throw context.createUnwind(null);    }  }  @Override  public Object onUnwind(EventContext context, VirtualFrame frame, Object info) {    // just return 42 as the return value for this node    return 42;  }}The event listener can be executed intercepting all function calls, for example using the following instrument:@TruffleInstrument.Registration(id = &quot;UniversalAnswer&quot;, services = UniversalAnswerInstrument.class)public static class UniversalAnswerInstrument extends TruffleInstrument {  @Override  protected void onCreate(Env env) {    env.registerService(this);    env.getInstrumenter().attachListener(SourceSectionFilter.newBuilder().tagIs(CallTag.class).build(), myListener);  }}When enabled, the instrument will execute its onReturnValue callback each time a function call returns. The callback reads the associated source section (using getInstrumentedSourceSection) and looks for a specific source code pattern (the function call inc(c), in this case). As soon as such code pattern is found, the instrument throws a special runtime exception, called UnwindException, that instructs the Instrumentation framework about a change in the current application’s execution flow. The exception is intercepted by the onUnwind callback of the instrumentation agent, which can be used to return any arbitrary value to the original instrumented application. In the example, all calls to inc(c) will return 42 regardless of any application-specific data. A more realistic instrument might access and monitor several aspects of an application, and might not rely on source code locations, but rather on object instances or other application-specific data.",
                    "url": " /docs/graalvm-as-a-platform/implement-instrument/"
                  },
                  
                  "docs-graalvm-as-a-platform-implement-language":  {
                    "title": "Implement Your Language for GraalVM",
                    "content": "Introduction to SimpleLanguageWe found the easiest way to get started with implementing your own language byextending an existing SimpleLanguage.SimpleLanguage is a demonstrationlanguage built using the Truffle API.The SimpleLanguage project provides a showcase on how to use the Truffle APIsfor writing your own language. It aims to use most of the available Truffleframework features and documents their use extensively with inline sourcedocumentation.To start, please ensure maven3 andGraalVM are available in yoursystem.  Clone the SimpleLanguage repository using    $ git clone https://github.com/graalvm/simplelanguage    Set the JAVA_HOME and PATH environment variables to the GraalVM home and bin folders using a command-line shell for Linux:    $ export JAVA_HOME=/path/to/graalvm$ export PATH=/path/to/graalvm/bin:$PATH    and for macOS X:    $ export JAVA_HOME=/path/to/graalvm/Contents/Home$ export PATH=/path/to/graalvm/Contents/Home/bin:$PATH    Execute mvn package from SimpleLanguage folder to build the language.The command also builds a slnative executable in the simplelanguage/nativedirectory and sl-component.jar language component which later can be installedinto GraalVM using the GraalVMUpdater tool.Please verify if native-image plugin is available in your GraalVM distributionto avoid the build failure:    $ gu list$ gu install native-image    You can disable the SimpleLanguage native image build during the packaging phase by running:    $ export SL_BUILD_NATIVE=false$ mvn package    Run in the simplelanguage root folder:    $ ./sl ./language/tests/HelloWorld.sl  The SimpleLanguage demonstration language is licensed under the Universal Permissive License (UPL).IDE SetupThe Truffle Language Implementation framework provides language-agnostic infrastructure to realize standard IDE features by providing additional APIs. If you would like to experiment with your language and get the benefits of an IDE, consider the import of SimpleLanguage as an example.EclipseThe SimpleLanguage teaching project has been tested with Eclipse Neon.2 Release 4.6.2 and Eclipse Oxygen.3A. To import the project folder to the desirable Eclipse environment:  Open Eclipse with a new workspace;  Install m2e and m2e-apt plugins from the Eclipse marketplace (Help -&amp;gt; Eclipse Marketplace);  Finally, import SimpleLanguage project from File -&amp;gt; Import -&amp;gt; Maven -&amp;gt; Existing Maven Projects -&amp;gt; browse to the simplelanguage folder -&amp;gt; Finish.NetbeansNetBeans provides GUI support for debugging arbitrary languages. In order to upload SimpleLanguage to NetBeans interface, proceed to File -&amp;gt; Open Project -&amp;gt; select simplelanguage folder -&amp;gt; check “Open Required Projects” -&amp;gt; open Project.IntelliJ IDEASimpleLanguage project has been tested with IntelliJ IDEA 2018.3. Open IntelliJ IDEA and, from the main menu bar, select  File -&amp;gt; Open -&amp;gt; Navigate to and select the simplelanguage folder -&amp;gt; Press “OK”.  All dependencies will be included automatically.Run SimpleLanguageTo run a SimpleLanguage source file, execute$ ./sl language/tests/HelloWorld.slTo see assembly code for Truffle compiled functions, run$ ./sl -disassemble language/tests/SumPrint.slDump GraphsTo investigate performance issues, we recommend the Ideal Graph Visualizer (hereand after “IGV”) – an essential tool for any language implementer building ontop of GraalVM Enterprise Edition.It is available as a separate download on Oracle Technology Network and requires accepting the Oracle Technology Network Developer License.1.Unzip the downloaded package, enter the bin directory and start IGV:$ cd idealgraphvisualizer/bin$ idealgraphvisualizer2.Execute the following from simplelanguage root folder to dump graphs to IGV:$ ./sl -dump language/tests/SumPrint.slDebugTo start debugging the SimpleLanguage implementation with a Java debugger, pass the -debug option to the command-line launcher of your program:$ ./sl -debug language/tests/HelloWorld.slThen attach a Java remote debugger (like Eclipse) on port 8000.SimpleLanguage Component for GraalVMLanguages implemented with Truffle Language Implementation framework can be packaged as Components which later can be installed intoGraalVM using the GraalVM Updater.Running mvn package in the simplelanguage folder also builds asl-component.jar.This file is the SimpleLanguage component for GraalVM and can be installed byrunning:$ gu -L install /path/to/sl-component.jarSimpleLanguage Native ImageA language implemented with Truffle Language Implementation framework can be AOTcompiled using the GraalVM Native Image. Runningmvn package in the simplelanguage folder also builds a slnative executablein the native directory. This executable is the full SimpleLanguageimplementation as a single native application, and has no need for a GraalVM inorder to execute SimpleLanguage code. Besides this, a big advantage of using thenative image when compared to running on the GraalVM is the greatly fasterstartup time as shown bellow.$ time ./sl language/tests/HelloWorld.sl== running on org.graalvm.polyglot.Engine@2db0f6b2Hello World!real    0m0.405suser    0m0.660ssys     0m0.108s$ time ./native/slnativelanguage/tests/HelloWorld.sl== running on org.graalvm.polyglot.Engine@7fd046f06898Hello World!real    0m0.004suser    0m0.000ssys     0m0.000sThis snipped shows a timed execution of a “Hello World” program using the sllauncher script, which runs SimpleLanguage on GraalVM, and using the nativeimage. We can see that when running on GraalVM the execution takes 405ms. Sinceour SimpleLanguage program does just one print statement, we can conclude thatalmost all of this time is spent starting up GraalVM and initializing thelanguage itself. When using the native image we see that the execution takesonly 4ms, showing two orders of magnitude faster startup than running on theGraalVM.For more information on the native-image tool consider reading the referencemanual.Disable SimpleLanguage Native Image BuildBuilding the native image through maven is attached to the maven packagephase. Since the native image build can take a bit of time, we provide theoption to skip this build by setting the SL_BUILD_NATIVE environment variableto false like so:$ export SL_BUILD_NATIVE=false$ mvn package...[INFO]                                                                         [INFO] ------------------------------------------------------------------------[INFO] Building simplelanguage-graalvm-native[INFO] ------------------------------------------------------------------------[INFO][INFO] --- exec-maven-plugin:1.6.0:exec (make_native) @ simplelanguage-graalvm-native ---Skipping the native image build because SL_BUILD_NATIVE is set to false.[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------...Run SimpleLanguage with the Newest Compiler VersionIn the outstanding case that you need to execute SimpleLanguage with the newestversion of the GraalVM compiler, please follow these instructions:  Download the latest JVMCI JDK 8 and point JAVA_HOME at it:    $ export JAVA_HOME=/path/to/openjdk1.8.0_212-jvmci-19.2-b01    Clone the “Graal” repository from SimpleLanguage folder:    $ cd /path/to/simplelanguage$ git clone https://github.com/oracle/graal.git    Clone the mx repository:    $ git clone https://github.com/graalvm/mx.git    Add mx to your path:    $ export PATH=/path/to/mx:$PATH    Navigate to the compiler folder:    $ cd /path/to/graal/compiler    Build the GraalVM compiler:    $ mx build    Run SimpleLanguage using the mx command:    $ mx -v --jdk=jvmci vm -cp /path/to/simplelanguage/launcher/target/launcher-19.0.2-SNAPSHOT.jar:/path/to/simplelanguage/language/target/simplelanguage.jar com.oracle.truffle.sl.launcher.SLMain  /path/to/simplelanguage/language/tests/SlScript.sl  Run SimpleLanguage Using Command LineExecuting SimpleLanguage code is normally done with the sl script which setsup the necessary command line depending on whether JAVA_HOME points to theGraalVM or another JVM installation. The following subsections describe thecommand line for both cases.GraalVMAssuming JAVA_HOME points to the GraalVM installation and that the currentworking directory is the simplelanguage directory, to run SimpleLanguage oneshould execute the following command:$ JAVA_HOME/bin/java     -cp launcher/target/launcher-19.0.2-SNAPSHOT.jar     -Dtruffle.class.path.append=language/target/simplelanguage.jar     com.oracle.truffle.sl.launcher.SLMain language/tests/Add.slIn short, we place the launcher jar on the class path and execute its mainclass, but we inform GraalVM of the presence of SimpleLanguage by using the-Dtruffle.class.path.append option and providing it the path to the fatlanguage jar. Having the language on a separate class path ensures a strongseparation between the language implementation and its embedding context (inthis case, the launcher).Disable Class Path SeparationNOTE! This should only be used during development.If it is required to disable the class path separation and enable having thelanguage implementation on the application class path (for example, for testingthe internals of the language) you can add the -XX:-UseJVMCIClassLoaderoption. This disables the class path isolation, enabling the languageimplementation to be placed on the application class path. The command line canthen look like the following.$ JAVA_HOME/bin/java     -XX:-UseJVMCIClassLoader     -cp launcher/target/launcher-19.0.2-SNAPSHOT.jar:language/target/simplelanguage.jar     com.oracle.truffle.sl.launcher.SLMain language/tests/Add.slOther JVM ImplementationsUnlike GraalVM, which includes all the dependencies needed to run a languageimplemented with Truffle framework, other JVM implementations need additionaljars to be present on the class path. These are the Truffle API and GraalVM SDKjars available from Maven Central.Assuming JAVA_HOME points to a Stock JDK installation, that the currentworking directory is the simplelanguage directory and the Truffle API andGraalVM SDK jars are present in that directory, one can execute SimpleLanguagewith the following command:$ JAVA_HOME/bin/java     -cp graal-sdk-19.0.2.jar:truffle-api-19.0.2.jar:launcher/target/launcher-19.0.2-SNAPSHOT.jar:language/target/simplelanguage.jar     com.oracle.truffle.sl.launcher.SLMain language/tests/Add.sl",
                    "url": " /docs/graalvm-as-a-platform/implement-language/"
                  },
                  
                  "downloads":  {
                    "title": "",
                    "content": "&amp;lt;!DOCTYPE html&amp;gt;                Downloads                                                            social-network                    algorithm                                            blogger                    cloud-download                    computing                                      conversation                                      document                    github-sign                                                              home-icon-silhouette                          icon-github                    icon-twitter                    logo                          screwdriver-and-wrench-crossed                                speed-meter                                                        linux                    mac-os-logo                          icon-windows-logo                                          &amp;lt;/symbol&amp;gt;  &amp;lt;/defs&amp;gt;                                                          Home                              Docs                                      Downloads                                      Community                                                                                                                Star                            Try graalvm                                                                                        The standard GraalVM bundle can run Java and JavaScript either via            OpenJDK (Java 8u222) or OracleJDK (Jave SE 8u221), Node.js            (v10.15.2) and standalone. GraalVM 19.2.0 is available as Community Edition and Enterprise            Edition. The most notable changes in GraalVM can be found from            the release notes.                    GraalVM consists of core and optional components and is distributed as anarchive. Consult distributioncomponents list to understand what is included in the base GraalVMinstallation. The GraalVMUpdater tool provided by default can add support for optionalcomponents and install third party languages and tools.                       The Oracle Database Multilingual Engine with added JavaScript support via GraalVM is available here.                                                                                      Community Edition                                                GraalVM Community is available for free for evaluation, development and production use.                  It is built from the GraalVM sources available on                  GitHub. We provide pre-built binaries for Linux, macOS X, and Windows platforms on x86 64-bit systems.                  Windows support is experimental.                                            DOWNLOAD FROM GITHUB              License                              Open Source Licenses                Free for development and production use                            Benefits                              Open-source license                Free community support via public channels                Presence of all enterprise components                Bug fixes and enhancements                            Available for                              macOS                Linux                Windows                                                                        Enterprise Edition                               GraalVM Enterprise provides additional performance,                security, and scalability relevant for running applications in                production. It is free for evaluation uses and available for                download from the Oracle                Technology Network. We provide binaries for                Linux, macOS X, and Windows platforms on x86 64-bit systems.                Windows support is experimental.                                          Download from OTN              License                              Oracle Master License Agreement                Free for evaluation and non-production use                Contact us for commercial use and support options                            Benefits                              Faster performance and smaller footprint                Enhanced security features                Managed capabilities for native code                Premier 24x7x365 support via MOS                            Available for                              macOS                Linux                Windows                                                                                                                                                                                                                                                                                        GraalVM                          Getting Started              Reference Manual              GraalVM SDK Javadoc              Release Notes              Downloads                                            Community                          Team Blog              In the Press              Get Support              FAQ                                            Stay Tuned                          Events              GitHub              Twitter              Gitter                                            Useful Links                          Oracle Help Center              Oracle GraalVM              Oracle Labs              Support                                                                          Copyright © 2018, 2019, Oracle and/or its affiliates. All rights reserved.                                                                &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;",
                    "url": " /downloads/"
                  },
                  
                  "docs-reference-manual-tools":  {
                    "title": "Tools Reference",
                    "content": "GraalVM Debugging and Monitoring ToolsGraalVM provides a set of tools for developers, integrators, and ITadministrators to debug and monitor GraalVM and deployed applications.DebuggerGraalVM supports debugging of guest language applications and provides abuilt-in implementation ofthe Chrome DevTools Protocol.This allows you to attach compatible debuggers such asChrome Developer Toolsto GraalVM.To debug guest language applications, pass the --inspect option to thecommand-line launcher, as in the followingexample with a node.js hello world program:var http = require(&#39;http&#39;);var server = http.createServer(function (request, response) {  response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});  response.end(&quot;Hello World!n&quot;);});server.listen(8000);console.log(&quot;Server running at http://localhost:8000/&quot;);  Save this program as HelloWorld.js and then run:$ node --inspect --jvm HelloWorld.jsDebugger listening on port 9229.To start debugging, open the following URL in Chrome:    chrome-devtools://devtools/bundled/js_app.html?ws=127.0.1.1:9229/76fcb6dd-35267eb09c3Server running at http://localhost:8000/      Navigate to http://localhost:8000/ in your browser to launch the node application.        Open the chrome-devtools:... link in a separate Chrome browser tab.        Navigate to the HelloWorld.js file and submit a breakpoint at line 4.        Refresh the node.js app and you can see the breakpoint hit.  You can inspect the stack, variables, evaluate variables and selected expressionsin a tooltip, and so on. By hovering a mouse over the response variable, forinstance, you can inspect its properties as can be seen in the screenshot below:Consult theJavaScript Debugging Referencefor details on Chrome DevTools debugging features.This debugging process applies to all guest languages that GraalVM supports.Other languages such as R and Ruby can be debugged as easily as JavaScript,including stepping through language boundaries during guest languageinteroperability.Inspect OptionsNode LauncherThe node.js implementation that GraalVM provides accepts the same options asnode.js built on the V8 JavaScript engine, such as:--inspect[=[host:]&amp;lt;port number&amp;gt;]Enables the inspector agent and listens on port 9229 by default. To listen on adifferent port, specify the optional port number.--inspect-brk[=[host:]&amp;lt;port number&amp;gt;]Enables the inspector agent and suspends on the first line of the applicationcode. Listens on port 9229 by default, to listen on a different port, specifythe optional port number. This applies to the node launcher only.Other Language LaunchersOther guest language launchers such as js, python, Rscript, ruby, lli and polyglotaccept the --inspect[=[host:]&amp;lt;port number&amp;gt;] option, but suspend on the first line ofthe application code by default.--inspect.Suspend=(true|false)Disables the initial suspension if you specify --inspect.Suspend=false.Additional Common Inspect OptionsAll launchers accept also following additional options:--inspect.Path=&amp;lt;path&amp;gt;Allows to specify a fixed path that generates a predictable connection URL. Bydefault, the path is randomly generated.--inspect.SourcePath=&amp;lt;source path&amp;gt;This option specifies a list of directories or ZIP/JAR files representing the source path. When the inspected application contains relative references to source files, their content is loaded from locations resolved with respect to this source path. It is useful during LLVM debugging, for instance.The paths are delimited by : on UNIX systems and by ; on MS Windows.--inspect.Secure=(true|false)When true, use TLS/SSL to secure the debugging protocol. Besides changing the WS(web socket) protocol to WSS, the HTTP endpoint that serves metadata about the debuggeeis also changed to HTTPS. This is not compatible e.g. withchrome://inspect page, which is not able to provide the debuggeeinformation and launch the debugger then. Launch debugging via the printed WSS URL directly.Use the standard javax.net.ssl.* system options to provide information aboutkeystore with the TLS/SSL encryption keys, or following options:  --inspect.KeyStore keystore file path,  --inspect.KeyStoreType keystore file type (defaults to JKS),  --inspect.KeyStorePassword keystore password,  --inspect.KeyPassword password for recovering keys, if it’s different from the keystore password.--inspect.WaitAttached=(true|false)When true, no guest language source code is executed until the inspector clientis attached. Unlike --inspect.Suspend=true, the execution is resumed rightafter the client is attached. That assures that no execution is missed by theinspector client. It is false by default.Advanced Debug OptionsFollowing options are for language experts and language developers:--inspect.Initialization=(true|false)When true, inspect the language initialization phase. When initial suspension isactive, suspends at the beginning of language initialization and not necessarilyat the beginning of the application code. It’s false by default.--inspect.Internal=(true|false)When true, internal sources are inspected as well. Internal sources may providelanguage implementation details. It’s false by default.Programmatic Launch of Inspector BackendEmbedders can provide the appropriate inspector options to the Engine/Contextto launch the inspector backend. The following code snippet provides an example ofa possible launch:String port = &quot;4242&quot;;String path = &quot;session-identifier&quot;;String remoteConnect = &quot;true&quot;;Context context = Context.newBuilder(&quot;js&quot;)            .option(&quot;inspect&quot;, port)            .option(&quot;inspect.Path&quot;, path)            .option(&quot;inspect.Remote&quot;, remoteConnect)            .build();String hostAdress = &quot;localhost&quot;;String url = String.format(            &quot;chrome-devtools://devtools/bundled/js_app.html?ws=%s:%s/%s&quot;,            hostAdress, port, path);// Chrome Inspector client can be attached by opening the above url in ChromeProfilerGraalVM provides Profiling command line tools that let you optimize your codethrough analysis of CPU and memory usage.Most applications spend 80 percent of their runtime in 20 percent of the code.For this reason, to optimize the code, it is essential to know where theapplication spends its time. GraalVM provides simple command line tools forruntime and memory profiling to help you analyze and optimize your code.In this section, we use an example application to demonstrate the profilingcapabilities that GraalVM offers. This example application uses a basic primenumber calculator based on the ancient Sieve of Eratosthenesalgorithm.      Copy the following code into a new file named primes.js:     class AcceptFilter {     accept(n) {         return true     } } class DivisibleByFilter {     constructor(number, next) {         this.number = number;         this.next = next;     }     accept(n) {         var filter = this;         while (filter != null) {             if (n % filter.number === 0) {                 return false;             }             filter = filter.next;         }         return true;     } } class Primes {     constructor() {         this.number = 2;         this.filter = new AcceptFilter();     }     next() {         while (!this.filter.accept(this.number)) {             this.number++;         }         this.filter = new DivisibleByFilter(this.number, this.filter);         return this.number;     } } var primes = new Primes(); var primesArray = []; for (let i = 0; i &amp;lt; 5000; i++) {     primesArray.push(primes.next()); } console.log(`Computed ${primesArray.length} prime numbers. ` +             `The last 5 are ${primesArray.slice(-5)}.`);        Run js primes.js.    The example application should print output as follows:     $&amp;gt; js primes.js Computed 5000 prime numbers. The last 5 are 48563,48571,48589,48593,48611.    This code takes a moment to compute so let’s see where all the time is spent.        Run js primes.js --cpusampler to enable CPU sampling.    The CPU sampler tool should print output for the example application as follows:     $ ./js primes.js --cpusampler Computed 5000 prime numbers. The last 5 are 48563,48571,48589,48593,48611. --------------------------------------------------------------------------------------------------- Sampling Histogram. Recorded 1184 samples with period 1ms   Self Time: Time spent on the top of the stack.   Total Time: Time the location spent on the stack.   Opt %: Percent of time spent in compiled and therfore non-interpreted code. ---------------------------------------------------------------------------------------------------  Name        |      Total Time     |  Opt % ||       Self Time     |  Opt % | Location ---------------------------------------------------------------------------------------------------  next        |       1216ms  98.5% |  87.9% ||       1063ms  85.9% |  99.0% | primes.js~31-37:564-770  accept      |        159ms  11.2% |  22.7% ||        155ms  12.5% |  14.8% | primes.js~13-22:202-439  :program    |       1233ms 100.0% |   0.0% ||         18ms   1.5% |   0.0% | primes.js~1-47:0-1024  constructor |          1ms   0.1% |   0.0% ||          1ms   0.1% |   0.0% | primes.js~7-23:72-442 ---------------------------------------------------------------------------------------------------    The sampler prints an execution time histogram for each JavaScript function. By default, CPU sampling takes a sample every single millisecond. From the result we can see that roughly 96 percent of the time is spent in the DivisibleByFilter.accept function.     accept(n) {     var filter = this;     while (filter != null) {         if (n % filter.number === 0) {             return false;         }         filter = filter.next;     }     return true; }    Now find out more about this function by filtering the samples and include statements in the profile in addition to methods.        Run js primes.js --cpusampler --cpusampler.Mode=statements --cpusampler.FilterRootName=*acceptto collect statement samples for all functions that end with accept.     $ js primes.js --cpusampler --cpusampler.Mode=statements --cpusampler.FilterRootName=*accept Computed 5000 prime numbers. The last 5 are 48563,48571,48589,48593,48611. ---------------------------------------------------------------------------------------------------- Sampling Histogram. Recorded 1567 samples with period 1ms   Self Time: Time spent on the top of the stack.   Total Time: Time the location spent on the stack.   Opt %: Percent of time spent in compiled and therfore non-interpreted code. ----------------------------------------------------------------------------------------------------  Name         |      Total Time     |  Opt % ||       Self Time     |  Opt % | Location ----------------------------------------------------------------------------------------------------  accept~16-18 |        436ms  27.8% |  94.3% ||        435ms  27.8% |  94.5% | primes.js~16-18:275-348  accept~15    |        432ms  27.6% |  97.0% ||        432ms  27.6% |  97.0% | primes.js~15:245-258  accept~19    |        355ms  22.7% |  95.5% ||        355ms  22.7% |  95.5% | primes.js~19:362-381  accept~17    |          1ms   0.1% |   0.0% ||          1ms   0.1% |   0.0% | primes.js~17:322-334 ----------------------------------------------------------------------------------------------------    Roughly 30 percent of the time is spent in this if condition:     if (n % filter.number === 0) {     return false; }    The if condition contains an expensive modulo operation, which might explain the runtime of the statement.    Now use the CPU tracer tool to collect execution counts of each statement.        Run js primes.js --cputracer --cputracer.TraceStatements --cputracer.FilterRootName=*acceptto collect execution counts for all statements in methods ending with accept.     $ js primes.js --cputracer --cputracer.TraceStatements --cputracer.FilterRootName=*accept Computed 5000 prime numbers. The last 5 are 48563,48571,48589,48593,48611. ----------------------------------------------------------------------------------------- Tracing Histogram. Counted a total of 351278226 element executions.   Total Count: Number of times the element was executed and percentage of total executions.   Interpreted Count: Number of times the element was interpreted and percentage of total executions of this element.   Compiled Count: Number of times the compiled element was executed and percentage of total executions of this element. -----------------------------------------------------------------------------------------  Name     |          Total Count |    Interpreted Count |       Compiled Count | Location -----------------------------------------------------------------------------------------  accept   |     117058669  33.3% |         63575   0.1% |     116995094  99.9% | primes.js~15:245-258  accept   |     117053670  33.3% |         63422   0.1% |     116990248  99.9% | primes.js~16-18:275-348  accept   |     117005061  33.3% |         61718   0.1% |     116943343  99.9% | primes.js~19:362-381  accept   |         53608   0.0% |          1857   3.5% |         51751  96.5% | primes.js~14:215-227  accept   |         53608   0.0% |          1857   3.5% |         51751  96.5% | primes.js~13-22:191-419  accept   |         48609   0.0% |          1704   3.5% |         46905  96.5% | primes.js~17:322-334  accept   |          4999   0.0% |           153   3.1% |          4846  96.9% | primes.js~21:409-412  accept   |             1   0.0% |             1 100.0% |             0   0.0% | primes.js~2-4:25-61  accept   |             1   0.0% |             1 100.0% |             0   0.0% | primes.js~3:52-55 -----------------------------------------------------------------------------------------    Now the output shows execution counters for each statement, instead of timing information. Tracing histograms often provides insights into the behavior of the algorithm that needs optimization.    Lastly, use the memory tracer tool for capturing allocations, for which GraalVM currently provides experimental support. Node, --memtracer as an experimental tool must be preceded by the --experimental-options command line option.        Run js primes.js --experimental-options --memtracer to display source code locations andcounts of reported allocations.     $ js primes.js --experimental-options --memtracer Computed 5000 prime numbers. The last 5 are 48563,48571,48589,48593,48611. ------------------------------------------------------------  Location Histogram with Allocation Counts. Recorded a total of 5013 allocations.    Total Count: Number of allocations during the execution of this element.    Self Count: Number of allocations in this element alone (excluding sub calls). ------------------------------------------------------------  Name        |      Self Count |     Total Count |  Location ------------------------------------------------------------  next        |     5000  99.7% |     5000  99.7% | primes.js~31-37:537-737  :program    |       11   0.2% |     5013 100.0% | primes.js~1-46:0-966  Primes      |        1   0.0% |        1   0.0% | primes.js~25-38:454-739 ------------------------------------------------------------    This output shows the number of allocations which were recorded per function. For each prime number that was computed, the program allocates one object in next and one in constructor of DivisibleByFilter. Allocations are recorded independently of whether they could get eliminated by the compiler. The Graal compiler is particularly powerful in optimizing allocations and can push allocations into infrequent branches to increase execution performance. The GraalVM team plans to add information about memory optimizations to the memory tracer in the future.  Tool ReferenceUse the --help:tools option in all guest language launchers to displayreference information for the CPU sampler, the CPU tracer, and the memory tracer.The current set of available options is as follows:CPU Sampler Command Options  --cpusampler: enables the CPU sampler. Disabled by default.  --cpusampler.Delay=&amp;lt;Long&amp;gt;: delays the sampling for the given number of milliseconds (default: 0).  --cpusampler.FilterFile=&amp;lt;Expression&amp;gt;: applies a wildcard filter for sourcefile paths. For example, *program*.sl. The default is ∗.  --cpusampler.FilterLanguage=&amp;lt;String&amp;gt;: profiles languages only with thematching mime-type. For example, +. The default is no filter.  --cpusampler.FilterRootName=&amp;lt;Expression&amp;gt;: applies a wildcard filter forprogram roots. For example, Math.*. The default is ∗.  --cpusampler.GatherHitTimes: saves a timestamp for each taken sample. The default is false.  --cpusampler.Mode=&amp;lt;Mode&amp;gt;:  describes level of sampling detail. Please note that increased detail can lead to reduced accuracy.          exclude_inlined_roots samples roots excluding inlined functions (enabled by default);      rootssamples roots including inlined functions;      statements samples all statements.        --cpusampler.Output=&amp;lt;Output&amp;gt;: prints a ‘histogram’ or ‘calltree’ as output.The default is ‘histogram’.  --cpusampler.Period=&amp;lt;Long&amp;gt;: specifies the period, in milliseconds, tosample the stack.  --cpusampler.SampleInternal: captures internal elements. The default isfalse.  --cpusampler.StackLimit=&amp;lt;Integer&amp;gt;: specifies the maximum number of stackelements.  --cpusampler.SummariseThreads : prints sampling output as a summary of all ‘per thread’ profiles. The default is false.CPU Tracer Command Options  --cputracer: enables the CPU tracer. Disabled by default.  --cputracer.FilterFile=&amp;lt;Expression&amp;gt;: applies a wildcard filter for sourcefile paths. For example, *program*.sl. The default is ∗.  --cputracer.FilterLanguage=&amp;lt;String&amp;gt;: profiles languages only with thematching mime-type. For example, +. The default is no filter.  --cputracer.FilterRootName=&amp;lt;Expression&amp;gt;: applies a wildcard filter forprogram roots. For example, Math.*. The default is ∗.  --cputracer.Output=&amp;lt;Output&amp;gt; prints a histogram or json as output. The default is histogram.  --cputracer.TraceCalls: captures calls when tracing. The default is false.  --cputracer.TraceInternal: traces internal elements. The default is false.  --cputracer.TraceRoots=&amp;lt;Boolean&amp;gt;: captures roots when tracing.  The defaultis true.  --cputracer.TraceStatements: captures statements when tracing. The defaultis false.Memory Tracer Command OptionsWarning: The memory tracer tool is experimental. Experimental features might never be included in a production version, or might change significantly before being considered production-ready.Make sure to prepend --experimental-options flag to enable --memtracer.  --experimental-options --memtracer: enables the memory tracer. Disabled by default.  --memtracer.FilterFile=&amp;lt;Expression&amp;gt;: applies a wildcard filter for source file paths. For example, *program*.sl. The default is ∗.  --memtracer.FilterLanguage=&amp;lt;String&amp;gt;: profiles languages only with the matching mime-type. For example, +. The default is no filter.  --memtracer.FilterRootName=&amp;lt;Expression&amp;gt;: applies a wildcard filter for program roots. For example, Math.*. The default is ∗.  --memtracer.Output=&amp;lt;Format&amp;gt;: prints a ‘typehistogram’, ‘histogram’, or ‘calltree’ as output. The default is ‘histogram’.  --memtracer.StackLimit=&amp;lt;Integer&amp;gt;: sets the maximum number of maximum stack elements.  --memtracer.TraceCalls: captures calls when tracing. The default is false.  --memtracer.TraceInternal: captures internal elements. The default is false.  --memtracer.TraceRoots=&amp;lt;Boolean&amp;gt;: captures roots when tracing. The default is true.  --memtracer.TraceStatements: captures statements when tracing. The default is false.Ideal Graph VisualizerIdeal Graph Visualizer or IGV is a developer tool, currently maintained as part of the GraalVM compiler, recommended for performance issues investigation.The tool is essential for any language implementers building on top of GraalVM Enterprise Edition.It is available as a separate download on Oracle Technology Network and requires accepting the Oracle Technology Network Developer License.Ideal Graph Visualizer is developed to view and inspect interim graph representations from GraalVM and Truffle compilations.1.Unzip the downloaded package and enter bin directory:$ cd idealgraphvisualizer/bin2.Launch the tool:$ idealgraphvisualizer3.Save the following code snippet as  Test.rb:require &#39;json&#39;obj = {  time: Time.now,  msg: &#39;Hello World&#39;,  payload: (1..10).to_a}encoded = JSON.dump(obj)js_obj = Polyglot.eval(&#39;js&#39;, &#39;JSON.parse&#39;).call(encoded)puts js_obj[:time]puts js_obj[:msg]puts js_obj[:payload].join(&#39; &#39;)4.From another console window, make sure ruby component is installed in GraalVM,and connect Test.rb script to the running IGV:$ gu list$ ruby --jvm --vm.Dgraal.Dump=:1 --vm.Dgraal.PrintGraph=Network Test.rbThis causes GraalVM to dump compiler graphs in IGV format over the network to an IGV process listeningon 127.0.0.1:4445. Once the connection is made, you are able to see the graphs in the Outline window.Find e.g. java.lang.String.char(int) folder and open its After parsing graph by double-clicking.If the node has sourceNodePosition property, then the Processing Window will attempt to display its location and the entire stacktrace.Browsing GraphsOnce a specific graph is opened, you can search for nodes by name, ID, or by property=value data, and all matching results will be shown.Another cool feature of this tool is the ability to navigate to the original guest language source code!Select a node in graph and press ‘go to source’ button in the Stack View window.Graphs navigation is available also from the context menu, enabled by focusingand right-clicking a specific graph node. Extract nodes option will re-rendera graph and display just selected nodes and their neighbours.If the graph is larger than the screen, manipulate with the ‘satellite’ view buttonin the main toolbar to move the viewport rectangle.For user preference, the graph color scheme is adjustable by editingthe Coloring filter, enabled by default in the left sidebar.Viewing Source CodeSource code views can be opened in manual and assisted modes. Once you select a nodein the graph view, the Processing View will open. If IGV knows where the source codefor the current frame is, the green ‘go to source’ arrow is enabled. If IGV does notknow where the source is, the line is grayed out and a ‘looking glass’ button appears.Press it and select “Locate in Java project” to locate the correct project in the dialog.IGV hides projects which do not contain the required source file.The “Source Collections” serves to display the stand alone roots added by “Add root of sources” general action.If the source is located using the preferred method (i.e., from a Java project),its project can be later managed on the Project tab. That one is initially hidden,but you can display the list of opened projects using Window - Projects.Dumping GraphsThe IGV tool is developed to allow GraalVM language implementersto optimize their languages assembled with the Truffle framework. As a developmenttool it should not be installed to production environments.To dump the GraalVM compiler graphs from an embedded Java application to IGV,you need to add options to GraalVM based processes. Depending on the language/VMused, you may need to prefix the options by --vm. See the particularlanguage’s documentation for the details. The main option to add is-Dgraal.Dump=:1. This will dump graphs in an IGV readable format to the localfile system. To send the dumps directly to IGV over the network, add-Dgraal.PrintGraph=Network when starting a GraalVM instance. Optionally aport can be specified. Then dumps are sent to IGV from the running GraalVM onlocalhost. If IGV does not listen on localhost, options “Ideal Graph Settings|Accept Data from network” can be checked. If there is not an IGV instancelistening on 127.0.0.1 or it cannot be connected to, the dumps will beredirected to the local file system. The file system location is graal_dumps/under the current working directory of the process and can be changed with the-Dgraal.DumpPath option.In case an older GraalVM is used, you may need to explicitly request that dumpsinclude the nodeSourcePosition property. This is done by adding the-XX:+UnlockDiagnosticVMOptions -XX:+DebugNonSafepoints options.GraalVM VisualVMGraalVM comes with GraalVM VisualVM, an enhanced version of the popularVisualVM tool which includes special heap analysisfeatures for the supported guest languages. These languages and features arecurrently available:  Java: Heap Summary, Objects View, Threads View, OQL Console  JavaScript: Heap Summary, Objects View, Thread View  Python: Heap Summary, Objects View  Ruby: Heap Summary, Objects View, Threads View  R: Heap Summary, Objects ViewStarting GraalVM VisualVMTo start GraalVM VisualVM execute jvisualvm. Immediately after the startup,the tool shows all locally running Java processes in the Applications area,including the VisualVM process itself.Important: GraalVM Native Image does not implement JVMTI agent, hence triggering heap dump creation from Applications area is impossible. Apply -H:+AllowVMInspection flag with the native-image tool for Native Image processes. This way your application will handle signals and get a heap dump when it receives SIGUSR1 signal. Guest language REPL process must be started also with the --jvm flag to monitor it using GraalVM VisualVM. This functionality is available with GraalVM Enterprise Edition. It is not available in GraalVM open source version available on GitHub. See the Generating Native Heap Dumps page for details on creating heap dumps from a native image process.Getting Heap DumpTo get a heap dump of, for example, a Ruby application for later analysis,first start your application, and let it run for a few seconds to warm up. Thenright-click its process in GraalVM VisualVM and invoke the Heap Dump action. Anew heap viewer for the Ruby process opens.Analyzing ObjectsInitially the Summary view for the Java heap is displayed. To analyze the Rubyheap, click the leftmost (Summary) dropdown in the heap viewer toolbar, choosethe Ruby Heap scope and select the Objects view. Now the heap viewer displaysall Ruby heap objects, aggregated by their type.Expand the Proc node in the results view to see a list of objects of this type.Each object displays its logical value as provided by the underlyingimplementation. Expand the objects to access their variables and references,where available.Now enable the Preview, Variables and References details by clicking the buttonsin the toolbar and select the individual ProcType objects. Where available, thePreview view shows the corresponding source fragment, the Variables view showsvariables of the object and References view shows objects referring to theselected object.Last, use the Presets dropdown in the heap viewer toolbar to switch the viewfrom All Objects to Dominators or GC Roots. To display the heap dominators,retained sizes must be computed first, which can take a few minutes for theserver.rb example. Select the Objects aggregation in the toolbar to view theindividual dominators or GC roots.Analyzing ThreadsClick the leftmost dropdown in the heap viewer toolbar and select the Threadsview for the Ruby heap. The heap viewer now displays the Ruby thread stacktrace, including local objects. The stack trace can alternatively be displayedtextually by clicking the HTML toolbar button.Reading JFR SnapshotsVisualVM tool bundled with GraalVM 19.2.0 in both Community and Enterpriseeditions has the ability to read JFR snapshots – snapshots taken with JDKFlight Recorder (previously Java Flight Recorder). JFR is a tool for collectingdiagnostic and profiling data about a running Java application. It is integratedinto the Java Virtual Machine (JVM) and causes almost no performance overhead,so it can be used even in heavily loaded production environments.To install the JFR support, released as a plugin:  run &amp;lt;GRAALVM_HOME&amp;gt;/bin/jvisualvm to start VisualVM;  navigate to Tools &amp;gt; Plugins &amp;gt; Available Plugins to list all available plugins and install the VisualVM-JFR andVisualVM-JFR-Generic modules.The JFR snapshots can be opened using either the File &amp;gt; Load action or bydouble-clicking the JFR Snapshots node and adding the snapshot into the JFRrepository permanently. Please follow the documentation for your Java version tocreate JFR snapshots.The JFR viewer reads all JFR snapshots created from Java 7 and newer and presents the data in typicalVisualVM views familiar to the tool users.These views and functionality are currently available:  Overview tab displays the basic information about the recorded process likeits main class, arguments, JVM version and configuration, and system properties.This tab also provides access to the recorded thread dumps.  Monitor tab shows the process uptime and basic telemetry – CPU usage, Heapand Metaspace utilization, number of loaded classes and number of live &amp;amp; startedthreads.  Threads tab reconstructs the threads timeline based on all events recorded inthe snapshot as precisely as possible, based on the recording configuration.  Locks tab allows to analyze threads synchronization.  File IO tab presents information on read and write events to the filesystem.  Socket IO tab presents information on read and write events to the network.  Sampler tab shows per-thread CPU utilization and memory allocations, and aheap histogram. There is also an experimental feature “CPU sampler” building CPUsnapshot from the recorded events. It does not provide an exact performanceanalysis but still helps to understand what was going on in the recordedapplication and where the CPU bottleneck might be.  Browser tab provides a generic browser of all events recorded in the snapshot.  Environment tab gives an overview of the recording machine setup and conditionlike CPU model, memory size, operating system version, CPU utilization, memoryusage, etc..  Recording tab lists the recording settings and basic snapshot telemetry likenumber of events, total recording time, etc..Warning: The support of JDK Flight Recorder is experimental. Experimental features mightnever be included in a production version, or might change significantly beforebeing considered production-ready. Some advanced features likeanalyzing JVM internals, showing event stack traces or support for creating JFRsnapshots from live processes are not available in this preview version and willbe addressed incrementally in the following releases.",
                    "url": " /docs/reference-manual/tools/"
                  },
                  
                  "docs-reference-manual-languages-llvm":  {
                    "title": "Reference Manual for LLVM",
                    "content": "Running LLVM on GraalVMGraalVM provides an implementation of the lli tool to directly executeprograms from LLVM bitcode.In contrast to static compilation that is normally used for LLVM basedlanguages, LLI first interprets the bitcode and then dynamically compiles thehot parts of the program using the GraalVM compiler. This allows seamlessinteroperability with the dynamic languages supported by GraalVM.Run programs in LLVM bitcode format:lli [LLI Options] [GraalVM Options] [Polyglot Options] filename.bc [program args]Where filename.bc is a single program source file in LLVM bitcode format.Note: LLVM bitcode is platform dependent. The program must be compiled tobitcode for the appropriate platform.Compiling to LLVM BitcodeGraalVM can execute C/C++, Rust, and other languages that can be compiled toLLVM bitcode. As a first step, you have to compile the program to LLVM bitcodeusing an LLVM frontend such as clang. C/C++ code can be compiled to LLVMbitcode using clang with the -emit-llvm option.Here is some example C code named hello.c:#include &amp;lt;stdio.h&amp;gt;int main() {    printf(&quot;Hello from GraalVM!n&quot;);    return 0;}You can compile hello.c to an LLVM bitcode file named hello.bc as follows:$ clang -c -O1 -emit-llvm hello.cYou can then run hello.bc on GraalVM like this:$ lli hello.bcHello from GraalVM!External library dependenciesIf the bitcode file depends on external libraries, they can be loaded using the--lib argument.For example:#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;ncurses.h&amp;gt;int main() {    initscr();    printw(&quot;Hello, Curses!&quot;);    refresh();    sleep(1);    endwin();    return 0;}This can be run with:$ clang -c -O1 -emit-llvm hello-curses.c$ lli --lib /usr/lib/libncursesw.so hello-curses.bcFor Mac OS users, ncurses library path is /usr/lib/libncurses.dylib.Running C++For running C++ code, LLI requires the libc++ standard library from the LLVMproject. If you are using Ubuntu Linux, install the package libc++1.#include &amp;lt;iostream&amp;gt;int main() {    std::cout &amp;lt;&amp;lt; &quot;Hello, C++ World!&quot; &amp;lt;&amp;lt; std::endl;}Make sure you compile your C++ code with the correct standard library:$ clang++ -c -O1 -emit-llvm -stdlib=libc++ hello-c++.cpp$ lli hello-c++.bcHello, C++ World!Running RustLLI does not load the Rust standard libraries automatically.To install Rust, run the following in your terminal, then follow the onscreen instructions:curl https://sh.rustup.rs -sSf | shTo run Rust code,the required Rust libraries have to be specified manually.fn main() {    println!(&quot;Hello Rust!&quot;);}This can be run with:$ rustc --emit=llvm-bc hello-rust.rs$ lli --lib $(rustc --print sysroot)/lib/libstd-* hello-rust.bcHello Rust!LLVM ToolchainThe toolchain is a set of tools and APIs for compiling native programs, such asC and C++, to bitcode that can be executed with the GraalVM LLVM runtime. Tosimplify compiling C/C++ to LLVM bitcode, we provide launchers that invoke thecompiler with special flags to produce results that can be executed by theGraalVM LLVM runtime. Depending on the execution mode, the launchers location is$GRAALVM/jre/languages/llvm/{native|managed}/bin/* (in the native executionmode, the path is $GRAALVM/jre/languages/llvm/native/bin/*, in the managedmode – $GRAALVM/jre/languages/llvm/managed/bin/*). They are meant to bedrop-in replacements for the C/C++ compiler when compiling a native program. Thegoal is to produce a GraalVM LLVM runtime executable by simply pointing thebuild system to those launchers, for example via CC/CXX environmentvariables or by setting PATH.Warning: Toolchain support is experimental. Experimental features might never beincluded in a production version, or might change significantly before beingconsidered production-ready.The LLVM toolchain is pre-packaged as a component and can be installed with GraalVM Updater tool:gu install llvm-toolchainThe following example shows how the toolchain can be used to compile a make-based project.Let us assume that the CC variable is used in the Makefile to specify the Ccompiler that produces an executable named myprogram.We compile the project as follows:$ make CC=${GRAALVM}/jre/languages/llvm/native/bin/clang myprogramAfterwards, the resulting myprogram can be executed by the LLVM runtime:$ ${GRAALVM}/bin/lli myprogramUse Cases      Simplify the compilation to bitcode: GraalVM users who want to run native projects via the GraalVM LLVM runtime mustfirst compile these projects to LLVM bitcode. Although it is possible to do thiswith the standard LLVM tools (clang, llvm-link, etc.), there are severaladditional considerations, such as optimizations and manual linking. Thetoolchain aims to simplify this process, by providing an out-of-the-box drop-inreplacement for the compiler when building native projects targeting the GraalVMLLVM runtime.        Compile native extensions: GraalVM language implementers often use the GraalVM LLVM runtime to execute native extensions, and these extensions are commonly installed by a package manager. For example, packages in Python are usually added via pip install, which means that the Python implementation is required to be able to compile these native extensions on demand. The toolchain provides a Java API for languages to access the tools bundled with GraalVM.        Compile to bitcode at build time: GraalVM supported languages that integrate with the GraalVM LLVM runtime usually need to build bitcode libraries to integrate with the native pieces of theirimplementation. The toolchain can be used as a build-time dependency to achievethis in a standardized and compatible way.  File FormatTo be compatible with existing build systems, by default, the toolchain willproduce native executables with embedded bitcode (ELF files on Linux, Mach-Ofiles on macOS).Toolchain IdentifierThe GraalVM LLVM runtime can be ran in different configurations, which candiffer in how the bitcode is being compiled. Generally, toolchain users do notneed to be concerned, as the GraalVM LLVM runtime knows the mode it is runningand will always provide the right toolchain. However, if a languageimplementation wants to store the bitcode compilation for later use, it willneed to be able to identify the toolchain and its configurations used to compilethe bitcode. To do so, each toolchain has an identifier. Conventionally, theidentifier denotes the compilation output directory. The internal GraalVM LLVMruntime library layout follows the same approach.Java API Toolchain ServiceLanguage implementations can access the toolchain via the Toolchain service. The service provides two methods:  TruffleFile getToolPath(String tool) returns the path to the executable for agiven tool. Every implementation is free to choose its own set of supportedtools. The command line interface of the executable is specific to the tool. Ifa tool is not supported or not known, null is returned.  String getIdentifier() returns the identifier for the toolchain. It can beused to distinguish results produced by different toolchains. The identifier canbe used as a path suffix to place results in distinct locations, therefore itdoes not contain special characters like slashes or spaces.The Toolchain lives in the SULONG_API distribution. The LLVM runtime willalways provide a toolchain that matches its current mode. The service can belooked-up via the Env:LanguageInfo llvmInfo = env.getInternalLanguages().get(&quot;llvm&quot;);Toolchain toolchain = env.lookup(llvmInfo, Toolchain.class);TruffleFile toolPath = toolchain.getToolPath(&quot;CC&quot;);String toolchainId = toolchain.getIdentifier();InteroperabilityGraalVM supports several other programming languages, including JavaScript,Python, Ruby, and R. While LLI is designed to run LLVM bitcode, it also providesan API for programming language interoperability that lets you execute code fromany other language that GraalVM supports.Dynamic languages like JavaScript usually access object members by name. Sincenormally names are not preserved in LLVM bitcode, it must be compiled with debuginfo enabled.The following example demonstrates how you can use the API for interoperabilitywith other programming languages.Let us define a C struct for points and implement allocation functions:// cpart.c#include &amp;lt;polyglot.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;struct Point {    double x;    double y;};POLYGLOT_DECLARE_STRUCT(Point)void *allocNativePoint() {    struct Point *ret = malloc(sizeof(*ret));    return polyglot_from_Point(ret);}void *allocNativePointArray(int length) {    struct Point *ret = calloc(length, sizeof(*ret));    return polyglot_from_Point_array(ret, length);}void freeNativePoint(struct Point *p) {    free(p);}void printPoint(struct Point *p) {    printf(&quot;Point&amp;lt;%f,%f&amp;gt;n&quot;, p-&amp;gt;x, p-&amp;gt;y);}Make sure GRAALVM_HOME resolves to the GraalVM installation directory, then compile the cpart.c file with:$ clang -g -O1 -c -emit-llvm -I$GRAALVM_HOME/jre/languages/llvm/include cpart.cYou can access your C/C++ code from other languages like JavaScript:// jspart.js// Load and parse the LLVM bitcode into GraalVMvar cpart = Polyglot.evalFile(&quot;llvm&quot; ,&quot;cpart.bc&quot;);// Allocate a light-weight C structvar point = cpart.allocNativePoint();// Access it as if it were a JS objectpoint.x = 5;point.y = 7;// Pass it back to a native functioncpart.printPoint(point);// We can also allocate an array of structsvar pointArray = cpart.allocNativePointArray(15);// We can access this array like it was a JS arrayfor (var i = 0; i &amp;lt; pointArray.length; i++) {    var p = pointArray[i];    p.x = i;    p.y = 2*i;}cpart.printPoint(pointArray[3]);// We can also pass a JS object to a native functioncpart.printPoint({x: 17, y: 42});// Don&#39;t forget to free the unmanaged data objectscpart.freeNativePoint(point);cpart.freeNativePoint(pointArray);Run this JavaScript file with:$ js --polyglot jspart.jsPoint&amp;lt;5.000000,7.000000&amp;gt;Point&amp;lt;3.000000,6.000000&amp;gt;Point&amp;lt;17.000000,42.000000&amp;gt;Polyglot C APIThere are also lower level API functions for directly accessing polyglot valuesfrom C. See the Polyglot Referenceand the documentation comments in polyglot.h for more details.For example, this program allocates and accesses a Java array from C:#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;polyglot.h&amp;gt;int main() {    void *arrayType = polyglot_java_type(&quot;int[]&quot;);    void *array = polyglot_new_instance(arrayType, 4);    polyglot_set_array_element(array, 2, 24);    int element = polyglot_as_i32(polyglot_get_array_element(array, 2));    printf(&quot;%dn&quot;, element);    return element;}Compile it to LLVM bitcode:$ clang -g -O1 -c -emit-llvm -I$GRAALVM_HOME/jre/languages/llvm/include polyglot.cAnd run it, using the --jvm argument to run GraalVM in the JVM mode, since we areusing a Java type:$ lli --jvm polyglot.bc24Embedding in JavaGraalVM can also be used to embed LLVM bitcode in Java host programs.For example, let us write a Java class Polyglot.java that embeds GraalVM torun the previous example:import java.io.*;import org.graalvm.polyglot.*;class Polyglot {    public static void main(String[] args) throws IOException {        Context polyglot = Context.newBuilder().                       allowAllAccess(true).build();        File file = new File(&quot;polyglot.bc&quot;);        Source source = Source.newBuilder(&quot;llvm&quot;, file).build();        Value cpart = polyglot.eval(source);        cpart.execute();    }}Compiling and running it:$ javac Polyglot.java$ java Polyglot24See the Embedding documentationfor more information.Source-Level DebuggingYou can use GraalVM’s Debugger to debug the programyou compiled to LLVM bitcode.To use this feature, please make sure to compile your program with debug information by specifying the -gargument when compiling with clang.This gives you the ability to step through the program’s source code and set breakpoints in it.To also be able to inspect the local and global variables of your program you may pass--llvm.enableLVI=true as argument to lli.This option is not enabled per default as it can significantly decrease your program’s run-time performance.LLVM CompatibilityGraalVM works with LLVM bitcode versions 3.8 to 7.0.Optimization FlagsIn contrast to the static compilation model of LLVM languages, in GraalVM themachine code is not directly produced from the LLVM bitcode, but there is anadditional dynamic compilation step by the GraalVM compiler.In this scenario, first the LLVM frontend (e.g. clang) does optimizations onthe bitcode level, and then the GraalVM compiler does its own optimizations on top of thatduring dynamic compilation. Some optimizations are better when doneahead-of-time on the bitcode, while other optimizations are better left for thedynamic compilation of the GraalVM compiler, when profiling information is available.In principle, all optimization levels should work, but for best results wesuggest compiling the bitcode with optimization level -O1.Cross-language interoperability will only work when the bitcode is compiledwith debug information enabled (-g), and the -mem2reg optimization isperformed on the bitcode (compiled with at least -O1, or explicitly using theopt tool).LLI Command Options-L &amp;lt;path&amp;gt;/--llvm.libraryPath=&amp;lt;path&amp;gt;: a list of paths where GraalVM willsearch for library dependencies. Paths are delimited by :.--lib &amp;lt;libs&amp;gt;/--llvm.libraries=&amp;lt;libs&amp;gt;: a list of libraries to load. The listcan contain precompiled native libraries (*.so/*.dylib) and bitcodelibraries (*.bc). Files with a relative path are looked up relative tollvm.libraryPath. Entries are delimited by :.--llvm.enableLVI=&amp;lt;true/false&amp;gt;: enable source-level symbol inspection in thedebugger. This defaults to false as it can decrease run-time performance.--llvm.managed enable a managed execution mode for LLVM IR code, which means memory allocations from LLVM bitcode are done on the managed heap. This article explains the managed execution in every detail.--version prints the version and exit.--version:graalvm prints GraalVM version information and exit.Expert and Diagnostic OptionsUse --help and --help:&amp;lt;topic&amp;gt; to get a full list of options.Limitations and Differences to Native ExecutionLLVM code interpreted or compiled with the default configuration of GraalVMCommunity or Enterprise editions will not have the same characteristics as thesame code interpreted or compiled in a managed environment, enabledwith the --llvm.managed option on top of GraalVM Enterprise. Thebehavior of the lli interpreter tool used to directly execute programsin LLVM bitcode format differs between native and managed modes. Thedifference lies in safety guarantees and cross-language interoperability.In the default configuration, cross-language interoperability requires bitcodeto be compiled with the debug information enabled (-g), and the -mem2regoptimization is performed on the bitcode (compiled with at least -O1, orexplicitly using the opt tool). These requirements can be overcome in amanaged environment of GraalVM EE that allows native code to participate in thepolyglot programs, passing and receiving the data from any other supportedlanguage. In terms of security, the execution of native code in a managedenvironment passes with additional safety features: catching illegal pointeraccesses, accessing arrays outside of the bounds, etc..There are certain limitations and differences to the native execution depending on the GraalVM edition.Consider them respectively.Limitations and Differences to Native Execution on Top of GraalVM CEThe LLVM interpreter in GraalVM Community Edition environment allows executing LLVM bitcode within amultilingual context. Even though it aspires to be a generic LLVM runtime, thereare certain fundamental and/or implementational limitations that users need tobe aware of.The following restrictions and differences to native execution (i.e., bitcode compiled down to native code) exist when LLVM bitcode is executed with the LLVM interpreter on top of GraalVM CE:  The GraalVM LLVM interpreter assumes that bitcode was generated to target the x86_64 architecture.  Bitcode should be the result of compiling C/C++ code using clang version 7, other compilers/languages, e.g., Rust, might have specific requirements that are not supported.  Unsupported functionality – it is not possible to call any of the following functions:          clone()      fork()      vfork()      setjmp(), sigsetjmp(), longjmp(), siglongjmp()      Functions of the exec() function family      Pthread functions      Code running in the LLVM interpreter needs to be aware that a JVM is running in the same process, so many syscalls such as fork, brk, sbrk, futex, mmap, rt_sigaction, rt_sigprocmask, etc. might not work as expected or cause the JVM to crash.      Calling unsupported syscalls or unsupported functionality (listed above) via native code libraries can cause unexpected side effects and crashes.        Thread local variables          Thread local variables from bitcode are not compatible with thread local variables from native code.        Cannot rely on memory layout          Pointers to thread local variables are not stored in specific locations, e.g., the FS segment.      The order of globals in memory might be different, consequently no assumptions about their relative locations can be made.      Stack frames cannot be inspected or modified using pointer arithmetic (overwrite return address, etc.).      Walking the stack is only possible using the Truffle APIs.      There is a strict separation between code and data, so that reads, writes and pointer arithmetic on function pointers or pointers to code will lead to undefined behavior.        Signal handlers          Installing signal handlers is not supported.        The stack          The default stack size is not set by the operating system but by the option --llvm.stackSize.        Dynamic linking          Interacting with the LLVM bitcode dynamic linker is not supported, e.g., dlsym/dlopen can only be used for native libraries.      The dynamic linking order is undefined if native libraries and LLVM bitcode libraries are mixed.      Native libraries cannot import symbols from bitcode libraries.        x86_64 inline assembly is not supported.  Undefined behavior according to C spec          While most C compilers map undefined behavior to CPU semantics, the GraalVM LLVM interpreter might map some of this undefined behavior to Java or other semantics. Examples include: signed integer overflow (mapped to the Java semantics of an arithmetic overflow), integer division by zero (will throw an ArithmeticException), oversized shift amounts (mapped to the Java behavior).        Floating point arithmetics          Some floating point operations and math functions will use more precise operations and cast the result to a lower precision (instead of performing the operation at a lower precision).      Only the rounding mode FE_TONEAREST is supported.      Floating point exceptions are not supported.        NFI limitations (calling real native functions)          Structs, complex numbers, or fp80 values are not supported as by-value arguments or by-value return values.      The same limitation applies to calls back from native code into interpreted LLVM bitcode.        Limitations of polyglot interoperability (working with values from other GraalVM languages)          Foreign objects cannot be stored in native memory locations. Native memory locations include:                  globals (except the specific case of a global holding exactly one pointer value);          malloc’ed memory (including c++ new, etc.);          stack (e.g. escaping automatic variables).                      LLVM instruction set support (based on LLVM 7.0.1)          A set of rarely-used bitcode instructions are not available (va_arg, catchpad, cleanuppad, catchswitch, catchret, cleanupret, fneg, callbr).      The instructions with limited support:                  atomicrmw (only supports sub, add, and, nand, or, xor, xchg);          extract value and insert value (only supports a single indexing operand);          cast (missing support for certain rarely-used kinds);          atomic ordering and address space attributes of load and store instructions are ignored.                    Values – assembly constants are not supported (module-level assembly and any assembly strings).      Types:                  There is no support for 128-bit floating point types (fp128 and ppc_fp128), x86_mmx, half-precision floats (fp16) and any vectors of unsupported primitive types.          The support for fp80 is limited (not all intrinsics are supported for fp80, some intrinsics or instructions might silently fall back to fp64).                      A number of rarely-used or experimental intrinsics based on LLVM 7.0.1 are not supported because of implementational limitations or because they are out of scope:          experimental intrinsics: llvm.experimental.*, llvm.launder.invariant.group, llvm.strip.invariant.group;      trampoline intrinsics: llvm.init.trampoline, llvm.adjust.trampoline;      general intrinsics: llvm.var.annotation, llvm.ptr.annotation, llvm.annotation, llvm.codeview.annotation, llvm.trap, llvm.debugtrap, llvm.stackprotector, llvm.stackguard, llvm.ssa_copy, llvm.type.test, llvm.type.checked.load, llvm.load.relative, llvm.sideeffect;      specialised arithmetic intrinsics: llvm.canonicalize, llvm.fmuladd;      standard c library intrinsics: llvm.fma, llvm.trunc, llvm.nearbyint, llvm.round;      code generator intrinsics: llvm.returnaddress, llvm.addressofreturnaddress, llvm.frameaddress, llvm.localescape, llvm.localrecover, llvm.read_register, llvm.write_register, llvm.stacksave, llvm.stackrestore, llvm.get.dynamic.area.offset, llvm.prefetch, llvm.pcmarker, llvm.readcyclecounter, llvm.clear_cache, llvm.instrprof*, llvm.thread.pointer;      exact gc intrinsics: llvm.gcroot, llvm.gcread, llvm.gcwrite;      element wise atomic memory intrinsics: llvm.*.element.unordered.atomic;      masked vector intrinsics: llvm.masked.*;      bit manipulation intrinsics: llvm.bitreverse, llvm.fshl, llvm.fshr.      Limitations and Differences to Managed Execution on Top of GraalVM EEA managed execution for LLVM intermediate representation code is GraalVMEnterprise Edition feature  and can be enabled with --llvm.managed commandline option. In the managed mode, GraalVM LLVM prevents access to unmanagedmemory and uncontrolled calls to native code and operating system functionality.The allocations are performed in the managed Java heap, and accesses to thesurrounding system are routed through proper Truffle API and Java API calls.All the restrictions from the default native LLVM execution on GraalVM apply to the managed execution, but with the following differences/changes:  Platform independent          Bitcode must be compiled for the a generic linux_x86_64 target, using the provided musl libc library, on all platforms, regardless of the actual underlying operating system.        C++          C++ is currently not supported in a managed mode.        Native memory and code          Calls to native functions are not possible, thus only the functionality provided in the supplied musl libc and by the GraalVM LLVM interface is available.      Loading native libraries is not possible.      Native memory access is not possible.        System calls          System calls with only limited support are read, readv, write, writev, open, close, dup, dup2, lseek, stat, fstat, lstat, chmod, fchmod, ioctl, fcntl, unlink, rmdir, utimensat, uname, set_tid_address, gettid, getppid, getpid, getcwd, exit, exit_group, clock_gettime, arch_prctl.      The functionality is limited to common terminal IO, process control and file system operations.      Some syscalls are implemented as a noop and/or return errors warning that they are not available, e.g. chown, lchown, fchown, brk, rt_sigaction, sigprocmask, futex.        Musl libc          The musl libc library behaves differently than the more common glibc in some cases.        The stack          Accessing the stack pointer directly is not possible.      The stack is not contiguous, and accessing memory that is out of the bounds of a stack allocation (e.g., accessing neighboring stack value using pointer arithmetics) is not possible.        Pointers into the managed heap          Reading parts of a managed pointer is not possible.      Overwriting parts of a managed pointer (e.g., using bits for pointer tagging) and subsequently dereferencing the destroyed managed pointer is not possible.      Undefined behavior in C pointer arithmetics applies.      Complex pointer arithmetics (e.g., multiplying pointers) can convert a managed pointer to an i64 value – the i64 value can be used in pointer comparisons but cannot be dereferenced.        Floating point arithmetics          80-bit floating points only use 64-bit floating point precision.        Dynamic linking          The interaction with the LLVM bitcode dynamic linker is not supported, e.g., dlsym/dlopen cannot be used. This does not allow to load native code.      ",
                    "url": " /docs/reference-manual/languages/llvm/"
                  },
                  
                  "docs-reference-manual-languages-r":  {
                    "title": "Reference Manual for R",
                    "content": "GraalVM implementation of R, also known as FastR, is compatible with GNU R,can run R code at unparalleled performance,integrates with the GraalVMecosystem and provides additional R level features.Warning: The support for R is experimental.Experimental features might never be included in a production version, or mightchange significantly before being considered production-ready.Installing RThe R language can be installed to a GraalVM build with the gu command.See graalvm/bin/gu --help for more information.RequirementsGraalVM R engine requires the OpenMP runtime library be installed on the target system.Moreover, to install R packages that contain C/C++ or Fortran code, compilersfor those languages must be present on the target system. Note that all theserequirements can be satisfied by, e.g., installing the GNU Compiler Collection (GCC).The installation of R packages uses the configuration from jre/languages/R/etc/Makeconf.This includes, for example, the configuration of C compiler options.If you intend to install R packages, it is recommended to update this configurationto match your target system by running the jre/languages/R/bin/configure_fastr script.Experienced users can also edit the Makeconf file manually.Search Paths for PackagesThe default R library location is within the GraalVM installation directory.In order to allow installation of additional packages for users thatdo not have write access to the GraalVM installation directory,edit the R_LIBS_USER variable in the jre/languages/R/etc/Renviron file.Alternatively, the configuration script jre/languages/R/bin/configure_fastrautomatically creates a local R library directory in the current user’s home and changesthe R_LIBS_USER variable to point to that directory.Running R CodeRun R code with the R and Rscript commands:$ R [polyglot options] [R options] [filename]$ Rscript [polyglot options] [R options] [filename]GraalVM R engine uses the same polyglot options as other GraalVM languages and the same R options as GNU R, e.g., bin/R --vanilla.Use --help to print the list of supported options. The most important options include:  --jvm to enable Java interoperability  --polyglot to enable interoperability with other GraalVM languages  --vm.Djava.net.useSystemProxies=true to pass any options to the JVM, this will be translated to -Djava.net.useSystemProxies=true.Note: unlike other GraalVM languages, R does not yet ship with aNative Image of its runtime.Therefore the --native option, which is the default, will still start Rscript on top of JVM,but for the sake of future compatibility the Java interoperability will not be available in such case.Users can optionally build the native image using:jre/languages/R/bin/install_r_native_imageGraalVM R Engine CompatibilityGraalVM implementation of R, known as FastR, is based on GNU R and reusesthe base packages. It is currently based on R 3.5.1, and moves to new majorversions of R as they become available and stable. The FastRproject, maintains an extensive set of unittests for all aspects of the R language and the builtin functionality, and thesetests are available as part of the R source code. GraalVM R engine aims to befully compatible with GNU R, including its native interface as used by Rpackages. It can install and run unmodified complex R packages like ggplot2,Shiny, or Rcpp. As some packages rely on unspecified behavior orimplementation details of GNU R, support for packages is work in progress, andsome packages might not install successfully or work as expected.Packages can be installed using the install.packages function or the R CMD INSTALL shell command.By default, R uses fixed snapshot of the CRAN repository1.This behavior can be overridden by explicitly setting the repos argument of the install.packages function.This functionality does not interfere with the checkpoint package. If you are behind a proxy server, makesure to configure the proxy either with environment variables or using the JVM options,e.g., --vm.Djava.net.useSystemProxies=true.Versions of some packages specifically patched for GraalVM implementation of R can be installed using the install.fastr.packagesfunction that downloads them from the GitHub repository.Currently, those are rJava and data.table.Known limitations of GraalVM implementation of R compared to GNU R:  Only small parts of the low-level graphics package are functional. However, the grid package is supported and R can install and run packages based on it like ggplot2.   Support for the graphics package in R is planned for future releases.  Encoding of character vectors. Related builtins (e.g., Encoding) are available,   but do not execute any useful code. Character vectors are represented as Java Strings and therefore encoded in UTF-16 format. GraalVM implementation of R will add support for encoding in future releases.  Some parts of the native API (e.g., DATAPTR) expose implementation details that are hard to emulate for alternative implementations of R. These are implemented as needed while testing the GraalVM implementation of R with various CRAN packages.You can use the compatibility checker to find whether the CRAN packages you are interested in are tested on GraalVM and whether the tests pass successfully.High PerformanceGraalVM runtime optimizes R code that runs for extended periods of time.The speculative optimizations based on the runtime behavior of the R code and dynamic compilation employed by GraalVM runtime are capable of removing most of the abstraction penalty incurred by the dynamism and complexity of the R language.Let us look at an algorithm in R code. The following example calculates themutual information of a large matrix:x &amp;lt;- matrix(runif(1000000), 1000, 1000)mutual_R &amp;lt;- function(joint_dist) { joint_dist &amp;lt;- joint_dist/sum(joint_dist) mutual_information &amp;lt;- 0 num_rows &amp;lt;- nrow(joint_dist) num_cols &amp;lt;- ncol(joint_dist) colsums &amp;lt;- colSums(joint_dist) rowsums &amp;lt;- rowSums(joint_dist) for(i in seq_along(1:num_rows)){  for(j in seq_along(1:num_cols)){   temp &amp;lt;- log((joint_dist[i,j]/(colsums[j]*rowsums[i])))   if(!is.finite(temp)){    temp = 0   }   mutual_information &amp;lt;-    mutual_information + joint_dist[i,j] * temp  } } mutual_information}system.time(mutual_R(x))#   user  system elapsed#  1.321   0.010   1.279Algorithms such as this one usually require C/C++ code to run efficiently:2if (!require(&#39;RcppArmadillo&#39;)) {    install.packages(&#39;RcppArmadillo&#39;)    library(RcppArmadillo)}library(Rcpp)sourceCpp(&quot;r_mutual.cpp&quot;)x &amp;lt;- matrix(runif(1000000), 1000, 1000)system.time(mutual_cpp(x))#   user  system elapsed#  0.037   0.003   0.040(Uses r_mutual.cpp.)However, after a few iterations, GraalVM runs the R code efficiently enough tomake the performance advantage of C/C++ negligible:system.time(mutual_R(x))#   user  system elapsed#  0.063   0.001   0.077GraalVM implementation of R is primarily aimed at long-running applications. Therefore, the peak performance is usually only achieved after a warmup period. While startup time is currently slower than GNUR’s, due to the overhead from Java class loading and compilation, future releases will contain a native image of R with improved startup.GraalVM IntegrationThe R language integration with the GraalVM ecosystem includes:  seamless interop with other GraalVM languages and with Java  debugging with Chrome DevTools  CPU and memory profiling  VisualVM integrationTo start debugging the code start the R script with --inspect option$ Rscript --inspect myScript.RNote that GNU R compatible debugging using, for example, debug(myFunction) is also supported.InteroperabilityGraalVM supports several other programming languages, including JavaScript, Ruby, Python, and LLVM.GraalVM implementation of R also provides an API for programming language interoperability that lets you execute code from any other language that GraalVM supports. Note that you must start the R script with --polyglot to have access to other GraalVM languages.GraalVM execution of R provides the following interoperability primitives:  eval.polyglot(&#39;languageId&#39;, &#39;code&#39;) evaluates code in some other language, the languageId can be, e.g., js.  eval.polyglot(path = &#39;/path/to/file.extension&#39;) evaluates code loaded from a file. The language is recognized from the extension.  export(&#39;polyglot-value-name&#39;, rObject) exports an R object so that it can be imported by other languages.  import(&#39;exported-polyglot-value-name&#39;) imports a polyglot value exported by some other language.Please use the ?functionName syntax to learn more. The following example demonstrates the interoperability features:# get an array from Rubyx &amp;lt;- eval.polyglot(&#39;ruby&#39;, &#39;[1,2,3]&#39;)print(x[[1]])# [1] 1# get a JavaScript objectx &amp;lt;- eval.polyglot(path=&#39;r_example.js&#39;)print(x$a)# [1] &quot;value&quot;# use R vector in JavaScriptexport(&#39;robj&#39;, c(1,2,3))eval.polyglot(&#39;js&#39;, paste0(    &#39;rvalue = Polyglot.import(&quot;robj&quot;); &#39;,    &#39;console.log(&quot;JavaScript: &quot; + rvalue.length);&#39;))# JavaScript: 3# NULL -- the return value of eval.polyglot(Uses r_example.js.)R vectors are presented as arrays to other languages. This includes single element vectors, e.g. 42L or NA.However, single element vectors that do not contain NA can be typically used in places where the otherlanguages expect a scalar value. Array subscript or similar operation can be used in other languages to accessindividual elements of an R vector. If the element of the vector is not NA, the actual valueis returned as a scalar value. If the element is NA, then a special object that looks like nullis returned. The following Ruby code demonstrates this.vec = Polyglot.eval(&quot;R&quot;, &quot;c(NA, 42)&quot;)p vec[0].nil?# truep vec[1]# 42vec = Polyglot.eval(&quot;R&quot;, &quot;42&quot;)p vec.to_s# &quot;[42]&quot;p vec[0]# 42The foreign objects passed to R are implicitly treated as specific R types.The following table gives some examples.            Example of foreign object (Java)      Viewed ‘as if’ on the R side                  int[] {1,2,3}      c(1L,2L,3L)              int[][] { {1, 2, 3}, {1, 2, 3} }      matrix(c(1:3,1:3),nrow=3)              int[][] { {1, 2, 3}, {1, 3} }      not supported: raises error              Object[] {1, ‘a’, ‘1’}      list(1L, ‘a’, ‘1’)              42      42L      In the following code example, we can simply just pass the Ruby array to the R built-in function sum,which will work with the Ruby array as if it was integer vector.sum(eval.polyglot(&#39;ruby&#39;, &#39;[1,2,3]&#39;))Foreign objects can be also explicitly wrapped into adapters that make them look like the desired R type.In such a case, no data copying occurs if possible. The code snippet below shows the most common use cases.# gives list instead of an integer vectoras.list(eval.polyglot(&#39;ruby&#39;, &#39;[1,2,3]&#39;))# assume the following Java code:# public class ClassWithArrays {#   public boolean[] b = {true, false, true};#   public int[] i = {1, 2, 3};# }x &amp;lt;- new(&#39;ClassWithArrays&#39;); # see Java interop belowas.list(x)# gives: list(c(T,F,T), c(1L,2L,3L))For more details, please refer tothe executable specificationof the implicit and explicit foreign objects conversions.Note that R contexts started from other languages or Java (as opposed to via the bin/R script) will default to non-interactive mode, similar to bin/Rscript.This has implications on console output (results are not echoed) and graphics (output defaults to a file instead of a window), and some packages may behave differently in non-interactive mode.See the Polyglot Reference and theEmbedding documentationfor more information about interoperability with other programming languages.Interoperability with JavaGraalVM R engine provides built-in interoperability with Java. Java class objects can be obtained via java.type(...).The standard new function interprets string arguments as a Java class if such class exists. new also accepts Java types returned from java.type.Fields and methods of Java objects can be accessed using the $ operator.Additionally, you can use awt(...) to open an R drawing devicedirectly on a Java Graphics surface, for more details see Java Based Graphics.The following example creates a new Java BufferedImage object, plots random data to it using R’s grid package,and shows the image in a window using Java’s AWT framework. Note that you must start the R script with --jvm to have access to Java interoperability.library(grid)openJavaWindow &amp;lt;- function () {   # create image and register graphics   imageClass &amp;lt;- java.type(&#39;java.awt.image.BufferedImage&#39;)   image &amp;lt;- new(imageClass, 450, 450, imageClass$TYPE_INT_RGB);   graphics &amp;lt;- image$getGraphics()   graphics$setBackground(java.type(&#39;java.awt.Color&#39;)$white);   grDevices:::awt(image$getWidth(), image$getHeight(), graphics)   # draw image   grid.newpage()   pushViewport(plotViewport(margins = c(5.1, 4.1, 4.1, 2.1)))   grid.xaxis(); grid.yaxis()   grid.points(x = runif(10, 0, 1), y = runif(10, 0, 1),        size = unit(0.01, &quot;npc&quot;))   # open frame with image   imageIcon &amp;lt;- new(&quot;javax.swing.ImageIcon&quot;, image)   label &amp;lt;- new(&quot;javax.swing.JLabel&quot;, imageIcon)   panel &amp;lt;- new(&quot;javax.swing.JPanel&quot;)   panel$add(label)   frame &amp;lt;- new(&quot;javax.swing.JFrame&quot;)   frame$setMinimumSize(new(&quot;java.awt.Dimension&quot;,                image$getWidth(), image$getHeight()))   frame$add(panel)   frame$setVisible(T)   while (frame$isVisible()) Sys.sleep(1)}openJavaWindow()For more information on FastR interoperability with Java and other languages implemented with Truffle framework,refer to the Interoperability tutorial.GraalVM implementation of R provides its own rJava compatible replacement package available at GitHub,which can be installed using:$ R -e &quot;install.fastr.packages(&#39;rJava&#39;)&quot;GraalVM R Engine Additional FeaturesJava Based GraphicsThe GraalVM implementation of R includes its own Java based implementation of the grid package and the following graphics devices: png, jpeg, bmp, svg and awt (X11 is aliased to awt). The graphics package and most of its functions are not supported at the moment.The awt device is based on the Java Graphics2D object and users can pass it their own Graphics2D object instance when opening the device using the awt function, as shown in the Java interop example.When the Graphics2D object is not provided to awt, it opens a new window similarly to X11.The svg device in GraalVM implementation of R generates more lightweight SVG code than the svg implementation in GNU R.Moreover, functions tailored to manipulate the SVG device are provided: svg.off and svg.string.The SVG device is demonstrated in the following code sample. Please use the ?functionName syntax to learn more.library(lattice)svg()mtcars$cars &amp;lt;- rownames(mtcars)print(barchart(cars~mpg, data=mtcars))svgCode &amp;lt;- svg.off()cat(svgCode)In-Process Parallel ExecutionGraalVM R engine adds a new cluster type SHARED for the parallel package. This cluster starts new jobs as new threads inside the same process. Example:library(parallel)cl0 &amp;lt;- makeCluster(7, &#39;SHARED&#39;)clusterApply(cl0, seq_along(cl0), function(i) i)Worker nodes inherit the attached packages from the parent node with copy-on-write semantics, but not the global environment.This means that you do not need to load again R libraries on the worker nodes but values (including functions) from the globalenvironment have to be transfered to the worker nodes, e.g., using clusterExport.Note that unlike with the FORK or PSOCK clusters the child nodes in SHARED cluster are running in the same process,therefore, e.g., locking files with lockfile or flock will not work. Moreover, the SHARED cluster is based onan assumption that packages’ native code does not mutate shared vectors (which is a discouraged practice) and is threadsafe and re-entrant on the C level.If the code that you want to parallelize does not match these expectations, you can still use the PSOCK cluster with the GraalVM R engine.The FORK cluster and functions depending solely on forking (e.g., mcparallel) are not supported at the moment.1 More technically, GraalVM implementation of R uses a fixed MRAN URL from $R_HOME/etc/DEFAULT_CRAN_MIRROR, which is a snapshot of theCRAN repository as it was visible at a given date from the URL string.2 When this example is run for the first time, it installs the RcppArmadillo package,which may take few minutes. Note that this example can be run in both R executedwith GraalVM and GNU R.",
                    "url": " /docs/reference-manual/languages/r/"
                  },
                  
                  "docs-reference-manual-languages-jvm":  {
                    "title": "JVM Languages Reference",
                    "content": "Running JVM-based AppsGraalVM gives you an enhanced performance for JVM-based applications writtenin languages such as Java, Scala, Groovy, Clojure or Kotlin. It uses a dynamiccompiler that dramatically improves the efficiency and the speed of applicationsthrough unique approaches to code analysis and optimization.InteroperabilityIn addition to running JVM-based languages, you can also call any other languageimplemented with GraalVM Language Implementation Framework directly from Java.See the Polyglot Reference and theEmbedding documentationfor more information about interoperability with other programming languages.Compiler PerformanceThe GraalVM compiler achieves excellent performance for modern workloadssuch as Scala or usage of the Java Streams API. For examples, see theJava performance examples.Compiler Operating ModesThere are two operating modes of the GraalVM compiler when used as a HotSpot JIT compiler:      libgraal: the GraalVM compiler is compiled ahead of time into a native shared library. In this operating mode, the shared library is loaded by the HotSpot VM. The compiler uses memory separate from the HotSpot heap and it runs fast from the start since it does not need to warm-up. This is the default and recommended mode of operation.        jargraal: the GraalVM compiler goes through the same warm-up phase that the rest of Java application does. That is, it is first interpreted before its hot methods are compiled. This mode is selected with the -XX:-UseJVMCINativeLibrary command line option. This will delay the time to reach peak performance as the compileritself needs to be compiled before it produces code quickly. This mode allows you todebug the GraalVM compiler with a Java debugger.  Compiler Configuration on JVMThe options for configuring the GraalVM compiler on the JVM are in 3 categories.General optionsThese are general options for setting/getting configuration details.  -XX:-UseJVMCICompiler: This disables use of the GraalVM compiler as the top tier JIT.This is useful when wanting to compare performance of the GraalVM compiler against the native JIT compilers.      -Dgraal.CompilerConfiguration=&amp;lt;name&amp;gt;: Selects the GraalVM compiler configuration to use. If omitted, the compilerconfiguration with the highest auto-selection priority is used. To see the setof available configurations, supply the value help to this option.    The current configurations and their semantics are:          enterprise: To produce highly optimized code with a possible trade-off to compilation time.This value is only available in GraalVM EE.      community: To produce reasonably optimized code with a faster compilation time.      economy: To compile as fast as possible with less optimal throughput of the generated code.            -Dgraal.ShowConfiguration=none: Prints information about the GraalVM compiler configuration selected.  This option only produces output when the compiler is initialized. By default, the GraalVM compiler is  initialized on the first top-tier compilation. For this reason, the way to use this option  is as follows: java -XX:+EagerJVMCI -Dgraal.ShowConfiguration=info -version.    The accepted values for this option are:          none: To show no information.      info: To print one line of output showing the name of the compiler configuration in use and the location it is loaded from.      verbose: To print detailed compiler configuration information.            -Dgraal.MitigateSpeculativeExecutionAttacks=None: Selects a strategy to mitigate speculative  execution attacks (e.g., SPECTRE).    Accepted values are:          None: No mitigations are used in JIT compiled code.      AllTargets: All branches are protected against speculative attacks. This has a largeperformance impact.      GuardTargets: Only branches that preserve Java memory safety are protected. This hasreduced performance impact.      NonDeoptGuardTargets: Same as GuardTargets except that branches which deoptimize arenot protected since they can not be executed repeatedly.      Performance tuning options  -Dgraal.UsePriorityInlining=true: This can be used to disable use of the advanced inliningalgorithm that favors throughput over compilation speed. This option is only available inGraalVM EE.  -Dgraal.Vectorization=true: This can be used to disable the auto vectorization optimization.This option is only available in GraalVM EE.      -Dgraal.TraceInlining=false: Enables tracing of inlining decisions. This can be used  for advanced tuning where it may be possible to change the source code of the program.  The output format is shown below:    compilation of &#39;Signature of the compilation root method&#39;:at &#39;Sig of the root method&#39; [&#39;Bytecode index&#39;]: &amp;lt;&#39;Phase&#39;&amp;gt; &#39;Child method signature&#39;: &#39;Decision made about this callsite&#39;  at &#39;Signature of the child method&#39; [&#39;Bytecode index&#39;]:     |--&amp;lt;&#39;Phase 1&#39;&amp;gt; &#39;Grandchild method signature&#39;: &#39;First decision made about this callsite&#39;     --&amp;lt;&#39;Phase 2&#39;&amp;gt; &#39;Grandchild method signature&#39;: &#39;Second decision made about this callsite&#39;  at &#39;Signature of the child method&#39; [&#39;Bytecode index&#39;]: &amp;lt;&#39;Phase&#39;&amp;gt; &#39;Another grandchild method signature&#39;: &#39;The only decision made about this callsite.&#39;    For example:    compilation of java.lang.Character.toUpperCaseEx(int):at java.lang.Character.toUpperCaseEx(Character.java:7138) [bci: 22]:   ├──&amp;lt;GraphBuilderPhase&amp;gt; java.lang.CharacterData.of(int): no, bytecode parser did not replace invoke   └──&amp;lt;PriorityInliningPhase&amp;gt; java.lang.CharacterData.of(int): yes, worth inlining according to the cost-benefit analysis.at java.lang.Character.toUpperCaseEx(Character.java:7138) [bci: 26]:   ├──&amp;lt;GraphBuilderPhase&amp;gt; java.lang.CharacterDataLatin1.toUpperCaseEx(int): no, bytecode parser did not replace invoke   └──&amp;lt;PriorityInliningPhase&amp;gt; java.lang.CharacterDataLatin1.toUpperCaseEx(int): yes, worth inlining according to the cost-benefit analysis.  at java.lang.CharacterDataLatin1.toUpperCaseEx(CharacterDataLatin1.java:223) [bci: 4]:     ├──&amp;lt;GraphBuilderPhase&amp;gt; java.lang.CharacterDataLatin1.getProperties(int): no, bytecode parser did not replace invoke     └──&amp;lt;PriorityInliningPhase&amp;gt; java.lang.CharacterDataLatin1.getProperties(int): yes, worth inlining according to the cost-benefit analysis.  Diagnostic options      -Dgraal.CompilationFailureAction=Silent: Specifies the action to take when compilation fails by  throwing an exception.    The accepted values are:          Silent: Print nothing to the console.      Print: Print a stack trace to the console.      Diagnose: Retry the compilation with extra diagnostics enabled. On VM exit, the collected diagnostics are saved to a zip file that can be submitted along with a bug report. A message is printed to the console describing where the diagnostics file is saved:        Graal diagnostic output saved in /Users/graal/graal_dumps/1549459528316/graal_diagnostics_22774.zip            ExitVM: Same as Diagnose except that the VM process exits after retrying.        For all values except for ExitVM, the VM continues executing.    -Dgraal.CompilationBailoutAsFailure=false: The compiler may not complete compilation of a method due to some property or code shape in the method (e.g. exotic uses of the jsr and ret bytecodes). In this case the compilation bails out. If you want to be informed of such bailouts, this option makes GraalVM treat bailouts as failures and thus be subject to the action specified by the -Dgraal.CompilationFailureAction option.  -Dgraal.PrintCompilation=false: Prints an informational line to the console for each completed compilation.For example:    HotSpotCompilation-11  Ljava/lang/Object;                            wait          ()V       |  591ms    12B    92B  4371kBHotSpotCompilation-175 Ljava/lang/String;                            lastIndexOf   (II)I     |  590ms   126B   309B  4076kBHotSpotCompilation-184 Ljava/util/concurrent/ConcurrentHashMap;      setTabAt      ([Ljava/util/concurrent/ConcurrentHashMap$Node;ILjava/util/concurrent/ConcurrentHashMap$Node;)V  |  591ms    38B    67B  3411kBHotSpotCompilation-136 Lsun/nio/cs/UTF_8$Encoder;                    encode        ([CII[B)I |  591ms   740B   418B  4921  Setting Compiler Options with Language LaunchersThe GraalVM compiler properties above are usable with some other GraalVM launchers such asnode, js and lli. The prefix for specifying the properties is slightly different.For example:$ java -XX:+EagerJVMCI -Dgraal.ShowConfiguration=info -versionBecomes:$ js --jvm --vm.Dgraal.ShowConfiguration=info -versionNote the -D prefix is replaced by --vm.D.JVM Operations ManualDifference between running the GraalVM compiler in a Native Image vs on the JVMWhen running the GraalVM compiler on the JVM, it goes through the same warmup phase that therest of Java application does. That is, it is first interpreted beforeits hot methods are compiled. This can translate into slightly longer timesuntil the application reaches peak performance when compared to the native compilersin the JVM such as C1 and C2.To address the issue of taking longer to reach to peak performance, libgraalwas introduced – a shared library, produced using Native Imageframework to ahead-of-time compile the compiler itself. That means the GraalVMcompiler is deployed as a native shared library. In this mode, thecompiler uses memory separate from the HotSpot heap and it runs compiled fromthe start. That is, it has execution properties similar to other native HotSpotcompilers such as C1 and C2. Currently, this is the default mode ofoperation in both GraalVM Community and Enterprise images. It can be disabledwith -XX:-UseJVMCINativeLibrary.Measuring PerformanceThe first thing to be sure of when measuring the performance is to ensure the JVM is using the GraalVM compiler.In the GraalVM binary, the JVM is configured to use the GraalVM compileras the top tier compiler by default. You can confirm this by adding -Dgraal.ShowConfiguration=infoto the command line. It will produce a line of output similar to the one belowwhen the compiler is initialized:Using Graal compiler configuration &#39;community&#39; provided by org.graalvm.compiler.hotspot.CommunityCompilerConfigurationFactory loaded from jar:file:/Users/dsimon/graal/graal/compiler/mxbuild/dists/graal.jar!/org/graalvm/compiler/hotspot/CommunityCompilerConfigurationFactory.classNote that the GraalVM compiler is only initialized on the first top tier JIT compilation requestso if your application is short lived, you may not see this output.Optimizing JVM-based applications is a science in itself. The compilation may noteven be a factor in the case of poor performance as the problem maylie in any other part of the VM (I/O, garbage collection, threading etc) or inpoorly written application or 3rd party library code. For this reason, it’sworth using profilers such as Java Mission Control todiagnose application behavior.You can also compare performance against the native top tier compiler in the JVM byadding -XX:-UseJVMCICompiler to the command line.If you observe a significant performance regression when using the GraalVM compiler, pleaseopen an issue on GitHub. Attaching a Java Flight Recorder log and instructionsto reproduce the issue makes investigation easier and thuschances of a fix higher. Even better is if you can submit a JMHbenchmark that represents the hottest parts of your application (as identifiedby a profiler). This allows us to very quickly pinpoint missing optimizationopportunities or to offer suggestions on how to restructure the code toavoid or reduce performance bottlenecks.Troubleshooting the GraalVM CompilerLike all software, the GraalVM compiler is not guaranteed to be bug free so it is useful toknow how to diagnose and submit useful bug reports if you encounter issues.If you spot a security vulnerability, please do not report it via GitHub Issues or the public mailing lists,but via the process outlined at Reporting Vulnerabilities guide.Compilation ExceptionsOne advantage of the compiler being written in Java is that runtime exceptions duringcompilation are not fatal VM errors. Instead, each compilation has an exceptionhandler that takes an action based on the graal.CompilationFailureActionproperty.The default value is Silent. Specifying Diagnose causes failing compilations to be retriedwith extra diagnostics enabled. Just before the VM exits, all diagnostic outputcaptured during retried compilations is written to a .zip file and its locationis printed on the console:Graal diagnostic output saved in /Users/demo/graal-dumps/1499768882600/graal_diagnostics_64565.zipYou can then attach the .zip file to an issue on GitHub.Apart from Silent and Diagnose the following values for graal.CompilationFailureActionare supported:  Print: Prints a message and stack trace to the console but does not do the re-compilation.  ExitVM: Same as Diagnose but the VM process exits after the re-compilation.Code Generation ErrorsThe other type of error compilers can have is producing incorrect machine code.This error can cause a VM crash, which should produce a file that starts withhs_err_pid in the current working directory of the VM process. In most cases,there is a section in the file that shows the stack at the time of the crash,including the type of code for each frame in the stack, as in the followingexample:Stack: [0x00007000020b1000,0x00007000021b1000],  sp=0x00007000021af7a0,  free space=1017kNative frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)J 761 JVMCI org.graalvm.compiler.core.gen.NodeLIRBuilder.matchComplexExpressions(Ljava/util/List;)V (299 bytes) @ 0x0000000108a2fc01 [0x0000000108a2fac0+0x141] (null)j  org.graalvm.compiler.core.gen.NodeLIRBuilder.doBlock(Lorg/graalvm/compiler/nodes/cfg/Block;Lorg/graalvm/compiler/nodes/StructuredGraph;Lorg/graalvm/compiler/core/common/cfg/BlockMap;)V+211j  org.graalvm.compiler.core.LIRGenerationPhase.emitBlock(Lorg/graalvm/compiler/nodes/spi/NodeLIRBuilderTool;Lorg/graalvm/compiler/lir/gen/LIRGenerationResult;Lorg/graalvm/compiler/nodes/cfg/Block;Lorg/graalvm/compiler/nodes/StructuredGraph;Lorg/graalvm/compiler/core/common/cfg/BlockMap;)V+65This example shows that the top frame was compiled (J) by the JVMCI compiler,which is the GraalVM compiler. The crash occurred at offset 0x141 in the machinecode produced for:org.graalvm.compiler.core.gen.NodeLIRBuilder.matchComplexExpressions(Ljava/util/List;)VThe next two frames in the stack were executing in the interpreter (j). Thelocation of the crash is also often indicated near the top of the file withsomething like this:# Problematic frame:# J 761 JVMCI org.graalvm.compiler.core.gen.NodeLIRBuilder.matchComplexExpressions(Ljava/util/List;)V (299 bytes) @ 0x0000000108a2fc01 [0x0000000108a2fac0+0x141] (null)In this example, there is likely an error in the code produced by the GraalVM compiler for NodeLIRBuilder.matchComplexExpressions.When filing an issue on GitHubfor such a crash, you should first attempt to reproduce the crash with extradiagnostics enabled for the compilation of the problematic method.In this example, you would add the following to your command line:-Dgraal.MethodFilter=NodeLIRBuilder.matchComplexExpressions, -Dgraal.Dump=:2These options are described in more detail here.In brief, these options tell the compiler to capture snapshots of the compiler state atverbosity level 2 while compiling any method named matchComplexExpressions ina class with a simple name of NodeLIRBuilder. The complete format of theMethodFilter option is described in the output of java -XX:+JVMCIPrintProperties.Quite often, the crash location does not exist directly in the problematic methodmentioned in the crash log but comes from an inlined method.In such a case, simply filtering for the problematic method might not capture anerroneous compilation causing a crash.To improve the likelihood of capturing an erroneous compilation, you need tobroaden the MethodFilter value. To guide this, add -Dgraal.PrintCompilation=truewhen trying to reproduce the crash so you can see what was compiled just beforethe crash.The following shows sample output from the console:HotSpotCompilation-1218        Lorg/graalvm/compiler/core/amd64/AMD64NodeLIRBuilder;                  peephole                                      (Lorg/graalvm/compiler/nodes/ValueNode;)Z           |   87ms   428B   447B  1834kBHotSpotCompilation-1212        Lorg/graalvm/compiler/lir/LIRInstructionClass;                         forEachState                                  (Lorg/graalvm/compiler/lir/LIRInstruction;Lorg/graalvm/compiler/lir/InstructionValueProcedure;)V  |  359ms    92B   309B  6609kBHotSpotCompilation-1221        Lorg/graalvm/compiler/hotspot/amd64/AMD64HotSpotLIRGenerator;          getResult                                     ()Lorg/graalvm/compiler/hotspot/HotSpotLIRGenerationResult;  |   54ms    18B   142B  1025kB## A fatal error has been detected by the Java Runtime Environment:##  SIGSEGV (0xb) at pc=0x000000010a6cafb1, pid=89745, tid=0x0000000000004b03## JRE version: OpenJDK Runtime Environment (8.0_121-b13) (build 1.8.0_121-graalvm-olabs-b13)# Java VM: OpenJDK 64-Bit GraalVM (25.71-b01-internal-jvmci-0.30 mixed mode bsd-amd64 compressed oops)# Problematic frame:# J 1221 JVMCI org.graalvm.compiler.hotspot.amd64.AMD64HotSpotLIRGenerator.getResult()Lorg/graalvm/compiler/hotspot/HotSpotLIRGenerationResult; (18 bytes) @ 0x000000010a6cafb1 [0x000000010a6caf60+0x51] (null)## Failed to write core dump. Core dumps have been disabled. To enable core dumping, try &quot;ulimit -c unlimited&quot; before starting Java againHere we see that the crash happened in a different method than the first crash.As such, we expand the filter argument to be -Dgraal.MethodFilter=NodeLIRBuilder.matchComplexExpressions,AMD64HotSpotLIRGenerator.getResultand run again.When the VM crashes in this way, it does not execute the shutdown code thatarchives the GraalVM compiler diagnostic output or delete the directory it was written to.This must be done manually after the crash.By default, the directory is $PWD/graal-dumps/&amp;lt;timestamp&amp;gt;; for example, ./graal-dumps/1499938817387.However, you can set the directory with -Dgraal.DumpPath=&amp;lt;path&amp;gt;.A message, such as the following, is printed to the console when thisdirectory is first used by the compiler:Dumping debug output in /Users/demo/graal-dumps/1499768882600This directory should contain content related to the crashing method, such as:$ ls -l /Users/demo/graal-dumps/1499768882600-rw-r--r--  1 demo  staff    144384 Jul 13 11:46 HotSpotCompilation-1162[AMD64HotSpotLIRGenerator.getResult()].bgv-rw-r--r--  1 demo  staff     96925 Jul 13 11:46 HotSpotCompilation-1162[AMD64HotSpotLIRGenerator.getResult()].cfg-rw-r--r--  1 demo  staff  12600725 Jul 13 11:46 HotSpotCompilation-791[NodeLIRBuilder.matchComplexExpressions(List)].bgv-rw-r--r--  1 demo  staff   1727409 Jul 13 11:46 HotSpotCompilation-791[NodeLIRBuilder.matchComplexExpressions(List)].cfgYou should attach a zip of this directory to an issue on GitHub.",
                    "url": " /docs/reference-manual/languages/jvm/"
                  },
                  
                  "docs-reference-manual-languages-js":  {
                    "title": "GraalVM JavaScript Reference",
                    "content": "GraalVM includes an ECMAScript compliant JavaScript engine.It is designed to be fully standard compliant, execute applications with high performance, and provide all the benefits from the GraalVM stack, including language interoperability and common tooling.With that engine, GraalVM can execute JavaScript and Node.js applications.Running JavaScriptGraalVM can execute plain JavaScript code:js [options] [filename...] -- [args]Running Node.js appsGraalVM is adapted to run unmodified Node.js applications. Applications canimport npm modules, including native ones.To run Node.js-based applications, use the node utility in the GraalVM distribution:node [options] [filename] [args]To install a Node.js module, use the npm executable in the /bin folder of theGraalVM package. The npm command is equivalent to the default Node.jscommand and supports all Node.js APIs.1. Install the colors and ansispan modules using npm install asfollows:npm install colors ansispanAfter the modules are installed, you can use them from your application.2. Add the following code snippet to a file named app.js and save it in the same directory where you installed Node.js modules:                          // RUN-CMD: rm -rf node_modules// RUN-CMD: npm install ansispan colors// RUN-CMD: node {file}// RUN-CMD: rm -r node_modules// BEGIN-SNIPPETconst http = require(&quot;http&quot;);const span = require(&quot;ansispan&quot;);require(&quot;colors&quot;);http.createServer(function (request, response) {    response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/html&quot;});    response.end(span(&quot;Hello Graal.js!&quot;.green));}).listen(8000, function() { console.log(&quot;Graal.js server running at http://127.0.0.1:8000/&quot;.red); });// END-SNIPPETsetTimeout(function() { console.log(&quot;DONE!&quot;); process.exit(); }, 2000);      3. Execute it on GraalVM using the node command as follows:node app.jsInteroperabilityGraalVM supports several other programming languages, including Ruby, R, Pythonand LLVM. While GraalVM is designed to run Node.js and JavaScript applications,it also provides an API for programming language interoperability that lets youexecute code from any other language that GraalVM supports.From JavaScript code you can access Java applications, as in the followingexample:$ node --jvm&amp;gt; var BigInteger = Java.type(&#39;java.math.BigInteger&#39;);&amp;gt; console.log(BigInteger.valueOf(2).pow(100).toString(16));10000000000000000000000000You can also call methods in other programming languages that GraalVM supports:$ node --jvm --polyglot&amp;gt; console.log(Polyglot.eval(&#39;R&#39;, &#39;runif(100)&#39;)[0]);0.8198353068437427We provide migration guides for code previously targeted to the Rhino or Nashorn engines.See the JavaInterop.md for an overview of supported Java interoperability features.For additional information, see the Polyglot Reference and theEmbedding documentationfor more information about interoperability with other programming languages.GraalVM JavaScript CompatibilityGraalVM is ECMAScript 2018 compliant and fully compatible with a diverse range of active Node.js (npm) modules.It will also be compliant to ECMAScript 2019 once this updated specification is published (draft spec).More than 95,000 npm packages are regularly tested and are compatible with GraalVM, including modules like express, react, async, request, browserify, grunt, mocha, and underscore.The latest release of GraalVM is based on Node.js version 10.15.2.Is GraalVM compatible with the JavaScript language?What version of ECMAScript do we support?GraalVM is compatible to the ECMAScript 2019 specification.Some features of ECMAScript 2020 including some proposed features and extensions are available as well, but might not be fully implemented, compliant, or stable, yet.How do we know it?GraalVM is tested against the official test suite of ECMAScript, test262.On the current stable feature set of ECMAScript 2019, GraalVM compliance is above 99%.In our internal CI system, we test against test262, tests published by Nashorn and V8, Node unit tests, as well as GraalVM’s own unit tests.From the graaljs code repository, you can execute the whole test262 test suite:mx test262 gateThis will execute test262 in a mode to guarantee that local changes do not regress compatibility, i.e., results in an error if any tests expected to pass actually fail.Individual tests can be executed withmx test262 single=built-ins/Array/length.jsFor a reference of the JavaScript APIs that GraalVM supports, see GRAAL.JS-API.Is GraalVM compatible with the original node implementation?Node.js based on GraalVM is largely compatible with the original Node.js (based on the V8 engine).This leads to a high number of npm-based modules being compatible with GraalVM (out of the 95k modules we test, more than 90% of them pass all tests).Several sources of differences have to be considered.      Setup:GraalVM mostly mimicks the original setup of Node, including the node executable, npm, and similar. However, not all command-line options are supported (or behave exactly identically), you need to (re-)compile native modules against our v8.h file, etc.        Internals:GraalVM is implemented on top of a JVM, and thus has a different internal architecture. This implies that some internal mechanisms behave differently and cannot exactly replicate V8 behavior. This will hardly ever affect user code, but might affect modules implemented natively, depending on V8 internals.        Performance:Due to GraalVM being implemented on top of a JVM, performance characteristics vary from the original native implementation. While GraalVM’s peak performance can match V8 on many benchmarks, it will typically take longer to reach the peak (known as warmup). Be sure to give the GraalVM compiler some extra time when measuring (peak) performance.  How do we determine GraalVM’s JavaScript compatibility?GraalVM is compatible to ECMAScript 2019, guaranteeing compatibility on the language level.In addition, GraalVM uses the following approaches to check and retain compatibility to Node.js code:  node-compat-table: GraalVM is compared against other engines using the node-compat-table module, highlighting incompatibilities that might break Node.js code.  automated mass-testing of modules using mocha: in order to test a large set of modules, GraalVM is tested against 95k modules that use the mocha test framework. Using mocha allows automating the process of executing the test and comprehending the test result.  manual testing of popular modules: a select list of npm modules is tested in a manual test setup. These highly-relevant modules are tested in a more sophisticated manner.If you want your module to be tested by GraalVM in the future, ensure the module provides some mocha tests (and send us an email so we can ensure it is on the list of tested modules).How can one verify GraalVM works on their application?If your module ships with tests, execute them with GraalVM.Of course, this will only test your app, but not its dependencies.You can use the compatibility checker to find whether the module you’re interested in is tested on GraalVM, whether the tests pass successfully and so on.Additionally, you can upload your package-lock.json or package.json file into that utility and it’ll analyze all your dependencies at once.GraalVM JavaScript OptionsOn the command line, --js.&amp;lt;property&amp;gt;=&amp;lt;value&amp;gt; sets options that tune language features and extensions.The following options are currently supported:  --js.annex-b: enables ECMAScript Annex B web compatibility features. Boolean value, default is true.  --js.array-sort-inherited: defines whether Array.protoype.sort should sort inherited keys (implementation-defined behavior). Boolean value, default is true.  --js.atomics: enables ES2017 Atomics. Boolean value, default is true.  --js.ecmascript-version: emulates a specific ECMAScript version. Integer value (5-9), default is the latest version.  --js.intl-402: enables ECMAScript Internationalization API. Boolean value, default is false.  --js.regexp-static-result: provides static RegExp properties containing results of the last successful match, e.g.: RegExp.$1 (legacy). Boolean value, default is true.  --js.shared-array-buffer: enables ES2017 SharedArrayBuffer. Boolean value, default is false.  --js.strict: enables strict mode for all scripts. Boolean value, default is false.  --js.timezone: sets the local time zone. String value, default is the system default.  --js.v8-compat: provides better compatibility with Google’s V8 engine. Boolean value, default is false.Use --help:languages to see the full list of available options.See the Polyglot Reference for information on how to set options programmatically when embedding.GraalVM Options--jvm executes the application on the JVM instead of in the Native Image.--vm.&amp;lt;option&amp;gt; passes VM options and system properties to the Native Image.To pass JVM options to GraalVM you need to provide --jvm before,i.e., --jvm --vm.&amp;lt;option&amp;gt;. List all available system properties to the Native Image,JVM and VM options and with --help:vm.System properties can be set as follows: --vm.D&amp;lt;name&amp;gt;=&amp;lt;value&amp;gt;.For example, --vm.Dgraal.TraceTruffleCompilation=true will print finished compilations.--compiler.&amp;lt;property&amp;gt;=&amp;lt;value&amp;gt; passes settings to the compiler.For example, --compiler.CompilationThreshold=&amp;lt;Integer&amp;gt; sets the minimum number of invocations or loop iterations before a function is compiled.Polyglot Options--polyglot enables you to interoperate with other programming languages.--&amp;lt;languageID&amp;gt;.&amp;lt;property&amp;gt;=&amp;lt;value&amp;gt; passes options to guest languages through the GraalVM Polyglot SDK.Use --help:languages to find out which options are available.GraalVM JavaScript Operations ManualWhat’s the difference between running GraalVM’s JavaScript in a Native Image compared to the JVM?In essence, the JavaScript engine of GraalVM is a plain Java application.Running it on any JVM (JDK 8 or higher) is possible; for best performance, it should be the GraalVM or a compatible JVMCI-enabled JDK using the GraalVM compiler.This mode gives the JavaScript engine full access to Java at runtime, but also requires the JVM to first (just-in-time) compile the JavaScript engine when executed, just like any other Java application.Running in a Native Image means that the JavaScript engine, including all its dependencies from, e.g., the JDK, is pre-compiled into a native binary.This will tremendously speed up the startup of any JavaScript application, as GraalVM can immediately start to compile JavaScript code, without itself requiring to be compiled first.This mode, however, will only give GraalVM access to Java classes known at the time of image creation.Most significantly, this means that the JavaScript-to-Java interoperability features are not available in this mode, as they would require dynamic class loading and execution of arbitrary Java code at runtime.How to achieve the best peak performance?Optimizing JVM-based applications is a science in itself.Here are a few tips and tricks you can follow to analyse and improve peak performance:  When measuring, ensure you have given the GraalVM compiler enough time to compile all hot methods before starting to measure peak performance. A useful command line option for that is --vm.Dgraal.TraceTruffleCompilation=true – this outputs a message whenever a (JavaScript) method is compiled. As long as this still prints frequently, measurement should not yet start.  Compare the performance between the Native Image and the JVM mode if possible. Depending on the characteristics of your application, one or the other might show better peak performance.  The Polyglot API comes with several tools and options to inspect the performance of your application:          --cpusampler and --cputracer will print a list of the hottest methods when the application is terminated. Use that list to figure out where most time is spent in your application. More details about the command line options for the polyglot commands can be found from the  polyglot documentation.      --experimental-options --memtracer can help you understand the memory allocations of your application. Refer to Profiling command line tools reference for more detail.      ",
                    "url": " /docs/reference-manual/languages/js/"
                  },
                  
                  "docs-reference-manual-languages-ruby":  {
                    "title": "Reference Manual for TruffleRuby",
                    "content": "TruffleRuby is an implementation of the Ruby programming language on top of GraalVM that aims to:  Run idiomatic Ruby code faster  Run Ruby code in parallel  Boot Ruby applications in less time  Execute C extensions in a managed environment  Add fast and low-overhead interoperability with languages like Java, JavaScript, Python and R  Provide new tooling such as debuggers and monitoring  All while maintaining very high compatibility with the standard implementation of RubyWarning: The support for Ruby is experimental.Experimental features might never be included in a production version, or mightchange significantly before being considered production-ready.If you are attempting to experiment with deploying TruffleRuby to production wewould encourage you to contact us so we can help you understand what is possible atthe moment and to help solve any issues for you.TruffleRuby repositoryThe TruffleRuby project is open source and located on GitHub: oracle/truffleruby. If you encounter any issues or want to leave feedback or feature requests please create an issue in this repository.Installing RubyTruffleRuby can be installed to a GraalVM build with the gu command.See graalvm/bin/gu --help for more information.Running Ruby applicationsRun Ruby applications with the standard ruby command:$ ruby [options] program.rbOther Ruby commands are available, including gem, irb, rake, rdoc,and ri.TruffleRuby uses thesame options as the standard implementation of Ruby with some additions.Installing a Ruby gem$ gem install chunky_png$ ruby -r chunky_png -e &quot;puts ChunkyPNG::Color.to_hex(ChunkyPNG::Color(&#39;mintcream @ 0.5&#39;))&quot;#f5fffa80What does TruffleRuby do?Run idiomatic Ruby code fasterTruffleRuby in conjunction with the GraalVM produces very fast machine code.Traditionally, performance-critical Ruby code has had to be extracted out tolanguage extensions implemented in native code. This approach is cumbersome anderror-prone. TruffleRuby on the GraalVM is able to optimize Ruby code. Moreimportantly, it can optimize idiomatic Ruby code.The following example template rendering benchmark is taken from theMRI benchmark suite.It has been modified to work with the benchmark-ips benchmarking harness,and to write the result of the render to a file in order to include IO.require &#39;benchmark/ips&#39;require &#39;erb&#39;data = &amp;lt;&amp;lt;erb&amp;lt;html&amp;gt;&amp;lt;head&amp;gt; &amp;lt;%= title %&amp;gt; &amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;  &amp;lt;h1&amp;gt; &amp;lt;%= title %&amp;gt; &amp;lt;/h1&amp;gt;  &amp;lt;p&amp;gt;    &amp;lt;%= content %&amp;gt;  &amp;lt;/p&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;erbtitle = &#39;hello world!&#39;content = &quot;hello world!n&quot; * 10erb = ERB.new(data)out = File.open(&#39;test.out&#39;, &#39;w&#39;)Benchmark.ips do |x|  x.iterations = 3  x.report(&quot;erb&quot;) { out.write(erb.result(binding)) }end$ gem install benchmark-ips$ ruby benchmark.rb            MRI 2.5.3      JRuby 9.2.5.0      TruffleRuby  CE native      TruffleRuby  EE JVM                  34 K renders/s      29 K renders/s      542 K renders/s  (16x faster)      1 M renders/s  (31x faster)      Run Ruby code in parallelTruffleRuby runs threads in parallel, without a global-interpreter-lock. Itincludes sophisticated techniques to automatically make objects thread-safe onlywhen they are going to be used by more than one thread, leaving themunsynchronized when used from only one thread to give you parallelism without anoverhead when you do not want to use it.Boot Ruby applications in less timeA hello-world script in TruffleRuby runs about as fast as MRI, or over ten timesfaster than JRuby. TruffleRuby can run without a heavy-weight JVM so that youstart running your Ruby code almost immediately.Execute C extensions in a managed environmentTruffleRuby executes C extensions using a managed C interpreter and just-in-timecompiler, not by running native code.Provide new toolingTruffleRuby includes a built-in debugger that allows you to use Chrome DevToolson your Ruby application.$ ruby --inspect test.rbDebugger listening on port 9229.To start debugging, open the following URL in Chrome:    chrome-devtools://devtools/bundled/inspector.html?ws=127.0.0.1:9229/ffffffffffffffff-fffffffffffffffffAdd fast and low-overhead interoperabilityTruffleRuby allows you to write polyglot programs using the other languages fromGraalVM.High compatibility with the standard implementation of RubyTruffleRuby aims to be fully compatible with the standard implementation ofRuby, MRI, version 2.6.2. We test extensively using the MRItest suite and the Ruby Spec project.InteroperabilityGraalVM supports several other programming languages, including JavaScript, R,Python, and LLVM. TruffleRuby lets you run code from these languages, and useobjects and methods from one language in another.As an example, we can pass a JSON-encoded string into Graal.js, decode it intoa JavaScript object, and then inspect the decoded object in Ruby:require &#39;json&#39;obj = {  time: Time.now,  msg: &#39;Hello World&#39;,  payload: (1..10).to_a}encoded = JSON.dump(obj)js_obj = Polyglot.eval(&#39;js&#39;, &#39;JSON.parse&#39;).call(encoded)puts js_obj[:time]puts js_obj[:msg]puts js_obj[:payload].join(&#39; &#39;)We use the --jvm --polyglot option to say we want to run a polyglot program.$ ruby --jvm --polyglot test.rb2018-04-11 15:25:08 -0700Hello World1 2 3 4 5 6 7 8 9 10CompatibilityTruffleRuby aims to be fully compatible with the standard implementation ofRuby, MRI, version 2.6.2, revision 67232.Any incompatibility with MRI is considered a bug, except for rare cases detailed below.If you find an incompatibility with MRI, please report it to us.Our policy is to match the behaviour of MRI, except where we do not know how todo so with good performance for typical Ruby programs. Some features work butwill have very low performance whenever they are used and we advise againstusing them on TruffleRuby if you can. Some features are missing entirely and maynever be implemented. In a few limited cases, we are deliberately incompatiblewith MRI in order to provide a greater capability.In general, we are not looking to debate whether Ruby features are good, bad, orif we could design the language better. If we can support a feature, we will do.In the future, we aim to provide compatibility with extra functionality providedby JRuby, but at the moment we do not.IdentificationTruffleReport defines these constants for identification:  RUBY_ENGINE is &#39;truffleruby&#39;  RUBY_VERSION is the compatible MRI version  RUBY_REVISION is the compatible MRI version revision  RUBY_PATCHLEVEL is always zero  RUBY_RELEASE_DATE is the Git commit date  RUBY_ENGINE_VERSION is the GraalVM version, or 0.0- and the Git commit hash if your build is not part of a GraalVM release.Additionally, TruffleRuby defines:  TruffleRuby.revision which is the Git commit hashIn the C API, we define a preprocessor macro TRUFFLERUBY.Features entirely missingContinuations and callccContinuations and callcc are unlikely to ever be implemented in TruffleRuby,as their semantics fundamentally do not match the technology that we are using.ForkYou cannot fork the TruffleRuby interpreter. The feature is unlikely to everbe supported when running on the JVM but could be supported in the future inthe native configuration. The correct and portable way to test if fork isavailable is:Process.respond_to?(:fork)Standard librariesThe following standard libraries are unsupported.  continuation  dbm  gdbm  sdbm  debug (could be implemented in the future, use --inspect instead)  profile (could be implemented in the future, use --cpusampler instead)  profiler (could be implemented in the future, use --cpusampler instead)  io/console (partially implemented, could be implemented in the future)  io/wait (partially implemented, could be implemented in the future)  pty (could be implemented in the future)  ripper (has a no-op implementation, and could be implemented in the future)  win32  win32olefiddle is not yet implemented - the module and some methods are therebut not enough to run anything serious.We provide our own included implementation of the interface of the ffi gem,like JRuby and Rubinius. The implementation should be fairly complete and passesall the specs of the ffi gem except for some rarely-used corner cases.Safe levels$SAFE and Thread#safe_level are 0 and no other levels are implemented.Trying to use level 1 will raise a SecurityError. Other levels will raiseArgumentError as in standard Ruby. See our security notes formore explanation on this.Internal MRI functionalityRubyVM is not intended for users and is not implemented.RDoc HTML generationTruffleRuby does not include the Darkfish theme for RDoc.Features with major differencesThreads run in parallelIn MRI, threads are scheduled concurrently but not in parallel. In TruffleRubythreads are scheduled in parallel. As in JRuby and Rubinius, you are responsiblefor correctly synchronising access to your own shared mutable data structures,and we will be responsible for correctly synchronising the state of theinterpreter.Threads detect interrupts at different pointsTruffleRuby threads may detect that they have been interrupted at differentpoints in the program to where it would on MRI. In general, TruffleRuby seemsto detect an interrupt sooner than MRI. JRuby and Rubinius are also differentto MRI, the behaviour is not documented in MRI, and it is likely to changebetween MRI versions, so we would not recommend depending on interrupt pointsat all.Fibers do not have the same performance characteristics as in MRIMost use cases of fibers rely on them being easy and cheap to start up andhaving low memory overheads. In TruffleRuby we implement fibers using operatingsystem threads, so they have the same performance characteristics as Rubythreads. As with coroutines and continuations, a conventional implementationof fibers fundamentally is not compatible with the execution model we arecurrently using.Some classes marked as internal will be differentMRI provides some classes that are described in the documentation as being onlyavailable on MRI (C Ruby). We implement these classes if it is practical to doso, but this is not always the case. For example RubyVM is not available.Features with subtle differencesCommand line switches-y, --yydebug, --dump=, --debug-frozen-string-literal are ignored witha warning as they are unsupported development tools.Programs passed in -e arguments with magic-comments must have an encoding thatis UTF-8 or a subset of UTF-8, as the JVM has already decoded arguments by thetime we get them.--jit options and the jit feature are not supported because TruffleRubyuses the GraalVM compiler as a JIT.Time is limited to millisecond precisionRuby normally provides microsecond (millionths of a second) clock precision,but TruffleRuby is currently limited to millisecond (thousands of a second)precision. This applies to Time.now andProcess.clock_gettime(Process::CLOCK_REALTIME).Setting the process title does not always workSetting the process title (via $0 or Process.setproctitle in Ruby) is doneas best-effort. It may not work, or the title you try to set may be truncated.Line numbers other than 1 work differentlyIn an eval where a custom line number can be specified, line numbers below 1are treated as 1, and line numbers above 1 are implemented by inserting blanklines in front of the source before parsing it.The erb standard library has been modified to not use negative line numbers.Polyglot standard IO streamsIf you use standard IO streams provided by the Polyglot engine, via theexperimental --polyglot-stdio option, reads and writes to file descriptors 1,2 and 3 will be redirected to these streams. That means that other IOoperations on these file descriptors, such as isatty may not be relevant forwhere these streams actually end up, and operations like dup may lose theconnection to the polyglot stream. For example, if you $stdout.reopen, assome logging frameworks do, you will get the native standard-out, not thepolyglot out.Also, IO buffer drains, writes on IO objects with sync set, andwrite_nonblock, will not retry the write on EAGAIN and EWOULDBLOCK, as thestreams do not provide a way to detect this.Error messagesError message strings will sometimes differ from MRI, as these are not generallycovered by the Ruby Specification suite or tests.SignalsThe set of signals that TruffleRuby can handle is different from MRI. Whenlaunched as a GraalVM Native Image, TruffleRuby allows trapping all the samesignals that MRI does, as well as a few that MRI does not. The only signalsthat cannot be trapped are KILL, STOP, and VTALRM. Consequently, anysignal handling code that runs on MRI can run on TruffleRuby without modificationin the GraalVM Native Image.However, when run on the JVM, TruffleRuby is unable to trap USR1 or QUIT,as these are reserved by the JVM itself. Any code that relies on being able totrap those signals will need to fallover to another available signal. Additionally,FPE, ILL, KILL, SEGV, STOP, and VTALRM cannot be trapped, but thesesignals are also unavailable on MRI.When TruffleRuby is run as part of a polyglot application, any signals that arehandled by another language become unavailable for TruffleRuby to trap.Features with very low performanceObjectSpaceUsing most methods on ObjectSpace will temporarily lower the performance ofyour program. Using them in test cases and other similar ‘offline’ operations isfine, but you probably do not want to use them in the inner loop of yourproduction application.set_trace_funcUsing set_trace_func will temporarily lower the performance of your program.As with ObjectSpace, we would recommend that you do not use this in the innerloop of your production application.BacktracesThrowing exceptions, and other operations which need to create a backtrace, areslower than on MRI. This is because we have to undo optimizations that we haveapplied to run your Ruby code fast in order to recreate the backtrace entries.We would not recommend using exceptions for control flow on any implementation ofRuby anyway.To help alleviate this problem in some cases backtraces are automaticallydisabled where we dynamically detect that they probably will not be used. See theexperimental --backtraces-omit-unused option.C Extension CompatibilityVALUE is a pointerIn TruffleRuby VALUE is a pointer type (void *) rather than ainteger type (long). This means that switch statements cannot bedone using a raw VALUE as they can with MRI. You can normallyreplace any switch statement with if statements with littledifficulty if required.Identifiers may be macros or functionsIdentifiers which are normally macros may be functions, functions may be macros,and global variables may be macros. This may cause problems where they are usedin a context which relies on a particular implementation (e.g., taking theaddress of it, assigning to a function pointer variable and using defined() tocheck if a macro exists). These issues should all be considered bugs and befixed, please report these cases.rb_scan_argsrb_scan_args only supports up to ten pointers.RDATAThe mark function of RDATA and RTYPEDDATA is not called duringgarbage collection. Instead we simulate this by caching informationabout objects as they are assigned to structs, and periodically runall mark functions when the cache has become full to represent thoseobject relationships in a way that the our garbage collector willunderstand. The process should behave identically to MRI.Compatibility with JRubyRuby to Java interopTruffleRuby does not support the same interop to Java interface as JRuby does.We provide an alternate polyglot API for interoperating withmultiple languages, including Java, instead.Java to Ruby interopCalling Ruby code from Java is supported by theGraalVM polyglot API.Java extensionsUse Java extensions written for JRuby is not supported. We could apply the sametechniques as we have developed to run C extensions to this problem, but it isnot clear if this will ever be a priority.Compatibility with RubiniusWe do not have any plans at the moment to provide support for Rubinius’extensions to Ruby.Features not yet supported in native configuration  Java interopRunning TruffleRuby in the native configuration is mostly the same as runningon the JVM. There are differences in resource management, as both VMs usedifferent garbage collectors. But, functionality-wise, they are essentially onpar with one another. The big difference is support for Java interop, whichcurrently relies on reflection. TruffleRuby’s implementation of Java interopdoes not work with the GraalVM Native Image Generator’s limited support forruntime reflection.Spec Completeness‘How many specs are there?’ is not a question with an easy precise answer. Thenumber of specs varies for different versions of the Ruby language, differentplatforms, different versions of the specs, and different configurations ofthe specs. The specs for the standard library and C extension API are alsovery uneven and they so can give misleading results.For the command line interface, the language, and the core library specs,which covers the bulk of what TruffleRuby reimplements, this is how many specexamples TruffleRuby runs successfully compared to our compatible version ofMRI running the version of specs from TruffleRuby:  Command line 112 / 136, 82%  Language 2270 / 2332, 97%  Core library 19453 / 20644, 94%Compatibility with gemsYou can use the compatibility checker to find whether the gems you are interested in are tested on GraalVM, whether the tests pass successfully and so on. Additionally, you can drop your Gemfile.lock file into that tool and it will analyze all the gems you are using at once. Note that the processing is done on the client-side, so no information is uploaded to any servers.TruffleRuby Options and Command LineTruffleRuby has the same command line interface as our compatible MRI version.Usage: truffleruby [switches] [--] [programfile] [arguments]  -0[octal]       specify record separator (0, if no argument)  -a              autosplit mode with -n or -p (splits $_ into $F)  -c              check syntax only  -Cdirectory     cd to directory before executing your script  -d, --debug     set debugging flags (set $DEBUG to true)  -e &#39;command&#39;    one line of script. Several -e&#39;s allowed. Omit [programfile]  -Eex[:in], --encoding=ex[:in]                  specify the default external and internal character encodings  -Fpattern       split() pattern for autosplit (-a)  -i[extension]   edit ARGV files in place (make backup if extension supplied)  -Idirectory     specify $LOAD_PATH directory (may be used more than once)  -l              enable line ending processing  -n              assume &#39;while gets(); ... end&#39; loop around your script  -p              assume loop like -n but print line also like sed  -rlibrary       require the library before executing your script  -s              enable some switch parsing for switches after script name  -S              look for the script using PATH environment variable  -T[level=1]     turn on tainting checks  -v              print the version number, then turn on verbose mode  -w              turn warnings on for your script  -W[level=2]     set warning level; 0=silence, 1=medium, 2=verbose  -x[directory]   strip off text before #!ruby line and perhaps cd to directory  --copyright     print the copyright  --enable={gems|rubyopt|...}[,...], --disable={gems|rubyopt|...}[,...]                  enable or disable features. see below for available features  --external-encoding=encoding, --internal-encoding=encoding                  specify the default external or internal character encoding  --verbose       turn on verbose mode and disable script from stdin  --version       print the version number, then exit  --help          show this message, -h for short messageFeatures:  gems            rubygems (default: enabled)  did_you_mean    did_you_mean (default: enabled)  rubyopt         RUBYOPT environment variable (default: enabled)  frozen-string-literal                  freeze all string literals (default: disabled)TruffleRuby also reads the RUBYOPT environment variable, as in standardRuby, if run from the Ruby launcher.Unlisted Ruby switchesMRI has some extra Ruby switches which are are not normally listed in help outputbut are documented in the Ruby manual page.  -Xdirectory     cd to directory before executing your script (same as -C)  -U              set the internal encoding to UTF-8  -K[EeSsUuNnAa]  sets the source and external encoding  --encoding=external[:internal]                  the same as --external-encoding=external and optionally --internal-encoding=internalTruffleRuby optionsTruffleRuby options are set via --option=value, or you can use--ruby.option=value from any launcher. You can omit =value to set to true.Available options and documentation can be seen with --help:languages.Additionally set --help:expert and --help:internal to see those categoriesof options. Warning: All options are experimental and subject to change atany time. Experimental features might never be included in a production version,or might change significantly before being considered production-ready.Options can also be set as JVM system properties, where they have a prefixpolyglot.ruby.. For example --vm.Dpolyglot.ruby.cexts.remap=true, or viaany other way of setting JVM system properties. Finally, options can be set asGraalVM polyglot API configuration options.The priority for options is the command line first, then the Graal-SDK polyglotAPI configuration, then system properties last.TruffleRuby options, as well as conventional Ruby options and VM options, canalso bet set in the TRUFFLERUBYOPT and RUBYOPT environment variables, ifrun from the Ruby launcher.-- or the first non-option argument stops processing of TrufflRuby and VMoptions in the same way it stops processing of Ruby arguments.VM optionsTo set options in the underlying VM, use --vm., valid for both the nativeconfiguration and the JVM configuration.For example --vm.Dsystem_property=value or --vm.ea.To set the classpath, use the = notation, rather than two separate arguments.For example --vm.cp=lib.jar or --vm.classpath=lib.jar.Other binary switchesOther binaries, such as irb, gem, and so on, support exactly the sameswitches as in standard Ruby.Determining the TruffleRuby homeTruffleRuby needs to know where to locate files such as the standard library.These are stored in the TruffleRuby home directory.The search priority for finding Ruby home is:  The value of the TruffleRuby home option (i.e., --home=path/to/truffleruby_home).  The home that the Truffle framework reports.  The parent of the directory containing the Ruby launcher executable.If the home option is set, it is used even if it does not appear to be a correcthome location. Other options are tried until one is found that appears to be acorrect home location. If none appears to be correct a warning will be given butthe program will continue and you will not be able to require standardlibraries. You can tell TruffleRuby not to try to find a home at all using theno-home-provided option.Operations ManualIf you are attempting to experiment with deploying TruffleRuby to production wewould encourage you to contact us so we can help you understand what is possibleat the moment and to help solve any issues for you.TruffleRuby configurationsThere are two main configurations of TruffleRuby - Native Image and JVM. It isimportant to understand the different configurations of TruffleRuby, as each hasdifferent capabilities and performance characteristics. You should pick theexecution mode that is appropriate for your application.When distributed as part of GraalVM, TruffleRuby by default runs in the Native Imageconfiguration. In this configuration, TruffleRuby is ahead-of-time compiled to astandalone native executable. This means that you do not need a JVM installed onyour system to use it. The advantage of the native configuration is that itstarts about as fast as MRI,it may use less memory, and it becomes fast in less time than the JVM configuration. The disadvantageof the native configuration is that you cannot use Java tools like VisualVM, youyou cannot use Java interoperability, and peak performance may be lower than on theJVM. The Native Image configuration is used by default, but you can also request itusing --native. To use polyglot programming with the native configuration,you need to use the --polyglot flag.TruffleRuby can also be used in the JVM configuration, where it runs as anormal Java application on the JVM, as any other Java application would. Theadvantage of the JVM configuration is that you can use Java interoperability, andpeak performance may be higher than the Native Image configuration. The disadvantageof the JVM configuration is that it takes much longer to start and to get fast,and may use more memory. The JVM configuration is requested using --jvm.If you are running a short-running program you probably want the default,Native Image, configuration. If you are running a long-running program and want thehighest possible performance you probably want the JVM configuration, by using--jvm.Getting the best startup time performanceTo get the best startup time performance in most cases you want to use thenative configuration, which is the default.Getting the lowest memory footprintTo get the lowest memory footprint you probably initially want to use the nativeconfiguration, but as you get a larger working set of objects you may find thatthe simpler garbage collector and current lack of compressed ordinary objectpointers (OOPS) actually increases your memory footprint and you will be betteroff with the JVM configuration using --jvm to reduce memory use.Getting the best peak performance from TruffleRubyTo get the best peak performance from TruffleRuby for longer-runningapplications we would in most cases recommend the JVM configuration with--jvm.However to reach this peak performance you need to warm-up TruffleRuby, as youdo with most heavily optimizing virtual machines. This is done by running theapplication under load for a period of time. If you monitor the performance (bymeasuring operation time, or response time) you will see it reduce over time andthen probably stabilize.Tuning TruffleRubyTo tune TruffleRuby you will need to consider the options of either your JVM orthe Native Image, and then the Truffle framework, and the GraalVM compiler.TruffleRuby has a large set of options, which you can see with the --help:languagesflag.LoggingRuby application logging and warning works as in the standard implementation ofRuby.For logging of TruffleRuby internals, standard Java logging is used. The logginglevel can be set with --log.level=INFO, =FINEST, or so on.Troubleshooting TruffleRubyWarning: The GraalVM implementation of Ruby is experimental and we cannot guarantee it to be bug free. Experimental features mightnever be included in a production version, or might change significantly beforebeing considered production-ready.TruffleRuby uses sophisticated techniques to optimise a Ruby program and its users are strongly encouraged to submit useful bug reports to Truffleruby issues. If you encounter a performance problem, please consider the recommendations in Reporting Performance Problems document  .",
                    "url": " /docs/reference-manual/languages/ruby/"
                  },
                  
                  "docs-reference-manual-languages-python":  {
                    "title": "Reference Manual for Python",
                    "content": "GraalVM provides an early-stage implementation of Python 3.7.Warning: The support for Python is experimental.Experimental features might never be included in a production version, or mightchange significantly before being considered production-ready.A primary goal is to support SciPy and its constituentlibraries. At this point, the Python implementation is made available forexperimentation and curious end-users.Installing PythonPython can be installed to a GraalVM build with the gu command. See bin/gu --help for more information.Running PythonOur implementation of Python targets Python 3.7 compatibility at the moment. While support forthe Python language is still limited, you can run simple Python scripts or commandswith the graalpython binary:$ graalpython [options] [-c cmd | filename]If no program file or command is given, you are dropped into a simple REPL.GraalVM supports some of the same options as Python 3.7 and some additionaloptions to control the underlying Python implementation and the GraalVM tools andexecution engine. These can be viewed using the following command:$ graalpython --help --help:tools --help:languagesInteroperabilityGraalVM supports several other programming languages, including JavaScript, R,Ruby, and LLVM. GraalVM provides a Python API to interact with other languagesavailable on the GraalVM. In fact, GraalVM uses this API internally toexecute Python C extensions using the LLVM implementation in GraalVM.To run the following script, pass the --jvm --polyglot options tograalpython binary. This makes other GraalVM languages available in scripts.As a simple example, we can use the JavaScript regular expression engine tomatch Python strings:import polyglotre = polyglot.eval(string=&quot;RegExp()&quot;, language=&quot;js&quot;)pattern = re.compile(&quot;.*(?:we have (?:a )?matching strings?(?:[!?] )?)(.*)&quot;)if pattern.exec(&quot;This string does not match&quot;):    raise SystemError(&quot;that shouldn&#39;t happen&quot;)md = pattern.exec(&quot;Look, we have matching strings! This string was matched by Graal.js&quot;)if not md:    raise SystemError(&quot;this should have matched&quot;)print(&quot;Here is what we found: &#39;%s&#39;&quot; % md[1])If you put this code into a file polyglot_example.py, you can run it with:$ graalpython --jvm --polyglot polyglot_example.pyThis example matches Python strings using the JavaScript regular expression objectand Python reads the captured group from the JavaScript result and prints: Hereis what we found: &#39;This string was matched by Graal.js&#39;.As a more complex example, we can read a file using R, process the data inPython, and use R again to display the resulting data image, using both R andPython libraries in conjunction. To run it, first install therequired R library:$ R -e &#39;install.packages(&quot;https://www.rforge.net/src/contrib/jpeg_0.1-8.tar.gz&quot;, repos=NULL)&#39;This example also uses image_magix.py and workson a JPEG image input. (You can try with thisimage, for example). These files haveto be in the same folder the script below is located in and executed from.import polyglotimport sysimport timesys.path.insert(0, &quot;.&quot;)from image_magix import Imageload_jpeg = polyglot.eval(string=&quot;&quot;&quot;function(file.name) {    library(jpeg)    jimg &amp;lt;- readJPEG(file.name)    jimg &amp;lt;- jimg*255    jimg}&quot;&quot;&quot;, language=&quot;R&quot;)raw_data = load_jpeg(&quot;python_demo_picture.jpg&quot;)# the dimensions are R attributes; define function to access themgetDim = polyglot.eval(string=&quot;function(v, pos) dim(v)[[pos]]&quot;, language=&quot;R&quot;)# Create object of Python class &#39;Image&#39; with loaded JPEG dataimage = Image(getDim(raw_data, 2), getDim(raw_data, 1), raw_data)# Run Sobel filterresult = image.sobel()draw = polyglot.eval(string=&quot;&quot;&quot;function(processedImgObj) {    require(grDevices)    require(grid)    mx &amp;lt;- matrix(processedImgObj$`@data`/255, nrow=processedImgObj$`@height`, ncol=processedImgObj$`@width`)    grDevices:::awt()    grid.raster(mx, height=unit(nrow(mx),&quot;points&quot;))}&quot;&quot;&quot;, language=&quot;R&quot;)draw(result)time.sleep(10)See the Polyglot Reference and theEmbedding documentationfor more information about interoperability with other programming languages.ToolingAlthough GraalVM’s Python implementation is far from complete and cannot run the standard Pythondebugger pdb, the tools that GraalVM itself provides do work.To debug applications in the Chrome browser, for example, you can run a script like so:$ graalpython --inspect [script-to-debug.py]Debugger listening on port 9229.To start debugging, open the following URL in Chrome:    chrome-devtools://devtools/bundled/inspector.html?ws=127.0.0.1:9229/15615099-351e94d1e2dbPlease note: This Python implementation is in the very early stages, and can run little more than basic benchmarks at this point.The graalpython --help:tools command will give you more informationabout tools currently supported on Python.Native Images and JVM RuntimeBy default, GraalVM runs Python from an ahead-of-time compiled binary, yieldingfaster startup time and lower footprint. However, the ahead-of-time compiledbinary only includes the Python and LLVM interpreters. To interoperate withother languages, we had to supply the --jvm argument above. This instructs thelauncher to run on the JVM instead of in the Native Image mode – you will notice alonger startup time.Python CompatibilityIs GraalVM compatible with the Python language?GraalVM’s implementation of Python is in the early stages of development. A primary goal is to supportSciPy and its constituent libraries, but we have a long way to go there. At thispoint, the Python implementation is made available for experimentation andcurious end-users. GraalVM currently aims to be compatible with Python 3.7,but it is a long way from there, and it is very likely that any Python programthat requires any imports at all will hit something unsupported.Is there any progress in GraalVM and Python packages compatibility?It is too early to claim that there are any Python packages that GraalVM iscompatible with.Python Command OptionsPython is run using graalpython [option] ... (-c cmd | file) [arg] ...and supports some of the same options as the standard Python interpreter:  -c cmd: program passed in as string (terminates option list)  -h: print this help message and exit (also --help)  -i: inspect interactively after running script; forces a prompt even ifstdin does not appear to be a terminal; also PYTHONINSPECT=x  -V: Print the Python version number and exit (also --version)  file: Program read from script file  arg ...: Arguments passed to program in sys.argv[1:]Here are some GraalVM-specific options:  --python.PythonInspectFlag: This is equivalent to Python’s -i option(see above).  -CC: Run clang and then opt with the arguments required to build aGraalVM and Sulong compatible LLVM bitcode file.  -LD: Run llvm-link with the appropriate options to bind multiple LLVMbitcode files into one that can be used on GraalVM with Sulong.The following options are mostly useful for developers of the language or toprovide bug reports:  --python.CoreHome=&amp;lt;String&amp;gt;: The path to the core library of Pythonthat is written in Python. This usually resides in a folderlib-graalpython in the GraalVM distribution.  --python.StdLibHome=&amp;lt;String&amp;gt;: The path to the standard library thatPython will use. Usually this is in a under lib-python/3 in theGraalVM distribution, but any Python 3.7 standard library location may work.  --python.WithJavaStacktrace: Prints a Java-level stack trace besides thenormal Python stack when errors occur.  --python.LazyInit: Load the core library after the Python context hasbeen initialized. This only affects certain tools such as the Chromedebugger and lets these tools also see the code in the Python core library.  --python.SharedCore: This option is not fully implemented, yet. It willallow sharing parts of the core library across multiple Python contexts,which will improve startup time of subsequent contexts.There are a few other debugging options used by the developers of GraalVM,but these change frequently and may not do anything at any given point in time,so any observed effects of them should not be relied upon.",
                    "url": " /docs/reference-manual/languages/python/"
                  },
                  
                  "docs-reference-manual-polyglot":  {
                    "title": "Reference for Polyglot Applications",
                    "content": "IntroductionGraalVM allows you to write polyglot applications with a seamless way to pass values from one language to another.With GraalVM there is no copying or marshalling necessary as it is with other polyglot systems.This lets you achieve high performance when language boundaries are crossed.Most of the time there is no additional cost for crossing a language boundary at all.Often developers have to make uncomfortable compromises that require them to rewrite their software in other languages. For example:  “That library is not available in my language. I need to rewrite it.”  “That language would be the perfect fit for my problem, but we cannot run it in our environment.”  “That problem is already solved in my language, but the language is too slow.”With GraalVM we aim to allow developers to freely choose the right language for the task at hand without making compromises.Throughout this section you learn how to combine multiple languages using our polyglot APIs.Running Polyglot ApplicationsThe following examples are designed to get you started with a basic polyglot application.Select a section for your Start Language and then select a tab for the Target Language.Ensure you set up GraalVM and export the GraalVM home directory as the $GRAALVM_HOME before you begin. See Get Started.Note that these examples work in all scenarios:  On JVM, by passing --polyglot --jvm.  On native launchers with --polyglot (e.g., js --polyglot).Note that it might be required to rebuild images to access languages installed with gu.  With native image executables (e.g., native-image --language:js).For native launchers and native image executables using Java as the Target Languageand accessing other classes than Java arrays, it is required to recompile the image and providea reflection configuration file.Requirement: to start an application with LLVM as a Target Language, make sure to precompile polyglot.c file provided below.Start from JavaScript / Node.jsCreate a file polyglot.js:                                  // BEGIN-SNIPPETvar array = Polyglot.eval(&quot;R&quot;, &quot;c(1,2,42,4)&quot;)console.log(array[2]);// END-SNIPPET                                            // BEGIN-SNIPPETvar array = Polyglot.eval(&quot;ruby&quot;, &quot;[1,2,42,4]&quot;)console.log(array[2]);// END-SNIPPET                                            // BEGIN-SNIPPETvar array = Polyglot.eval(&quot;python&quot;, &quot;[1,2,42,4]&quot;)console.log(array[2]);// END-SNIPPET                                            // BEGIN-SNIPPETvar array = new (Java.type(&quot;int[]&quot;))(4);array[2] = 42;console.log(array[2])// END-SNIPPET                                            // BEGIN-SNIPPETvar cpart = Polyglot.evalFile(&quot;llvm&quot;, &quot;polyglot.bc&quot;);cpart.main()// END-SNIPPET              R      Ruby      Python      Java      LLVM            Target Language      Run:$ js --polyglot --jvm polyglot.js42$ node --polyglot --jvm polyglot.js42Start Language RCreate a file polyglot.R:                                   # BEGIN-SNIPPETarray &amp;lt;- eval.polyglot(&quot;js&quot;, &quot;[1,2,42,4]&quot;)print(array[3L])# END-SNIPPET                                               # BEGIN-SNIPPETarray &amp;lt;- eval.polyglot(&quot;ruby&quot;, &quot;[1,2,42,4]&quot;)print(array[3L])# END-SNIPPET                                               # BEGIN-SNIPPETarray &amp;lt;- eval.polyglot(&quot;python&quot;, &quot;[1,2,42,4]&quot;)print(array[3L])# END-SNIPPET                                               # BEGIN-SNIPPETarray &amp;lt;- new(&quot;int[]&quot;, 4)array[3L] &amp;lt;- 42print(array[3L])# END-SNIPPET                                               # BEGIN-SNIPPETcpart &amp;lt;- eval.polyglot(&quot;llvm&quot;, path=&quot;polyglot.bc&quot;)cpart$main()# END-SNIPPET                JS      Ruby      Python      Java      LLVM            Target Language      Run:$ Rscript --polyglot --jvm polyglot.R[1] 42Start Language Ruby:Create a file polyglot.rb:                                  # BEGIN-SNIPPETarray = Polyglot.eval(&#39;js&#39;, &#39;[1,2,42,4]&#39;)puts array[2]# END-SNIPPET                                              # BEGIN-SNIPPETarray = Polyglot.eval(&#39;R&#39;, &#39;c(1L,2L,42L,4L)&#39;)puts array[2]# END-SNIPPET                                              # BEGIN-SNIPPETarray = Polyglot.eval(&#39;python&#39;, &#39;[1,2,42,4]&#39;)puts array[2]# END-SNIPPET                                              # BEGIN-SNIPPETarray = Java.type(&#39;int[]&#39;).new(4)array[2] = 42print(array[2])# END-SNIPPET                                              # BEGIN-SNIPPETcpart = Polyglot.eval_file(&#39;llvm&#39;, &#39;polyglot.bc&#39;)cpart.main()# END-SNIPPET                JS      R      Python      Java      LLVM            Target Language      Run:$ ruby --polyglot --jvm polyglot.rb42Start Language Python:Create a file polyglot.py:                                  # BEGIN-SNIPPETimport polyglotarray = polyglot.eval(language=&quot;js&quot;, string=&quot;[1,2,42,4]&quot;)print(array[2])# END-SNIPPET                                            # BEGIN-SNIPPETimport polyglotarray = polyglot.eval(language=&quot;R&quot;, string=&quot;c(1L,2L,42L,4L)&quot;)print(array[2])# END-SNIPPET                                            # BEGIN-SNIPPETimport polyglotarray = polyglot.eval(language=&quot;ruby&quot;, string=&quot;[1,2,42,4]&quot;)print(array[2])# END-SNIPPET                                            # BEGIN-SNIPPETimport javaarray = java.type(&quot;int[]&quot;)(4)array[2] = 42print(array[2])# END-SNIPPET                                            # BEGIN-SNIPPETimport polyglotcpart = polyglot.eval(language=&quot;llvm&quot;, path=&quot;polyglot.bc&quot;)cpart.main()# END-SNIPPET              JS      R      Ruby      Java      LLVM            Target Language      Run:$ graalpython --polyglot --jvm polyglot.py42Start Language Java:Create a file Polyglot.java:                                  // BEGIN-SNIPPETimport org.graalvm.polyglot.*;class Polyglot {    public static void main(String[] args) {        Context polyglot = Context.create();        Value array = polyglot.eval(&quot;js&quot;, &quot;[1,2,42,4]&quot;);        int result = array.getArrayElement(2).asInt();        System.out.println(result);    }}// END-SNIPPET                                            // BEGIN-SNIPPETimport org.graalvm.polyglot.*;class Polyglot {    public static void main(String[] args) {        Context polyglot = Context.newBuilder().                       allowAllAccess(true).build();        Value array = polyglot.eval(&quot;R&quot;, &quot;c(1,2,42,4)&quot;);        int result = array.getArrayElement(2).asInt();        System.out.println(result);    }}// END-SNIPPET                                            // BEGIN-SNIPPETimport org.graalvm.polyglot.*;class Polyglot {    public static void main(String[] args) {        Context polyglot = Context.newBuilder().                       allowAllAccess(true).build();        Value array = polyglot.eval(&quot;ruby&quot;, &quot;[1,2,42,4]&quot;);        int result = array.getArrayElement(2).asInt();        System.out.println(result);    }}// END-SNIPPET                                            // BEGIN-SNIPPETimport org.graalvm.polyglot.*;class Polyglot {    public static void main(String[] args) {        Context context = Context.newBuilder().allowIO(true).build();        Value array = context.eval(&quot;python&quot;, &quot;[1,2,42,4]&quot;);        int result = array.getArrayElement(2).asInt();        System.out.println(result);    }}// END-SNIPPET                                            // BEGIN-SNIPPETimport java.io.*;import org.graalvm.polyglot.*;class Polyglot {    public static void main(String[] args) throws IOException {        Context polyglot = Context.newBuilder().                       allowAllAccess(true).build();        File file = new File(&quot;polyglot.bc&quot;);        Source source = Source.newBuilder(&quot;llvm&quot;, file).build();        Value cpart = polyglot.eval(source);        cpart.getMember(&quot;main&quot;).execute();    }}// END-SNIPPET              JS      R      Ruby      Python      LLVM            Target Language      Run:$ javac Polyglot.java$ java Polyglot42Start Language C:Note: This requires clang to be installed.Create a file polyglot.c:                                   // BEGIN-SNIPPET#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;polyglot.h&amp;gt;int main() {    void *array = polyglot_eval(&quot;js&quot;, &quot;[1,2,42,4]&quot;);    int element = polyglot_as_i32(polyglot_get_array_element(array, 2));    printf(&quot;%dn&quot;, element);    return element;}// END-SNIPPET                                             // BEGIN-SNIPPET#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;polyglot.h&amp;gt;int main() {    void *array = polyglot_eval(&quot;R&quot;, &quot;c(1,2,42,4)&quot;);    int element = polyglot_as_i32(polyglot_get_array_element(array, 2));    printf(&quot;%dn&quot;, element);    return element;}// END-SNIPPET                                             // BEGIN-SNIPPET#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;polyglot.h&amp;gt;int main() {    void *array = polyglot_eval(&quot;ruby&quot;, &quot;[1,2,42,4]&quot;);    int element = polyglot_as_i32(polyglot_get_array_element(array, 2));    printf(&quot;%dn&quot;, element);    return element;}// END-SNIPPET                                             // BEGIN-SNIPPET#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;polyglot.h&amp;gt;int main() {    void *array = polyglot_eval(&quot;python&quot;, &quot;[1,2,42,4]&quot;);    int element = polyglot_as_i32(polyglot_get_array_element(array, 2));    printf(&quot;%dn&quot;, element);    return element;}// END-SNIPPET                                             // BEGIN-SNIPPET#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;polyglot.h&amp;gt;int main() {    void *arrayType = polyglot_java_type(&quot;int[]&quot;);    void *array = polyglot_new_instance(arrayType, 4);    polyglot_set_array_element(array, 2, 42);    int element = polyglot_as_i32(polyglot_get_array_element(array, 2));    printf(&quot;%dn&quot;, element);    return element;}// END-SNIPPET              JS      R      Ruby      Python      Java            Target Language      Run:$ clang -g -O1 -c -emit-llvm -I$GRAALVM_HOME/jre/languages/llvm/include polyglot.c$ lli --polyglot --jvm polyglot.bc42How Does Polyglot WorkIn order to provide foreign polyglot values in the languages implemented with theTruffle Language Implementation Framework,we have developed the so-called polyglot interoperability protocol. Thisinteroperability protocol consists of a set of standardized messages that everylanguage implements and uses for foreign polyglot values. The protocol allowsGraalVM to support interoperability between any combination of languages withoutrequiring them to know of each other. We plan to gradually improve the protocolto support more and more features over time.For further details, we recommend reading:  Matthias Grimmer, Chris Seaton, Roland Schatz, Würthinger, Hanspeter MössenböckHigh-Performance Cross-Language Interoperability in a Multi-Language RuntimeIn Proceedings of the 11th Dynamic Language Symposium (DLS).Running Polyglot ApplicationsWith polyglot applications it is often impossible to decide what the primarylanguage of an application is. Therefore, we have added an experimental newlauncher called polyglot to GraalVM. For the moment, this launcher runs codefor JavaScript, Ruby, and R without requiring the selection of a primarylanguage. The polyglot launcher does not require the --polyglot option, it isenabled by default.This is how you can run a polyglot application by using the examples from above:$ polyglot --jvm polyglot.js polyglot.R polyglot.rbWe have also included a basic experimental shell for multiple languages calledthe Polyglot Shell. It is useful to quickly test to test the interactivity oflanguages implemented with the Truffle Language Implementation framework.This is how you can start it:$ polyglot --jvm --shellGraalVM MultiLanguage Shell 19.2.0Copyright (c) 2013-2019, Oracle and/or its affiliates  JavaScript version 19.2.0  Python version 3.7.3  R version 3.5.1  Ruby version 2.6.2Usage:  Use Ctrl+L to switch language and Ctrl+D to exit.  Enter -usage to get a list of available commands.js&amp;gt;Warning: The polyglot launcher and the Polyglot Shell are experimental. Experimentalfeatures might never be included in a production version, or might changesignificantly before being considered production-ready.Polyglot OptionsYou can configure language engine for better throughput or startup.  --engine.Mode=default: Configures the execution mode of the engine. The execution mode automatically tunes the polyglot engine towards latency or throughput.          throughput: To collect the maximum amount of profiling information and compile using the  maximum number of optimizations. This mode results in slower application startup  but better throughput. This mode uses the compiler configuration community or   enterprise if not specified otherwise.      default: To use a balanced engine configuration. This mode uses the compiler configuration community or enterprise if not specified otherwise.      latency: To collect only minimal profiling information and compile as fast as possible  with less optimal generated code. This mode results in faster application  startup but less optimal throughput. This mode uses the compiler configuration  economy if not specified otherwise.      Polyglot Options for Language LaunchersWe have extended every language launcher with a set of so called polyglotoptions. Polyglot options allow users of any language launcher to access theoptions of other languages supported by GraalVM (implemented with the TruffleLanguage Implementation Framework).The format is: --&amp;lt;languageID&amp;gt;.&amp;lt;property&amp;gt;=&amp;lt;value&amp;gt;.For example the R launcher also supports the --js.atomics=true JavaScript option.Allowed values for the languageID are:  js options for JavaScript.  python options for Python.  r options for R.  ruby options for Ruby.  llvm options for LLVM.Use --help:languages to find out which options are available.Options for polyglot tools work in the same way with the following format: --&amp;lt;toolID&amp;gt;.&amp;lt;property&amp;gt;=&amp;lt;value&amp;gt;.Allowed values for &amp;lt;toolID&amp;gt; are:  inspect allows debugging with Chrome DevTools.  cpusampler collects data about CPU usage.  cputracer captures trace information about CPU usage.  memtracer captures trace information about memory usage.Use --help:tools to find out which options are available.Passing Options ProgrammaticallyOptions can also be passed programmatically using the Java polyglot API.Create a file called OptionsTest.java:import org.graalvm.polyglot.*;class OptionsTest {    public static void main(String[] args) {        Context polyglot = Context.newBuilder().allowExperimentalOptions(true)            .option(&quot;js.shared-array-buffer&quot;, &quot;true&quot;)            .build();        // the use of shared array buffer requires        // the &#39;js.shared-array-buffer&#39; option to be &#39;true&#39;        polyglot.eval(&quot;js&quot;, &quot;new SharedArrayBuffer(1024)&quot;);    }}Run:$ javac OptionsTest.java$ java OptionsTestPlease note that tool options can be passed in the same way.Options cannot be modified after the context was created.Passing Options using JVM ArgumentsEvery polyglot option can also be passed as a Java system property.Each available option translates to a system property with the polyglot. prefix.For example: -Dpolyglot.js.strict=true sets the default value for a strict interpretation for all JavaScript code that runs in the JVM.Options that were set programmatically take precedence over Java system properties.For languages the following format can be used: -Dpolyglot.&amp;lt;languageID&amp;gt;.&amp;lt;property&amp;gt;=&amp;lt;value&amp;gt; and for tools it is: -Dpolyglot.&amp;lt;toolID&amp;gt;.&amp;lt;property&amp;gt;=&amp;lt;value&amp;gt;.Create a file called SystemPropertiesTest.java:import org.graalvm.polyglot.*;class SystemPropertiesTest {    public static void main(String[] args) {        Context polyglot = Context.newBuilder().allowExperimentalOptions(true).build();        // the use of shared array buffer requires        // the &#39;js.shared-array-buffer&#39; option to be &#39;true&#39;        polyglot.eval(&quot;js&quot;, &quot;new SharedArrayBuffer(1024)&quot;);    }}Run:$ javac SystemPropertiesTest.java$ java -Dpolyglot.js.strict=true SystemPropertiesTestNote: System properties are read once when the polyglot context is created. Subsequent changes have no effect.",
                    "url": " /docs/reference-manual/polyglot/"
                  },
                  
                  "docs":  {
                    "title": "GraalVM Documentation",
                    "content": "A short introduction to GraalVMGraalVM is an ecosystem and shared runtime offering performance advantagesnot only to JVM-based languages such as Java, Scala, Groovy, andKotlin, but also to other programming languages such as JavaScript, Ruby, Python, and R.Additionally, it enables the execution of native code on the JVM via an LLVM front-end.GraalVM 19.2.0 is based on JDK version 8u222.The preceding diagram illustrates the architecture of GraalVM as an open ecosystem.The virtualization layer represents programming languages, provided by GraalVM.The execution of guest programming languages, namely JavaScript, Ruby, R, Pythonand LLVM bitcode, in the same runtime as the host JVM-based application is now down-to-earth.The host language and guest languages can directly interoperate with each otherand pass data back and forth in the same memory space.The bottom part demonstrates the applicability range. GraalVM can either run standalone,be embedded as part of the OpenJDK or Node.js platforms,or even execute inside Oracle Database.Distribution Components ListGraalVM consists of core and optional components, and is distributed as anarchive. That archive enables using GraalVM as a runtime platform forhigh-performance embeddable polyglot applications and includes the following:  Runtimes          Java HotSpot VM runtime with the GraalVM compiler enabled as the top tier JIT compiler for JVM-basedlanguages and supported guest programming languages.      Node.js runtime with the GraalVM JavaScript interpreter enabled as the JavaScript engine.        Libraries (jar files)          GraalVM Compiler – a dynamic just-in-time (JIT) compiler that improves efficiency andspeed of applications through unique approaches to code analysis andoptimization.      JavaScript interpreter – an ECMAScript compliant JavaScript engine.      LLVM bitcode interpreter – an implementation of the lli tool to directly execute programs from LLVM bitcode.      GraalVM Polyglot API – the APIs for combining programminglanguages in a shared runtime. These APIs allow you to match programminglanguages to your needs and gives you better performance using fewer resources.        Utilities          JavaScript REPL with the GraalVM JavaScript interpreter      LLVM bitcode interpreter command line utility      GraalVM Updater utility to install and manage additional components      GraalVM base installation can be extended with the optional components:  GraalVM Native Image functionality which allows scripted applications to be compiled ahead-of-time into a native machine-code binary. Warning: GraalVM Native Image is available as an Early Adopter technology, meaning it can be used in production and will be supported by Oracle as part of the Oracle GraalVM Enterprise Edition subscription, but is not covered by Oracle’s standard warranty.  Python interpreter –  a Python 3.7 compliant implementation.  Ruby interpreter – the Ruby engine based on the standard implementation of Ruby, MRI, version 2.6.2.  R interpreter – a GNU R 3.5.1 compatible implementation of the R programming language.Warning: The support for Ruby, R and Python languages is experimental. Experimental features might never be included in a production version, or might change significantly before being considered production-ready.GraalVM FeaturesGraalVM lets you:  Run your code faster and more efficiently  Interoperate directly with most modern programming languages  Embed languages with the GraalVM SDK  Create compiled native images  Use a single set of tools to monitor, debug, and profile all your codeGraalVM DocumentationWhether you are here to try running an application with GraalVM for the firsttime or ready to start coding with the GraalVM Polyglot APIs, check out ourdocumentation to help you on your way.  Get Started  Examples  Compatibility  Reference Manual  GraalVM as a Platform  FAQAlternatively you can have a look at the reference documentation in GraalVM SDK Javadoc:  The Polyglot Package allows you to configure and run polyglot applications.  The Proxy Package allows you to mimic the guest language objects using proxies.  The IO Package allows you to customize the file system access of languages.If you cannot find the answer you need or have a troubleshooting query,get in touch with us.",
                    "url": " /docs/"
                  },
                  
                  "":  {
                    "title": "",
                    "content": "",
                    "url": " /"
                  },
                  
                  "docs-examples-java-kotlin-aot":  {
                    "title": "Java/Kotlin Native Image Examples",
                    "content": "GraalVM demos: AOT compilation of an application using Java and KotlinThis is an example of a GraalVM demo application that shows ahead-of-timecompilation of Java and Kotlin code.Prerequisites  Maven  GraalVM  GraalVM Native ImagePreparation  Download or clone the repository and navigate into the java-kotlin-aot directory:    git clone https://github.com/graalvm/graalvm-demoscd graalvm-demos/java-kotlin-aot    This is a simple Java / Kotlin application showing how easy it is to interopbetween JVM-based languages. A Java method accesses a String from Kotlin andcalls a Kotlin function, which later accesses a String from a Java class. Beforerunning this example, you need to build the application. Note that you can useany JDK for building the application, however we refer to javac from GraalVMin the build script to simplify the prerequisites and not to depend on anotherJDK installed.    Having downloaded and unzipped GraalVM CE or EE archive, export the GraalVM home directory as the $GRAALVM_HOME and add $GRAALVM_HOME/binto the path, using a command-line shell for Linux:    export GRAALVM_HOME=/home/${current_user}/path/to/graalvm    and for macOS:    export GRAALVM_HOME=/Users/${current_user}/path/to/graalvm/Contents/Home    Note that your paths are likely to be different depending on the download location.        Make sure the native-image utility is available. Starting from GraalVM 19.0, Native Image was extracted from the base distribution. This functionality can be added to the core installation with GraalVM Updater tool by running:gu install native-image.    Then execute:    ./build.sh  Have a look at the build.sh script which creates a native image from the Java class.The native-image utility compile the application ahead-of-time for faster startup and lower general overhead at runtime.$GRAALVM_HOME/bin/native-image -cp ./target/mixed-code-hello-world-1.0-SNAPSHOT.jar -H:Name=helloworld -H:Class=hello.JavaHello -H:+ReportUnsupportedElementsAtRuntime --allow-incomplete-classpathIt takes a couple of parameters, the classpath, the main class of the application with-H:Class=... and the name of the resulting executable with -H:Name=....After executing the native-image command, check the directory, it should haveproduced an executable file helloworld.Running the applicationTo run the application, you need to execute the fat jar file in the target dir.You can run it as a normal Java application using java.Or, since we have a native image prepared, you can run that directly.The run.sh file executes both, and times them with the time utility.java -cp ./target/mixed-code-hello-world-1.0-SNAPSHOT-jar-with-dependencies.jar hello.JavaHello./helloworldApproximately, the following output should be produced:→ ./run.sh+ java -cp ./target/mixed-code-hello-world-1.0-SNAPSHOT-jar-with-dependencies.jar hello.JavaHelloHello from Kotlin!Hello from Java!real0m0.129suser0m0.094ssys0m0.034s+ ./helloworldHello from Kotlin!Hello from Java!real0m0.010suser0m0.003ssys0m0.004sThe performance gain of the native version is largely due to the faster startup.LicenseThe sample application in this directory is taken from the JetBrains Kotlin-examples repository.It is distributed under the Apache License 2.0.",
                    "url": " /docs/examples/java-kotlin-aot/"
                  },
                  
                  "docs-examples-java-performance-examples":  {
                    "title": "Java Performance Examples",
                    "content": "GraalVM demos: Performance Examples for JavaThe GraalVM compiler achieves excellent performance for modern workloadssuch as Scala or usage of the Java Streams API. The examples belowdemonstrate this.Prerequisites  GraalVMRunning the examplesLet us use a simple example based on the Streams APIto demonstrate performance of the GraalVM compiler. This example counts the number of uppercase characters in a body of text. To simulate a large load, the same sentence is processed 10 million times:1. Save the following code snippet to a file named CountUppercase.java:                          // COMPILE-CMD: javac {file}// RUN-CMD: java -Diterations=2 {file} In 2017 I would like to run ALL languages in one VM.// RUN-CMD: java -Diterations=2 -XX:-UseJVMCICompiler {file} In 2017 I would like to run ALL languages in one VM.// BEGIN-SNIPPETpublic class CountUppercase {    static final int ITERATIONS = Math.max(Integer.getInteger(&quot;iterations&quot;, 1), 1);    public static void main(String[] args) {        String sentence = String.join(&quot; &quot;, args);        for (int iter = 0; iter &amp;lt; ITERATIONS; iter++) {            if (ITERATIONS != 1) System.out.println(&quot;-- iteration &quot; + (iter + 1) + &quot; --&quot;);            long total = 0, start = System.currentTimeMillis(), last = start;            for (int i = 1; i &amp;lt; 10_000_000; i++) {                total += sentence.chars().filter(Character::isUpperCase).count();                if (i % 1_000_000 == 0) {                    long now = System.currentTimeMillis();                    System.out.printf(&quot;%d (%d ms)%n&quot;, i / 1_000_000, now - last);                    last = now;                }            }            System.out.printf(&quot;total: %d (%d ms)%n&quot;, total, System.currentTimeMillis() - start);        }    }}// END-SNIPPET      2. Compile it and run as follows:$ javac CountUppercase.java$ java CountUppercase In 2019 I would like to run ALL languages in one VM.1 (389 ms)2 (235 ms)3 (216 ms)4 (77 ms)5 (81 ms)6 (79 ms)7 (85 ms)8 (80 ms)9 (78 ms)total: 69999993 (1408 ms)The warmup time depends on numerous factors like the source code or howmany cores a machine has. If the performance profile of CountUppercase on yourmachine does not match the above, run it for more iterations by adding-Diterations=N just after java for some N greater than 1.3. Add the -Dgraal.PrintCompilation=true option to see statistics for the compilations:$ java -Dgraal.PrintCompilation=true CountUppercase In 2019 I would like to run ALL languages in one VM.This option prints a line after each compilation that shows the methodcompiled, time taken, bytecodes processed (including inlined methods), sizeof machine code produced, and amount of memory allocated during compilation.4. Use the -XX:-UseJVMCICompiler option to disable the GraalVM compiler anduse the native top tier compiler in the VM to compare performance, as follows:$ java -XX:-UseJVMCICompiler CountUppercase In 2019 I would like to run ALL languages in one VM.1 (602 ms)2 (443 ms)3 (429 ms)4 (423 ms)5 (418 ms)6 (432 ms)7 (454 ms)8 (415 ms)9 (407 ms)total: 69999993 (4443 ms)The preceding example demonstrates the benefits of partial escape analysis (PEA)and advanced inlining, which combine to significantly reduce heap allocation.The results were obtained using GraalVM Enterprise Edition.The GraalVM Community Edition still has good performance compared to the native top tiercompiler as shown below. You can simulate the Community Edition on the Enterprise Editionby adding the option -Dgraal.CompilerConfiguration=community.Sunflow is an open source rendering engine.The following example is a simplified version of code at the core of theSunflow engine. It performs calculations to blend various values for a point oflight in a rendered scene.1. Save the following code snippet to a file named Blender.java:                          // COMPILE-CMD: javac {file}// RUN-CMD: java {file}// RUN-CMD: java -XX:-UseJVMCICompiler {file}// BEGIN-SNIPPETpublic class Blender {    private static class Color {        double r, g, b;        private Color(double r, double g, double b) {            this.r = r;            this.g = g;            this.b = b;        }        public static Color black() {            return new Color(0, 0, 0);        }        public void add(Color other) {            r += other.r;            g += other.g;            b += other.b;        }        public void add(double nr, double ng, double nb) {            r += nr;            g += ng;            b += nb;        }        public void multiply(double factor) {            r *= factor;            g *= factor;            b *= factor;        }    }    private static final Color[][][] colors = new Color[100][100][100];    public static void main(String[] args) {        for (int j = 0; j &amp;lt; 10; j++) {            long t = System.nanoTime();            for (int i = 0; i &amp;lt; 100; i++) {                initialize(new Color(j / 20, 0, 1));            }            long d = System.nanoTime() - t;            System.out.println(d / 1_000_000 + &quot; ms&quot;);        }    }    private static void initialize(Color id) {        for (int x = 0; x &amp;lt; colors.length; x++) {            Color[][] plane = colors[x];            for (int y = 0; y &amp;lt; plane.length; y++) {                Color[] row = plane[y];                for (int z = 0; z &amp;lt; row.length; z++) {                    Color color = new Color(x, y, z);                    color.add(id);                    if ((color.r + color.g + color.b) % 42 == 0) {                         // PEA only allocates a color object here.                         row[z] = color;                    } else {                         // In this branch the color object is not allocated at all.                    }                }            }        }    }}// END-SNIPPET      2. Compile it and run as follows:$ javac Blender.java$ java Blender2477 ms910 ms857 ms815 ms813 ms821 ms819 ms832 ms819 ms839 msIf you would like to check how it would behave when using the GraalVM CE, use the following configuration flag:java -Dgraal.CompilerConfiguration=community Blender1127 ms902 ms888 ms858 ms820 ms860 ms855 ms864 ms899 ms899 ms3.  again, use the -XX:-UseJVMCICompiler option to disable the GraalVM compiler and run with the normal HotSpot’s jit:$ java -XX:-UseJVMCICompiler Blender2214 ms1666 ms1667 ms1438 ms1436 ms1458 ms1452 ms1528 ms1557 ms1474 msThe improvement compared to not using the GraalVM compiler  comes from the partial escape analysis moving the allocation of colorin initialize down to the point where it is stored into colors (i.e., thepoint at which it escapes).",
                    "url": " /docs/examples/java-performance-examples/"
                  },
                  
                  "docs-examples-java-simple-stream-benchmark":  {
                    "title": "Java Stream API Example",
                    "content": "GraalVM demos: Simple Java stream benchmarkThis application is a small benchmark of the Java stream API.Prerequisites  Maven  GraalVMPreparationDownload or clone the repository and navigate into the java-simple-stream-benchmark directory:git clone https://github.com/graalvm/graalvm-demoscd graalvm-demos/java-simple-stream-benchmarkBuild the benchmark. You can manually execute mvn package, but there is alsoa build.sh script included for your convenience../build.shNow you are all set to execute the benchmark and compare the results between different JVMs.Export the GraalVM home directory as the $GRAALVM_HOME and add $GRAALVM_HOME/binto the path, using a command-line shell for Linux:export GRAALVM_HOME=/path/to/graalvmand for macOS:export GRAALVM_HOME=/path/to/graalvm/Contents/HomeRunning the benchmarkTo run the benchmark, you need to execute the target/benchmarks.jar file.You can run it with the following command:$GRAALVM_HOME/bin/java -jar target/benchmarks.jarIf you would like to run the benchmark on a different JVM, you can run it withwhatever java you have. However, if you just want to run it on the same JVM,but without the GraalVM compiler, you may add the -XX:-UseJVMCICompiler optioninto the same command.$GRAALVM_HOME/bin/java -XX:-UseJVMCICompiler -jar target/benchmarks.jarThis way, the GraalVM compiler will not be used as the JVMCI compiler and the JVM will use its default one.A note about the resultsThe benchmark mode is AverageTime in nanoseconds per operation,which means lower numbers are better.Note that the results you see can be influenced by the hardware you are runningthis benchmark on, the CPU load, and other factors. Interpret them responsibly.",
                    "url": " /docs/examples/java-simple-stream-benchmark/"
                  },
                  
                  "docs-release-notes-known-issues":  {
                    "title": "Known Issues",
                    "content": "Known Issues  The GraalVM CE image for macOS currently depends on some libraries that are not installed by default on current macOS versions.This might cause issues with UI-related functionality:    Library not loaded: /usr/X11/lib/libfreetype.6.dylib    The necessary components can be added, e.g., by installing https://www.xquartz.org.We will remove this dependency in upcoming versions of GraalVM CE for macOS.    Due do the issue with the underlying platform Java Mission control freezes at startup on macOS. Because of that we removed the jmc utility from the distribution. For more information and workarounds please see the JMC known issues page.",
                    "url": " /docs/release-notes/known-issues/"
                  },
                  
                  "logo":  {
                    "title": "GraalVM Logo",
                    "content": "The purpose of this page is to provide GraalVM community with quality images andusage guidance for events, social media, online content, and other possible usecases. All open source logos stewarded by Oracle should follow the samesystematic branding principles.GraalVM LogoWe welcome and encourage GraalVM users to download and use our official logo files, available in PNG, EPS or SVG formats.Use the logo you need as displayed on the website. You may scale itto fit your placement, but please avoid changing colors, design, or altering thegraphics in any way. While placing the logo on dark backgrounds, please use theversion with white background.Color SchemeThe official color palette for open source community logo is comprised ofOSC Blue and OSC Orange.TypefaceIf you want to follow GraalVM logo typeface in your slides or banner design, thetypeface you are looking for is Sun Sans SemiBold.If you have some questions or requests regarding GraalVM branding, please reachus via this email.",
                    "url": " /logo/"
                  },
                  
                  "docs-examples-mle-oracle":  {
                    "title": "Oracle Database Example",
                    "content": "GraalVM demos: Oracle Database Multilingual Engine (MLE) based on JavaScript moduleThis repository contains the instructions how to run the Oracle Database Multilingual Engine (MLE),based on JavaScript module, with functions stored as procedures in the database.Prerequisites  DockerPreparationDownload the docker container of the Oracle database with an experimentalsupport for the Multi Language Engine from Oracle Database MLE.Load the docker image:docker load --input mle-docker-0.2.7.tar.gzRun the container (note that you can also configure non-default credentials,but this tutorial does not do that):docker run mle-docker-0.2.7Shell into the docker container:docker exec -ti &amp;lt;container_id&amp;gt; bash -liTo show only running containers and find out a necessary container ID, use the given command:docker psYou have to wait for the database to start. It may take quite a lot of time forthe first run, next runs are faster.To verify the database has started, run the sqlplus from a new command shell:sqlplus scott/tiger@localhost:1521/ORCLCDBNote: scott/tiger are the default login/password.ORCLCDB is a site identifier (SID). There can be more than one database onthe same Oracle_HOME, that is why SID is required to identify them.If you have changed the default login/password, change the command respectively.If sqlplus works - the database is ready. Exit sqlplus.Create a directory, initialize an empty node package, install the validatormodule from NPM, install the TypeScript types for the validator module.mkdir crazyawesomecd crazyawesomeecho &quot;{}&quot; &amp;gt; package.jsonnpm install validatornpm install @types/validatorDeploy the validator module to the database, in the following commandvalidator is the module name:dbjs deploy -u scott -p tiger -c localhost:1521/ORCLCDB validatorStart sqlplus again:sqlplus scott/tiger@localhost:1521/ORCLCDBUse the validator module functions as the stored procedures. Make sure to put a semicolon after the query:select validator.isEmail(&#39;oleg.selaev@oracle.com&#39;) from dual;select validator.isEmail(&#39;oleg.selaev&#39;) from dual;",
                    "url": " /docs/examples/mle-oracle/"
                  },
                  
                  "docs-examples-native-list-dir":  {
                    "title": "Native Image Example",
                    "content": "GraalVM demos: Native images for faster startupThis is a sample application to demonstrate GraalVM capabilities for creatingnative images.Prerequisites  GraalVM  GraalVM Native ImagePreparation  Download or clone the repository and navigate into the native-list-dir directory:    git clone https://github.com/graalvm/graalvm-demoscd graalvm-demos/native-list-dir    There are two Java classes, but we will start by building ListDir.java for thepurposes of this demo. You can manually execute javac ListDir.java, there isalso a build.sh script included for your convenience. Note that you can useany JDK for compiling the Java classes, however we refer to javac from GraalVMin the build script to simplify the prerequisites and not to depend on anotherJDK installed.    Having downloaded and unzipped GraalVM CE or EE archive, export the GraalVM home directory as the $GRAALVM_HOME and add $GRAALVM_HOME/binto the path, using a command-line shell for Linux:    export GRAALVM_HOME=/home/${current_user}/path/to/graalvm    and for macOS:    export GRAALVM_HOME=/Users/${current_user}/path/to/graalvm/Contents/Home    Note that your paths are likely to be different depending on the download location.        Make sure the native-image utility is available. Starting from GraalVM 19.0, Native Image was extracted from the base distribution. This functionality can be added to the core installation with GraalVM Updater tool by running:gu install native-image.    Then execute:    ./build.sh  The build.sh script creates a native image from the Java class.Let us look at it in more detail:$GRAALVM_HOME/bin/native-image ListDirThe native-image utility ahead-of-time compiles the ListDir class into astandalone binary in the current working directory. After running thecommand, an executable file listdir should have been produced.Running the ApplicationTo run the application, you need to either execute the ListDir class,as a normal Java application using java, or, since we have a native imageprepared, run that directly.The run.sh file, executes both, and times them with the time utility.time java ListDir $1time ./listdir $1To make it more interesting, pass it to a parent directory: ./run.sh .. (.. - isthe parent of the current directory, the one containing all the demos).Approximately, the following output should be produced:+ java ListDir ..Walking path: ..Total: 141 files, total size = 14448801 bytesreal0m0.320suser0m0.379ssys0m0.070s+ ./listDir ..Walking path: ..Total: 141 files, total size = 14448801 bytesreal0m0.030suser0m0.005ssys0m0.011sThe performance gain of the native version is largely due to the faster startup.Polyglot CapabilitiesYou can also experiment with a more sophisticated ExtListDir example,which uses Java/JavaScript polyglot capabilities.To compile that class you need to add graal-sdk.jar on the classpath:$GRAALVM_HOME/bin/javac -cp $GRAALVM_HOME/jre/lib/boot/graal-sdk.jar ExtListDir.javaBuilding the native image command is similar to the one above, but, since we want to use JavaScript, we need to inform the native-image utility about it by passing the --language:js option.Note that it takes a bit more time because it needs to include the JavaScript support.$GRAALVM_HOME/bin/native-image --language:js ExtListDirThe execution is the same as in the previous example:time java ExtListDir $1time ./extlistdir $1Profile-Guided Optimizaitons for High ThroughputGraalVM Enterprise Edition offers extra benefits for building a native image. These are profile-guided optimisations (PGO). As an example we will use a small application demonstrating Java streams.First, we run the application with java to see the output:+ javac Streams.java+ $GRAALVM_HOME/bin/native-image Streams+ ./streams 1000000 200...Iteration 20 finished in 1955 milliseconds with checksum 6e36c560485cdc01To enable PGO we need to build an instrumented image and run it to collect profiles:+ $GRAALVM_HOME/bin/native-image --pgo-instrument Streams+ ./streams 1000 200Profiles collected from this run are now stored in the default.iprof file. Note that we run the profiling with a much smaller data size.Now we can use these profiles to make an optimized image:+ $GRAALVM_HOME/bin/native-image --pgo StreamsWhen we run the PGO image with+ ./streams 1000000 200...Iteration 20 finished in 827 milliseconds with checksum 6e36c560485cdc01we will see more than 2x improvements in performance.",
                    "url": " /docs/examples/native-list-dir/"
                  },
                  
                  "docs-reference-manual-native-heapdump":  {
                    "title": "Generate Heap Dumps from Native Images",
                    "content": "Generating Native Heap DumpsAs described in the Creating Native Images chapter in the GraalVM section, it is possible to create highly performing applications. It is also possible tomonitor the execution and generate Java heap dumps from within the native imageapplication. The functionality is available only with GraalVM Enterprise Edition.GraalVM Native Image does not implement JVMTI agent and it is not possible totrigger heap dump creation using tools like GraalVM Visual VM or jmap. But itis possible to build a native image for your application to handle signals andthen get a heap dump when the application receives the SIGUSR1 signal. Another possibilityis to add a special method to your application which will generate the heap dumpat certain points in the lifetime of your application. E.g., when certainconditions are met while running a native image application, your applicationcode can trigger heap dump creation. We will show both possibilities in thischapter.Handling SIGUSR1 SignalThe following Java example is a simple multi-threaded application which runs for60 seconds. There is enough time to get its PID and send the SIGUSR1 signalwhich will generate a heap dump into the application’s working directory. Savethe following code as SVMHeapDump.java file on your disk:import java.text.DateFormat;import java.util.Date;public class SVMHeapDump extends Thread {    static int i = 0;    static int runs = 60;    static int sleepTime = 1000;    @Override    public void run() {        System.out.println(DateFormat.getDateTimeInstance().format(new Date()) + &quot;: Thread started, it will run for &quot; + runs + &quot; seconds&quot;);        while (i &amp;lt; runs){            System.out.println(&quot;Sleeping for &quot; + (runs-i) + &quot; seconds.&quot; );            try {                Thread.sleep(sleepTime);            } catch (InterruptedException ie){                System.out.println(&quot;Sleep interrupted.&quot;);            }            i++;        }    }    /**     * @param args the command line arguments     */    public static void main(String[] args) throws InterruptedException {        // Do some manipulations so we have something to dump        StringBuffer sb1 = new StringBuffer(100);        sb1.append(DateFormat.getDateTimeInstance().format(new Date()));        sb1.append(&quot;: Hello GraalVM native image developer! nGet PID of this process: &quot;);        sb1.append(&quot;&#39;ps -C svmheapdump -o pid= &#39;n&quot;);        sb1.append(&quot;then send it signal: &quot;);        sb1.append(&quot;&#39;kill -SIGUSR1 &amp;lt;pid_printed_above&amp;gt;&#39; n&quot;);        sb1.append(&quot;to get heap dump generated into working directory.n&quot;);        sb1.append(&quot;Starting thread!&quot;);        System.out.println(sb1);        SVMHeapDump t = new SVMHeapDump();        t.start();        while (t.isAlive()) {            t.join(0);        }        sb1 = new StringBuffer(100);        sb1.append(DateFormat.getDateTimeInstance().format(new Date()));        sb1.append(&quot;: Thread finished after: &quot;);        sb1.append(i);        sb1.append(&quot; iterations.&quot;);        System.out.println(sb1);    }}Building an ExampleCompile SVMHeapDump.java as following$ javac SVMHeapDump.javaIf you run it on java, you will see it runs for 60 seconds then finishes. We will now look how to tell native-image to generate binary which will accept SIGUSR1 signal to produce a heap dump.Building Native ImageWhen using GraalVM Enterprise Edition, downloaded from the Oracle Technology Network, you need to specify -H:+AllowVMInspection option for GraalVM native-image tool. See following example:$ $GRAALVM_HOME/bin/native-image SVMHeapDump -H:+AllowVMInspectionBuild on Server(pid: 31386, port: 26682)   classlist:     172.62 ms       (cap):     865.71 ms       setup:   1,103.32 ms  (typeflow):   2,003.86 ms   (objects):     664.40 ms  (features):      26.82 ms    analysis:   2,779.99 ms    universe:     152.09 ms     (parse):     311.20 ms    (inline):     471.03 ms   (compile):   2,405.97 ms     compile:   3,458.48 ms       image:     540.78 ms       write:     464.04 ms     [total]:   8,714.06 msThe native-image tool analyzes existing SVMHeapDump.class and creates from it an executable file. When the command completes, svmheapdump is created in the current directory.Run the Application and Get Heap Dump1. Run the App$ ./svmheapdumpFeb 22, 2018 2:56:30 PM: Hello GraalVM native image developer!Get PID of this process: &#39;ps -C svmheapdump -o pid= &#39;then send it signal: &#39;kill -SIGUSR1 &amp;lt;pid_printed_above&amp;gt;&#39;to get heap dump generated into working directory.Starting thread!Feb 22, 2018 2:56:30 PM: Thread started, it will run for 60 secondsSleeping for 60 seconds.2. Generate Heap DumpOpen the 2nd terminal to get PID of the running svmheapdump application using a command like ps -C svmheapdump -o pid= for Linux OS and pgrep svmheapdumpfor Mac OS.PID is printed, e.g. 100, which is then used in sending the signal to the running app:kill -SIGUSR1 100Heap dump is available at the working directory while application continues running.Java API ExampleThe following Java example shows how Java heap dump can be generated from withina running application using Compiler.command() after some condition is met.The condition to generate a heap dump is provided as an option on the command line.Save following Java code as SVMHeapDumpAPI.java.The application creates some data to have something to dump, checks the command lineto see if heap dump has to be created and then in method createHeapDump() createsthe actual heap dump performing checks for file existence.import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.text.DateFormat;import java.util.Date;public class SVMHeapDumpAPI {    private static final String HEAP_DUMP_COMMAND = &quot;HeapDump.dumpHeap(FileOutputStream, Boolean)Boolean&quot;;    /**     * @param args the command line arguments     */    public static void main(String[] args) {        // Do some manipulations so we have something to dump        StringBuffer sb1 = new StringBuffer(100);        sb1.append(DateFormat.getDateTimeInstance().format(new Date()));        sb1.append(&quot;: Hello GraalVM native image developer. nYour command line options are: &quot;);        if (args.length &amp;gt; 0) {            sb1.append(args[0]);            System.out.println(sb1);            if (args[0].equalsIgnoreCase(&quot;--heapdump&quot;)){                createHeapDump();            }        } else {                sb1.append(&quot;None&quot;);                System.out.println(sb1);        }     }    /**     * Generate heap dump and save it into temp file.     */    private static void createHeapDump() {        boolean heapDumpCreated = false;        try {            File file = File.createTempFile(&quot;SVMHeapDump-&quot;, &quot;.hprof&quot;);            FileOutputStream fileOutputStream = new FileOutputStream(file);            // Create heap dump            final Object[] args = new Object[]{HEAP_DUMP_COMMAND, fileOutputStream, Boolean.TRUE};            final Object resultObject = Compiler.command(args);            // Following code checks if heap dump was created using return value            if (resultObject instanceof Boolean) {                heapDumpCreated = ((Boolean) resultObject).booleanValue();            }            fileOutputStream.close();            if (heapDumpCreated){                System.out.println(&quot;  Heap dump created &quot; + file.getAbsolutePath() + &quot;, size: &quot; + file.length());            } else {                // Delete the file to not pollute disk with empty files.                System.out.println(&quot;  Heap dump creation failed.&quot;);                file.delete();            }        } catch (IOException ioe) {            System.out.println(&quot;  Caught IOException.&quot;);        }    }}Building an ExampleIn the next step, compile SVMHeapDumpAPI.java. It is good to define an environment variable pointing to your GraalVM installation, e.g. export GRAALVM_HOME=/usr/graalvm.Then compile using following command:$ javac SVMHeapDumpAPI.javaBuild Native ImageHeap dump creation will work after the native image is built from a class file. Use the following command:$ $GRAALVM_HOME/bin/native-image SVMHeapDumpAPI   Build on Server(pid: 31386, port: 26682)*   classlist:     804.50 ms       (cap):   1,645.69 ms       setup:   2,439.03 ms  (typeflow):   3,636.09 ms   (objects):   1,979.26 ms  (features):      57.29 ms    analysis:   5,775.18 ms    universe:     241.79 ms     (parse):     849.48 ms    (inline):   1,042.78 ms   (compile):   7,632.91 ms     compile:   9,971.89 ms       image:   1,441.42 ms       write:     637.83 ms     [total]:  21,388.04 msWhen the command completes, svmheapdumpapi executable is created in the current directory.Run the Application and Check Heap DumpNow you can run your native image application and generate heap dump from itwith the output similar to one below:$ ./svmheapdumpapi --heapdumpOct 3, 2017 10:33:54 AM: Hello GraalVM native image developer.Your command line options are: --heapdump  Heap dump created /tmp/SVMHeapDump-7779460659275234903.hprof, size: 4436516The resulting heap dump can be then opened with Graal VisualVM tool like any other Java heap dump.",
                    "url": " /docs/reference-manual/native_heapdump/"
                  },
                  
                  "community-opensource":  {
                    "title": "GraalVM Open Source",
                    "content": "GraalVM Open SourceGraalVM Community Edition is built from the sources of  3.6 million lines ofcode originated by the GraalVM team and collaborators, and additionally million lines of sources from projects we depend on like Java, Node.js and others.We invite you to explore the current state of the project, contribute, or get intouch in case you have questions or suggestions.ContributorsWe are grateful for contributions to the project, coming from our academic, industrial and individual collaborators.You can contribute to further project development by submitting a PR, reporting an issue, or providing feedback for using GraalVM in your deployment.GraalVM Open Source RepositoriesGraalVM Core Repository includes:  GraalVM compiler is written in Java and supports both dynamic and static compilation;  Truffle is a language implementation framework for creating languages and instrumentations for GraalVM;  Substrate VM is a framework that allows ahead-of-time (AOT) compilation of Java applications under closed-world assumption into executable images or shared objects;  Sulong is an engine for running LLVM bitcode on GraalVM;  other.Related repositories are:  GraalJS — GraalVM implementation of JavaScript (ECMAScript 2019 compatible) and Node.js 10.15.2;  FastR — GraalVM implementation of the 3.5.1 programming language;  GraalPython — GraalVM implementation of the Python 3.7 programming language;  TruffleRuby — GraalVM implementation of the Ruby 2.6.2 programming language;  SimpleLanguage — A simple demonstration language for the GraalVM;  VisualVM — a visual tool integrating command line JDK tools and lightweight profiling capabilities.EcosystemWe also contribute to the ecosystem by joining efforts with other open-source projects. If you see how your project can benefit from using GraalVM, feel free to reach us.      Eclipse Vert.x is a tool-kit for building reactive applications on the JVM. It’s even-driven, non-blocking, and supports languages like Java, JavaScript, Groovy, Ruby, Ceylon, Scala and Kotlin. Use this guide for building a Vert.x native image with GraalVM: how-to.vertx.io/graal-native-image-howto.        Fn Project is an open-source, container-native, polyglot FaaS (Function as a Service) platform. Fn users can employ GraalVM AOT compilation capabilities for serverless Java functions. Learn more: medium.com/fnproject/serverless-functions-some-like-it-aot-ea8b46951335.        Gluon Client Plugin leverages GraalVM, OpenJDK and JavaFX 11+, by compiling into native code the Java Client application and all its required dependencies, so it can directly be executed as a native application on the target platform. Learn more: docs.gluonhq.com/client/.        Helidon is a collection of Java libraries for writing microservices that run on a fast web core powered by Netty. It supports MicroProfile and provides familiar APIs like JAX-RS, CDI and JSON-P/B.  Starting with version 1.0.3, Helidon supports the GraalVM native-image capability. now you can easily compile your Helidon application into a native executable. Learn more about GraalVM support in Helidon: medium.com/oracledevs/helidon-flies-faster-with-graalvm-eea85287d2dc.        Micronaut is a modern, JVM-based, full-stack framework for building modular, easily testable microservice and serverless applications. It offers extensive GraalVM support out of the box. Create your first Micronaut application: guides.micronaut.io/micronaut-creating-first-graal-app/guide/index.html.        Picocli is a Java command line parser with both an annotations API and a programmatic API, featuring usage help with ANSI colors, autocomplete and nested subcommands. Picocli-based applications can be ahead-of-time compiled to GraalVM native images. Learn more: https://picocli.info/picocli-on-graalvm.html.        Quarkus is a Cloud Native, (Linux) Container First framework for writing Java applications. Quarkus tailors your application for GraalVM to offer instant startup and reduce memory consumption. Get started: quarkus.io/get-started/.  ",
                    "url": " /community/opensource/"
                  },
                  
                  "docs-examples-polyglot-javascript-java-r":  {
                    "title": "Polyglot Node.js Example",
                    "content": "GraalVM demos: Polyglot JavaScript, Java, R applicationThis page describes a simple example of a polyglot application you can run with GraalVM.Prerequisites  GraalVMPreparationDownload or clone the repository and navigate into the polyglot-javascript-java-r directory:git clone https://github.com/graalvm/graalvm-demoscd graalvm-demos/polyglot-javascript-java-rBuild the benchmark. You can manually execute npm install, but there’s also a build.sh script included for your convenience.Execute:./build.shNow you are all set to run the polyglot JavaScript, Java, R application.Export the GraalVM home directory as the $GRAALVM_HOME and add $GRAALVM_HOME/binto the path, using a command-line shell for Linux:export GRAALVM_HOME=/home/${current_user}/path/to/graalvmand for macOS:export GRAALVM_HOME=/Users/${current_user}/path/to/graalvm/Contents/HomeNote that your paths are likely to be different depending on the download location.Note that this application contains R code, so you need to install the Rlanguage component to add R support to GraalVM, run the GraalVM Updater commandto do it:gu install RFor more information on using GraalVM Updater please refer to its documentation.Running the applicationTo run the application, you need to execute the server.js file.You can run it with the following command (or run the run.sh script):$GRAALVM_HOME/bin/node --polyglot --jvm server.jsIf you would like to run the benchmark on a different instance of Node,you can run it with whatever node you have. However, presumably, the polyglotcapability will not be supported.Open localhost:3000 and enjoy the output of the polyglot app.Play with the source code and restart the application to see what elseyou can do with the mix of JavaScript, Java, and R.Debugging polyglot applicationsGraalVM also supports debugging of polyglot applications and provides a built-inimplementation of the Chrome DevTools Protocol. Add the --inspect parameter to the command line, open the URL the applicationprints at the startup in the Chrome browser and start debugging, set breakpoints,evaluate expressions of this app in JavaScript and R code alike.A note about the applicationThis sample application for brevity contains large-ish snippets of codeinside the strings. This is not the best approach for structuring polyglot apps,but it is the easiest to show in a single file.",
                    "url": " /docs/examples/polyglot-javascript-java-r/"
                  },
                  
                  "community-assets":  {
                    "title": "Presentation materials",
                    "content": "The GraalVM team regularly presents at various conferences and meetups. We are delighted to learn that you have taken interest in GraalVM and would like to share this interest with your network. Whether you are presenting at a conference, a meetup, or writing an article, you can use the images on this page in your creative work.These images are the intellectual property of the Oracle and cannot be altered without Oracle’s permission. Please use it responsibly. For the proper use guidelines please contact us: graalvm-users@oss.oracle.com.Please attribute them back to this website, so more people could find it. And please make sure to state your affiliation with the GraalVM project, whether you’re a part of the team or just a fan.GraalVM logoGraalVM overviewGraalVM supports many languages and runs in various environments.GraalVM componentsGraalVM functionality is enabled by several layers: it uses JVM as a platform, uses Java level compiler interface, JVMCI to integrate with it, uses the Truffle framework to run languages it has interpreters for, and through the LLVM bitcode interpreter, Sulong, it can run native code.Performance comparison with best competition (2017)The Practical partial evaluation for high-performance dynamic language runtimes paper byThomas Würthinger, Christian Wimmer, Christian Humer, Andreas Wöß, Lukas Stadler, Chris Seaton, Gilles Duboscq, Doug Simon, Matthias Grimmer compared performance of GraalVM against other runtimes. Here is a one-image summary of the findings. For proper interpretation, please read the paper.Sample applicationsYou can find several sample applications to play with and refer to on the examples page.",
                    "url": " /community/assets/"
                  },
                  
                  "community-press":  {
                    "title": "GraalVM in the Press",
                    "content": "In Case You MissedLightbend Launches Open Source Project CloudState to Advance Stateful Workloads on Knative / Kubernetes Serverless Stack(English) (August 27, 2019)Developing Microservices with GraalVM Enterprise Edition + Micronaut on Oracle Cloud(English) (July 29, 2019)Helidon Supports GraalVM for Native Executable Applications(English) (July 19, 2019)Die GraalVM: Javas Sprung in die Gegenwart?(German) (July 12, 2019)React Server Side Rendering with GraalVM for Clojure(English) (July 8, 2019)Venkat Subramaniam: Kotlin And Python Are Fun, But Java Developers Are Semantically Aligned With The Future(English) (July 1, 2019)Small &amp;amp; fast Docker images using GraalVM’s native-image(English) (May 30, 2019)Sharing is Caring! Domain objects in BOTH Scala and R with GraalVM Polyglot bindings(English) (May 1, 2019)Learn how you can reduce Maven build time by compiling javac as a GraalVM native image(English) (Apr 29, 2019)Helidon flies faster with GraalVM(English) (Apr 17, 2019)Mixing NodeJS and OpenJDK(English) (Apr 4, 2019)GraalVM with Groovy and Grape - creating native image of a standalone script(English) (Jan 16, 2019)GraalVM: the holy Graal of polyglot JVM?(English) (Jan 3, 2019)Comparing Kotlin Performance with Graal and C2(English) (Dec 9, 2018)How to make Beautiful Ruby Plots with Galaaz(English) (Nov 26, 2018)Running Reactive Spring Boot on GraalVM in Docker(English) (Nov 1, 2018)Ruby Plotting with Galaaz: An example of tightly coupling Ruby and R in GraalVM(English) (Oct 19, 2018)GraalVM and Groovy - how to start?(English) (Oct 3, 2018)Micronaut 1.0 RC1 and the power of ahead-of-time compilation(English) (Sep 30, 2018)Part 2: Native microservice in GraalVM(English) (Sep 24, 2018)Part 1: Java to native using GraalVM(English) (Sep 20, 2018)The GraalVM frenzy(English) (Sep 6, 2018)Getting to Know Graal, the New Java JIT Compiler(English) (Jul 16, 2018)Serverless Native Java Functions using GraalVM and Fn Project(English) (Jun 24, 2018)Using GraalVM to run Native Java in AWS Lambda with Golang(English) (Jun 11, 2018)Evaluating JavaScript in Java with GraalVM(English) (Jun 8, 2018)Why the Java community should embrace GraalVM(English) (Jun 5, 2018)Eclipse Vert.x goes Native(English) (Jun 4, 2018)Java Web Server in a 20 MB Docker Image(English) (Jun 4, 2018)A 7MB native-image Java app that runs in 30ms and uses only 4MB of RAM!(English) (May 28, 2018)GraalVM: смешались в кучу C и Scala(Russian) (May 18, 2018)Running PlayFramework on GraalVM(English) (May 10, 2018)Native Clojure with GraalVM(English) (Apr 28, 2018)High-Performance Interpreters for JetBrains MPS(English) (Apr 27, 2018)Oracle Releases GraalVM 1.0, a Polyglot Virtual Machine and Platform(English) (Apr 27, 2018)GraalVM: Virtuelle Maschine der besonderen Art(German) (Apr 26, 2018)Oracles GraalVM für “Native Java”?(German) (Apr 25, 2018)オラクル、JavaやJavaScript、Ruby、Pythonなど多言語対応を単一ランタイムで実現する「GraalVM」をオープンソースで公開。Twitterが本番環境で採用(Japanese) (Apr 20, 2018)Meet GraalVM, Oracle’s polyglot virtual machine(English) (Apr 18, 2018)What’s new in Oracle’s GraalVM multilanguage virtual machine(English) (Apr 18, 2018)GraalVM 1.0 Gives Developers a Speedy Polyglot Runtime–And Helps Twitter Save Money(English) (Apr 18, 2018)Oracle announces polyglot virtual machine, GraalVM(English) (Apr 17, 2018)JavaScript, Java, какая теперь разница?(Russian) (Apr 17, 2018)A Typical Truffle Specialization Pitfall(English) (Apr 17, 2018)",
                    "url": " /community/press/"
                  },
                  
                  "community-publications":  {
                    "title": "GraalVM Publications",
                    "content": "PublicationsHere you can find all publications related to GraalVM. If you are doing research related to GraalVM and want us to include your publication, please send us a pull request to add your paper.Selected PapersWe recommend the following papers as a starting point for learning about Graal:Language implementations on GraalVM are based on the Truffle framework.User applications are transformed to an abstract syntax tree, which is then partially evaluated. If you want to learn more about how to build Truffle languages, how partial evaluation works, and how the Truffle framework allows you to guide the GraalVM compiler, we recommend reading:  Thomas Würthinger, Christian Wimmer, Christian Humer, Andreas Wöß, Lukas Stadler, Chris Seaton, Gilles Duboscq, Doug Simon, Matthias GrimmerPractical partial evaluation for high-performance dynamic language runtimesIn Proceedings of the 37th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI 2017)Truffle language implementations abstract the differences between programming languages, which enables efficient cross-language interoperability. We recommend reading:  Matthias Grimmer, Chris Seaton, Roland Schatz, Würthinger, Hanspeter MössenböckHigh-Performance Cross-Language Interoperability in a Multi-Language RuntimeIn Proceedings of the 11th Dynamic Language Symposium (DLS)The GraalVM compiler ensures that the languages on top of the GraalVM run at full speed.The core of the compiler is its intermediate representation. We recommend reading:  Gilles Duboscq, Thomas Würthinger, Lukas Stadler, Christian Wimmer, Doug Simon, Hanspeter MössenböckAn intermediate representation for speculative optimizations in a dynamic compilerIn Proceedings of the 7th ACM workshop on Virtual machines and intermediate languages (VMIL ‘13)Speculative assumptions based on profiling information and deoptimizations allow GraalVM heavily optimize dynamically typed languages like JavaScript and ensure native speed. We recommend reading:  Gilles Duboscq, Thomas Würthinger, Hanspeter MössenböckSpeculation without regret: reducing deoptimization meta-data in the Graal compilerIn Proceedings of the 2014 International Conference on Principles and Practices of Programming on the Java platform: Virtual machines, Languages, and Tools (PPPJ ‘14)A powerful escape analysis with scalar replacement ensures that all interpreter data structures are removed when optimizing a Truffle AST. We recommend reading:  Lukas Stadler, Thomas Würthinger, Hanspeter MössenböckPartial Escape Analysis and Scalar Replacement for JavaIn Proceedings of Annual IEEE/ACM International Symposium on Code Generation and Optimization (CGO ‘14)Full List of Papers2019      Aleksandar Prokopec, Gilles Duboscq, David Leopoldseder, Thomas WuerthingerAn Optimization-Driven Incremental Inline Substitution Algorithm for Just-In-Time CompilersIn Proceedings of the 2019 International Symposium on Code Generation and Optimization (CGO 2019)        Aleksandar Prokopec, Andrea Rosà, David Leopoldseder, Gilles Duboscq, Petr Tůma, Martin Studener, Lubomír Bulej, Yudi Zheng, Alex Villazón, Doug Simon, Thomas Würthinger, Walter BinderRenaissance: benchmarking suite for parallel applications on the JVMIn Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI 2019)  2018      David Leopoldseder, Lukas Stadler, Manuel Rigger, Thomas Würthinger, Hanspeter Mössenböck A Cost Model for a Graph-Based Intermediate-Representation in a Dynamic CompilerIn Proceedings of the 10th ACM SIGPLAN International Workshop on Virtual Machines and Intermediate Languages        Kevin Menard, Chris Seaton, Benoit Daloze Specializing Ropes for RubyIn Proceedings of the 15th International Conference on Managed Languages &amp;amp; Runtimes (ManLang’18)        B. Daloze, A. Tal, S. Marr, H. Mössenböck, E. Petrank Parallelization of Dynamic Languages: Synchronizing Built-in CollectionsIn Proceedings of the Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA 2018)        David Leopoldseder, Roland Schatz, Lukas Stadler, Manuel Rigger, Thomas Wuerthinger, Hanspeter Moessenboeck Fast-Path Loop Unrolling of Non-Counted Loops to Enable Subsequent Compiler OptimizationsIn Proceedings of the 15th International Conference on Managed Languages &amp;amp; Runtimes, Article No. 2 (ManLang’18)        David Leopoldseder, Lukas Stadler, Thomas Würthinger,Josef Eisl, Doug Simon, Hanspeter Mössenböck Dominance-based duplication simulation (DBDS): code duplication to enable compiler optimizationsIn Proceedings of the 2018 International Symposium on Code Generation and Optimization (CGO 2018)        Matthias Grimmer, Roland Schatz, Chris Seaton, Thomas Wuerthinger, Mikel Lujan Cross-Language Interoperability in a Multi-Language RuntimeIn ACM Transactions on Programming Languages and Systems (TOPLAS), Vol. 40, No. 2, 2018        Manuel Rigger, Roland Schatz, Jacob Kreindl, Christian Haeubl, Hanspeter Moessenboeck Sulong, and Thanks for All the FishMoreVMs Workshop on Modern Language Runtimes, Ecosystems, and VMs (MoreVMs 2018)        Michael Van De Vanter, Chris Seaton, Michael Haupt, Christian Humer, Thomas WürthingerFast, Flexible, Polyglot Instrumentation Support for Debuggers and other ToolsIn The Art, Science, and Engineering of Programming, Vol. 2, No. 3, 2018, article 14  2017      Thomas Würthinger, Christian Wimmer, Christian Humer, Andreas Wöß, Lukas Stadler, Chris Seaton, Gilles Duboscq, Doug Simon, Matthias GrimmerPractical partial evaluation for high-performance dynamic language runtimesIn Proceedings of the 37th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI 2017)        Aleksandar Prokopec, David Leopoldseder, Gilles Duboscq, Thomas WürthingerMaking collection operations optimal with aggressive JIT compilationIn Proceedings of the 8th ACM SIGPLAN International Symposium on Scala (Scala 2017)        Michael Van De VanterBuilding Flexible, Low-Overhead Tooling Support into a High-Performance Polyglot VM (Extended Abstract)MoreVMs Workshop on Modern Language Runtimes, Ecosystems, and VMs  2016      Benoit Daloze, Stefan Marr, Daniele Bonetta, Hanspeter MössenböckEfficient and Thread-Safe Objects for Dynamically-Typed LanguagesAccepted for the Annual ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications 2016 (OOPSLA)        Manuel Rigger, Matthias Grimmer, Hanspeter MössenböckSulong – Execution of LLVM-Based Languages on the JVMIn Proceedings of International Workshop on Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems (ICOOOLPS)        Josef Eisl, Matthias Grimmer, Doug Simon, Thomas Würthinger, Hanspeter MössenböckTrace-based Register Allocation in a JIT CompilerIn Proceedings of the 13th International Conference on Principles and Practices of Programming on the Java Platform: Virtual Machines, Languages, and Tools (PPPJ ‘16)        Stefan Marr, Benoit Daloze, Hanspeter MössenböckCross-language compiler benchmarking: are we fast yet?In Proceedings of the 12th Symposium on Dynamic Languages (DLS 2016)        Manuel Rigger, Matthias Grimmer, Christian Wimmer, Thomas Würthinger, Hanspeter MössenböckBringing low-level languages to the JVM: efficient execution of LLVM IR on TruffleIn Proceedings of the 8th International Workshop on Virtual Machines and Intermediate Languages (VMIL 2016)        Manuel RiggerSulong: Memory Safe and Efficient Execution of LLVM-Based LanguagesIn Proceedings of the ECOOP 2016 Doctoral Symposium        Luca Salucci, Daniele Bonetta, Walter BinderEfficient Embedding of Dynamic Languages in Big-Data AnalyticsIn Proceedings of the International Conference on Distributed Computing Systems Workshops (ICDCSW 2016)        Lukas Stadler, Adam Welc, Christian Humer, Mick JordanOptimizing R language execution via aggressive speculationIn Proceedings of the 12th Symposium on Dynamic Languages (DLS 2016)        Daniele Bonetta, Luca Salucci, Stefan Marr, Walter BinderGEMs: shared-memory parallel programming for Node.jsIn Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA 2016)        Luca Salucci, Daniele Bonetta, Walter BinderLightweight Multi-language Bindings for Apache SparkIn Proceedings of the European Conference on Parallel Processing (Euro-Par 2016)        Luca Salucci, Daniele Bonetta, Stefan Marr, Walter BinderGeneric messages: capability-based shared memory parallelism for event-loop systemsIn Proceedings of the 21st ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPoPP 2016)        Stefan Marr, Chris Seaton, Stéphane DucasseZero-overhead metaprogramming: reflection and metaobject protocols fast and without compromisesIn Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI 2016)  2015      Matthias Grimmer, Chris Seaton, Thomas Würthinger, Hanspeter MössenböckDynamically Composing Languages in a Modular Way: Supporting C Extensions for Dynamic Languages.In Proceedings of the 14th International Conference on Modularity        Michael Van De VanterBuilding Debuggers and Other Tools: We Can “Have it All” (Position Paper)In Proceedings of the 10th Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems Workshop (ICOOOLPS)        Josef EislTrace register allocationIn Companion Proceedings of the 2015 ACM SIGPLAN International Conference on Systems, Programming, Languages and Applications: Software for Humanity (SPLASH Companion 2015)        Matthias Grimmer, Chris Seaton, Roland Schatz, Thomas Würthinger, Hanspeter MössenböckHigh-performance cross-language interoperability in a multi-language runtimeIn Proceedings of the 11th Symposium on Dynamic Languages (DLS 2015)        Matthias Grimmer, Roland Schatz, Chris Seaton, Thomas Würthinger, Hanspeter MössenböckMemory-safe Execution of C on a Java VMIn Proceedings of the 10th ACM Workshop on Programming Languages and Analysis for Security (PLAS’15)        Matthias Grimmer, Chris Seaton, Thomas Würthinger, Hanspeter MössenböckDynamically composing languages in a modular way: supporting C extensions for dynamic languagesIn Proceedings of the 14th International Conference on Modularity (MODULARITY 2015)        Doug Simon, Christian Wimmer, Bernhard Urban, Gilles Duboscq, Lukas Stadler, Thomas WürthingerSnippets: Taking the High Road to a Low LevelACM Transactions on Architecture and Code Optimization (TACO)        David Leopoldseder, Lukas Stadler, Christian Wimmer, Hanspeter MössenböckJava-to-JavaScript translation via structured control flow reconstruction of compiler IRIn Proceedings of the 11th Symposium on Dynamic Languages (DLS 2015)        Codruţ Stancu, Christian Wimmer, Stefan Brunthaler, Per Larsen, Michael FranzSafe and efficient hybrid memory management for JavaIn Proceedings of the 2015 International Symposium on Memory Management (ISMM’15)        Gülfem Savrun-Yeniçeri, Michael L. Van de Vanter, Per Larsen, Stefan Brunthaler, Michael FranzAn Efficient and Generic Event-based Profiler Framework for Dynamic LanguagesIn Proceedings of the Principles and Practices of Programming on The Java Platform (PPPJ’15)        Michael L. Van De VanterBuilding debuggers and other tools: we can “have it all”In Proceedings of the 10th Workshop on Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems (ICOOOLPS’15)        Benoit Daloze, Chris Seaton, Daniele Bonetta, Hanspeter MössenböckTechniques and applications for guest-language safepointsIn Proceedings of the 10th Workshop on Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems (ICOOOLPS’15)  2014      Matthias GrimmerHigh-performance language interoperability in multi-language runtimesIn Proceedings of the companion publication of the 2014 ACM SIGPLAN conference on Systems, Programming, and Applications: Software for Humanity (SPLASH Companion)        Matthias Grimmer, Manuel Rigger, Roland Schatz, Lukas Stadler, Hanspeter MössenböckTruffle C: Dynamic Execution of C on the Java Virtual MachineIn Proceedings of the International Conference on Principles and Practice of Programming in Java (PPPJ)        Matthias Grimmer, Thomas Würthinger, Andreas Wöß, Hanspeter MössenböckAn Efficient Approach to Access Native Binary Data from JavaScriptIn Proceedings of the 9th Workshop on Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems (ICOOOLPS)        Wei Zhang, Per Larsen, Stefan Brunthaler, Michael FranzAccelerating iterators in optimizing AST interpretersIn Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages &amp;amp; Applications (OOPSLA’14)        Matthias Grimmer, Manuel Rigger, Roland Schatz, Lukas Stadler, Hanspeter Mössenböck TruffleC: dynamic execution of C on a Java virtual machine In Proceedings of the 2014 International Conference on Principles and Practices of Programming on the Java platform: Virtual machines, Languages, and Tools (PPPJ’14)        Matthias Grimmer, Thomas Würthinger, Andreas Wöß, Hanspeter MössenböckAn efficient approach for accessing C data structures from JavaScriptIn Proceedings of the 9th International Workshop on Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems PLE (ICOOOLPS’14)        Christian Humer, Christian Wimmer, Christian Wirth, Andreas Wöß, Thomas WürthingerA domain-specific language for building self-optimizing AST interpretersIn Proceedings of the 2014 International Conference on Generative Programming: Concepts and Experiences (GPCE 2014)        Gilles Duboscq, Thomas Würthinger, Hanspeter MössenböckSpeculation without regret: reducing deoptimization meta-data in the Graal compilerIn Proceedings of the 2014 International Conference on Principles and Practices of Programming on the Java platform: Virtual machines, Languages, and Tools (PPPJ’14)        Thomas WürthingerGraal and truffle: modularity and separation of concerns as cornerstones for building a multipurpose runtimeIn Proceedings of the companion publication of the 13th international conference on Modularity (MODULARITY’14)        Lukas Stadler, Thomas Würthinger, Hanspeter MössenböckPartial Escape Analysis and Scalar Replacement for JavaIn Proceedings of Annual IEEE/ACM International Symposium on Code Generation and Optimization (CGO’14)        Christian Häubl, Christian Wimmer, Hanspeter MössenböckTrace transitioning and exception handling in a trace-based JIT compiler for javaACM Transactions on Architecture and Code Optimization (TACO)        Chris Seaton, Michael L. Van De Vanter, Michael HauptDebugging at Full SpeedIn Proceedings of the Workshop on Dynamic Languages and Applications (Dyla’14)        Andreas Wöß, Christian Wirth, Daniele Bonetta, Chris Seaton, Christian Humer, Hanspeter MössenböckAn object storage model for the truffle language implementation frameworkIn Proceedings of the 2014 International Conference on Principles and Practices of Programming on the Java platform: Virtual machines, Languages, and Tools (PPPJ’14)        Codruţ Stancu, Christian Wimmer, Stefan Brunthaler, Per Larsen, Michael FranzComparing points-to static analysis with runtime recorded profiling dataIn Proceedings of the 2014 International Conference on Principles and Practices of Programming on the Java platform: Virtual machines, Languages, and Tools (PPPJ’14)  2013      Thomas Würthinger, Christian Wimmer, Andreas Wöß, Lukas Stadler, Gilles Duboscq, Christian Humer, Gregor Richards, Doug Simon, Mario WolczkoOne VM to Rule Them AllIn Proceedings of the 2013 ACM international symposium on New ideas, new paradigms, and reflections on programming &amp;amp; software (Onward! 2013)        Matthias Grimmer, Manuel Rigger, Lukas Stadler, Roland Schatz, Hanspeter MössenböckAn efficient native function interface for JavaIn Proceedings of the International Conference on Principles and Practices of Programming on the Java Platform: Virtual Machines, Languages, and Tools (PPPJ)        Matthias GrimmerRuntime Environment for the Truffle/C VMMaster’s thesis, Johannes Kepler University Linz, November 2013        Gilles Duboscq, Thomas Würthinger, Lukas Stadler, Christian Wimmer, Doug Simon, Hanspeter MössenböckAn intermediate representation for speculative optimizations in a dynamic compilerIn Proceedings of the 7th ACM workshop on Virtual machines and intermediate languages (VMIL’13)        Lukas Stadler, Gilles Duboscq, Hanspeter Mössenböck, Thomas Würthinger, Doug SimonAn experimental study of the influence of dynamic compiler optimizations on Scala performanceIn Proceedings of the 4th Workshop on Scala (SCALA ‘13)        Gilles Duboscq, Lukas Stadler, Thomas Würthinger, Doug Simon, Christian Wimmer, Hanspeter MössenböckGraal IR: An Extensible Declarative Intermediate RepresentationIn Proceedings of the Asia-Pacific Programming Languages and Compilers Workshop, 2013        Christian Häubl, Christian Wimmer, Hanspeter MössenböckContext-sensitive trace inlining for JavaSpecial issue on the Programming Languages track at the 27th ACM Symposium on Applied ComputingComputer Languages, Systems &amp;amp; Structures        Christian Wimmer, Stefan BrunthalerZipPy on truffle: a fast and simple implementation of pythonIn Proceedings of the 2013 companion publication for conference on Systems, programming, &amp;amp; applications: software for humanity (SPLASH’13)        Christian Häubl, Christian Wimmer, Hanspeter MössenböckDeriving code coverage information from profiling data recorded for a trace-based just-in-time compilerIn Proceedings of the 2013 International Conference on Principles and Practices of Programming on the Java Platform: Virtual Machines, Languages, and Tools (PPPJ’13)  2012      Thomas Würthinger, Andreas Wöß, Lukas Stadler, Gilles Duboscq, Doug Simon, Christian WimmerSelf-optimizing AST interpretersIn Proceedings of the 8th symposium on Dynamic languages (DLS’12)        Christian Wimmer, Thomas WürthingerTruffle: a self-optimizing runtime systemIn Proceedings of the 3rd annual conference on Systems, programming, and applications: software for humanity (SPLASH’12)        Lukas Stadler, Gilles , Hanspeter Mössenböck, Thomas WürthingerCompilation queuing and graph caching for dynamic compilersIn Proceedings of the 6th ACM workshop on Virtual machines and intermediate languages (VMIL’12’)        Christian Häubl, Christian Wimmer, Hanspeter MössenböckEvaluation of trace inlining heuristics for JavaIn Proceedings of the 27th Annual ACM Symposium on Applied Computing (SAC’12)  If you are interested in deeper collaboration with us, please send us an email.",
                    "url": " /community/publications/"
                  },
                  
                  "docs-reference-manual":  {
                    "title": "GraalVM Reference Manual",
                    "content": "GraalVM Reference ManualReference manual describes everything there is to know about GraalVM, its architecture, implementation details, command line utilities’ options, compatibility with the default VMs for the supported languages and so on.Pick your favorite programming language and proceed to its page:  JavaScript &amp;amp; Node.js  Java &amp;amp; JVM Languages  Native Languages with the LLVM Runtime  Python  R  RubyIf you want to see whether GraalVM would work for your project, the first stepis to ensure the libraries and modules you use as dependencies work with GraalVM.To do it, please use the GraalVM language compatibility tool.To learn how to write polyglot applications and pass polyglot command line arguments see the polyglot reference page.Learn how polyglot applications can be embedded in Java applications or native images in the embedding reference page.For information on compiling your applications ahead-of-time and creating nativebinaries with GraalVM please refer to the Native Image page.More information on GraalVM Updater, the utility used to install language packs into the GraalVM distribution, for example Ruby, R, or Python, can be found on the GraalVM Updater page.",
                    "url": " /docs/reference-manual/"
                  },
                  
                  "docs-release-notes-release-candidates":  {
                    "title": "GraalVM Release Candidates",
                    "content": "1.0-RC16(2019-04-23)JavaWe addressed several benchmarks that had slower performance when running with the GraalVM compiler built as a native library, also known as libgraal, a mode selected as the default in the last release candidate. We fixed an issue causing a delay when shutting down the virtual machine process at the end of the execution of an application(see #1140).Native ImageWe improved the structure of the org.graalvm.nativeimage API: classes that canonly be used during image generation are now in the packageorg.graalvm.nativeimage.hosted, to clearly separate them from the classes thatcan be used at image run time. In order to stay backwards compatible, theoriginal classes are still present, but marked as deprecated. They will bedeleted in the next release candidate, so please update to the new classes.We fixed several bugs that were reported on GitHub, including anissue with the logging framework which materialized as an error that no instances of java.util.logging.SimpleFormatter are allowed in the image heap.As a result, native images work now correctly with Helidon, a Javaframework designed for writing microservices which recently announced theirsupport for GraalVM native images:Helidon flies faster with GraalVM.RubyA complete changelog for the Ruby component is available on GitHub. The highlights include:  Rounding modes have been implemented or improved for Float, Rational, BigDecimal classes (see #1509).  Added a pure-Ruby implementation of Foreign Function Interface (FFI) which passes almost all Ruby FFI specs (see #1529).  The KeyError raised from ENV#fetch and Hash#fetch now matches MRI’s message formatting (see #1633).JavaScriptA complete changelog for the JavaScript component is available on GitHub. The highlights include:  Loading JavaScript source code from URLs is now guarded by thejs.load-from-url command line option and prohibited by default.RA complete changelog for the R component is available on GitHub. The highlights include:  Allow parsing any letter in identifiersincluding, e.g., Japanese, with lexer starting from 1.0-RC16, which matchesGNU-R behavior.Python  Improved startup time of the graalpython native launcher.LLVM Runtime  The lli launcher now starts with the locale set to C.1.0-RC15(2019-04-05)JavaBy default,libgraal is nowused when running the java launcher or when using the --jvm mode for thelanguage launchers. The libgraal library is a version of the GraalVM compilerpre-compiled by native-image. In addition to improving startup time, libgraalcompletely prevents the GraalVM compiler from interfering with the heap usage andprofiles of application code. It has execution properties similar to othernative HotSpot compilers such as C1 and C2.JavaScript  Enabled Polyglot builtin based on Context.Builder.allowPolyglotAccess().  Added rest and spread properties support for foreign objects. For example, this spread syntax is now supported:    var arr1 = [0, 1, 2];var arr2 = [3, 4, 5];arr1 = [...arr1, ...arr2]; // arr1 is now [0, 1, 2, 3, 4, 5]  To see a complete list of changes, please refer to the project changelog.RNew Features  Implemented gzcon builtin for URL connections.Changes  Truffle interoperability API converts double values to int values if theyfit in the integer range. See the changes in the spectests.Bug Fixes  R incorrectly allowed Java interoperability when not started with --jvm.Starting from 1.0-RC15, --jvm flag is again necessary to enable interoperability with Java.A complete project changelog  is available on GitHub.RubyAn extensive list of changes is available on GitHub.Here is a short list of the most notable ones:Changes  Our experimental JRuby-compatible Java interop has been removed – use Polyglot and Java instead.  Process.clock_getres has been implemented.  debug, profile, profiler, which were already marked as unsupported, have been removed.Bug Fixes  autoload :C, &quot;path&quot;; require &quot;path&quot; now correctly triggers the autoload.  The shell standard library can now be require-d.Compatibility  Improved compatibility with MRI’s Float#to_s formatting #1626.  Added support for the base keyword argument to Dir.{[], glob}.PythonChanges  Migrated to the new Truffle libraries for interoperability support.  Added support for importing Java classes from the java namespace using normal Python import syntax, e.g. from java.util import ArrayList.  Implemented PEP 487 and PEP 560 to make the typing module work.More details can be found in the project changelog on GitHub.LLVM Interpreter  Added  a preliminary support for bitcode produced by LLVM 8.Native ImageBased on the feedback and bug reports, we improved the agent that traces reflectionand JNI usage on the JavaHotSpot VM. We also changed the implementation languageof the agent from C to Java. The agent is now a Native Image itself.The native-image-maven-plugin now supports multiline buildArgs andboolean parameter skip (skip image building if true).API changes for GraalVM integrators (SDK + Truffle)This version of GraalVM includes a major revision of the TruffleInteroperabilityAPIs.Most existing APIs for Truffle Interoperability were deprecated. Thecompatibility layer may cause significant performance reduction forinteroperability calls. Please see the Interop MigrationGuidefor an overview and individual @deprecated javadoc tags for guidance.We added Truffle Library API that allows language implementations to usepolymorphic dispatch for receiver types with support for implementation specificcaching/profiling with support for uncached dispatch. Please see the TruffleLibraryTutorialfor further details.The numerous changes were introduced to the GraalVM SDK Polyglot API as well:  Renamed Graal SDK to GraalVM SDK.  Experimental options now require --experimental-options on the command line tobe passed to the GraalVM language launchers, orContext.Builder#allowExperimentalOptions andEngine.Builder#allowExperimentalOptions to be set in other scenarios.For example, to diagnose the memory allocations of a JavaScript application with --memtracer profiling tool,you should prepend --experimental-options option:js --experimental-options --memtracer program.js.  Added a possibility to set an encoding in Source builder.  Added a new API for target type mappings using the new HostAccess API.We summarized all Truffle and SDK changes between GraalVM versions in separate changelogs:  GraalVM SDK changelog  GraalVM Truffle changelogToolsChrome Inspector  Object Preview feature added for GraalVM implementation of JavaScript.  Implemented a Custom Preview experimental feature for all languages supported by GraalVM.Ideal Graph Visualizer (IGV)Starting with 1.0-RC15 version of GraalVM, Ideal Graph Visualizer will beprovided as standalone download from GraalVMOTNpages. It is not part of GraalVM Community or Enterprise editions.1.0-RC14(2019-03-18)Introducing --vm.&amp;lt;option&amp;gt;We introduced a uniform --vm.&amp;lt;option&amp;gt; which allows to pass options in a uniform way, without knowing which VM mode (--jvm, or --native) will be used. It replaces  --jvm.&amp;lt;option&amp;gt; and --native.&amp;lt;option&amp;gt; command line options, e.g. the option to configure the maximum amount of memory used for the heap --jvm.Xmx=5G becomes --vm.Xmx=5G.This applies to all languages.JavalibgraalThis is the first release to include a prebuilt libgraal shared library. This shared library is produced by the native-image and contains a pre-compiled version of the GraalVM compiler. In addition to improving startup, libgraal completely avoids interfering with the heap usage and profiling of the application code. That is, it has execution properties similar to other native HotSpot compilers such as C1 and C2. To try it out, add -XX:+UseJVMCINativeLibrary to your java command line. Note that this is still a work in progress and we are focusing on improving its stability and ensuring it does not compromise peak performance.Default Failure BehaviorThe default behavior has changed for a failure (i.e., uncaught exception) duringthe compilation. These are now silently ignored and nothing is printed to theconsole. To get the old behavior of a message being printed to the console andfor collecting diagnostics about the failure, you now need to specify-Dgraal.CompilationFailureAction=Diagnose option.Native ImagesNew FeaturesWe introduced a tracing agent for the Java HotSpot VM that records usages of reflection and JNI that can then be converted to configuration files for the native image generator. This simplifies the process of getting new applications working as native images. For details, please look at the documentation.We improved support for the java.util.logging API. See the GitHub docs for details.The javax.script.ScriptEngine API is now supported. Please note that the Nashorn JavaScript engine does not work in native images and is therefore always excluded. However, Truffle based language implementations such as the GraalVM JavaScript engine are available when, e.g., the native image is built with the option --language:js.Implemented the Class.getSimpleName method for the native images (see 1020).Bugfixes      Fixed an NPE during native image generation at accessing annotations metadata on the classes opened for reflection (see 1048).        Fixed createTempFile() providing non-default filesystem and failing (see 1035).        Fixed a segfault due to incorrect socket address length value (see 1025).  JavaScriptHTML-like CommentsWe added support for HTML-like comments.var s = &quot;Introducing html-like comments&quot;;alert(s);&amp;lt;!-- this is a comment --&amp;gt;Changes  Renamed the option js.experimental-array-prototype to js.experimental-foreign-object-prototype.More details can be found in the project changelog on GitHub.RThe GraalVM implementation of R in this release comes with various bug fixes and improvements.Error PropagationAccording to the R semantics, errors are handled immediately at the point where they are raised. However, in language embedding or polyglot scenarios, it is more useful to have the errors propagate out of the R scope, so that they can be handled correctly. We changed the behavior of FastR in this regard so that now R errors are propagated. Note that this only happens if this is possible without causing unexpected side effect in R code,i.e., if there are no options(error = ...) or on.exit(...) handlers on the stack.Experimental OptionsAll specific options (NOT those GNU-R compatible like --save) are experimental except for --R.PrintErrorStacktracesToFile, which is an option that enables logging of FastR internal errors for bug reporting purposes. Experimental options can be unlocked using --experimental-options or with ContextBuilder#allowExperimentalOptions.To see a complete list of changes, please refer to the project changelog.RubyThis version of GraalVM features new methods implementations and other updates for Ruby implementation.New Features  Implemented Dir.children and Dir#children, String#delete_prefix, #delete_suffix and related methods.Changes  -Xlog= has been removed. Use --log.level= instead.  -J flag has been removed. Use --vm.* instead.  -J-cp lib.jar and similar have been removed. You should use --vm.cp=lib.jar or --vm.classpath=lib.jar instead.  The -X option now works as in MRI.An extensive list of changes is available on GitHub.PythonPython 3.7.0The standard library was updated to Python 3.7.0 from 3.6.5.Changes  Defined a subset of the graalpython launcher options as “stable”. All other options are subject to change and need to be unlocked explicitly on the command line.  Added the support for  -I flag to ignore the user environment and not add the working directory to sys.path.More details can be found in the project changelog on GitHub.LLVM Runtime  Various bug fixes.API Changes for GraalVM Integrators (SDK + Truffle)New Features  Added Context.Builder#allowExperimentalOptions to control whether experimental options can be passed to a Context.  Added Engine.Builder#allowExperimentalOptions to control whether experimental instrument and engine options can be passed.  The @Option annotation can now specify the stability of an option.  Added engine bound TruffleLogger for instruments. The engine bound logger can be used by threads executing without any context.Changes  Multiple deprecated elements were removed from  the Truffle Language Implementation Framework, i.e., TruffleException.isTimeout, EventBinding.getFilter etc..We summarized GraalVM Truffle and GraalVM SDK changes between GraalVM versions in the separate changelogs:  GraalVM SDK changelog  GraalVM Truffle changelog1.0-RC13(2019-03-05)ToolsIdeal Graph VisualizerWith GraalVM 1.0-RC13 release, there has been a significant change to theIdeal Graph Visualizer developer tool. The default behavior of the Dgraal.Dumpoption has changed in that IGV dumps are now written to the local file system by default.To get the old behavior of dumping straight to an IGV instance listening on 127.0.0.1:4445,you need to add -Dgraal.PrintGraph=Network option.If a network connection cannot be opened, dumping falls back to file system dumping.Graal VisualVMAnother developer tool, Graal VisualVM, now allows Heap monitoring of native-image processes.This functionality is available with GraalVM Enterprise Edition.R  R specific command line options are now passed as –R.PrintErrorStackTracesToFile=true instead of using JVM properties (–jvm.R:+PrintErrorStackTracesToFile). You can view available options with --help:languages.  Optional post installation script, configure_fastr, also regenerates etc/Renviron and etc/ldpaths files according to the target system.  R vectors are not writeable from other languages, because this would violate the R language semantics.A list of changes to GraalVM implementation of R is available on GitHub.JavaScript  Node.js updated from 10.15.0 to version 10.15.2.  Made JavaScript and Java interoperability available in native images. Note that you have to configure the accessible classes and methods at native image build time (see reflection configuration).  Node.js Worker class should be used instead of deprecated experimental Java.Worker API now.  A deprecated NashornJavaInterop mode was removed.More details can be found in the project changelog on GitHub.LLVM Runtime  Added the support for embedded bitcode in Mach-O files. We support bitcode in the __bitcode section of Mach-O object files, as well as bitcode files in an embedded xar archive in the __bundle section of executables or dylibs. For example, on OS X, you can compile your code with clang -fembed-bitcode -flto hello.c -o hello, creating a native executable with embedded bitcode. You can then run it natively (./hello) or with GraalVM ($GRAALVM_HOME/bin/lli ./hello).The full project changelog is available on GitHub.RubyThis release of GraalVM is rich in performance and compatibility improvements,multiple changes and bug fixes for Ruby implementation.An extensive list of all updates is available on  Github.  Here is a short list of most notable ones:New features:  Host interoperability with Java now works on SubstrateVM too.Changes:  -Xoptions has been deprecated and will be removed. Use --help:languages instead.  -Xlog= has been deprecated and will be removed. Use --log.level= instead.  -J has been deprecated and will be removed. Use --jvm. instead.  -J-cp lib.jar and so on have been deprecated and will be removed. Use--jvm.cp=lib.jar or --jvm.classpath=lib.jar instead.  -J-cmd, --jvm.cmd, JAVA_HOME, JAVACMD, and JAVA_OPTS do not work in any releasedconfiguration of TruffleRuby, so have been removed.  -Xoption=value has been deprecated and will be removed. Use --option=value instead.  TracePoint.trace and TracePoint#inspect have been implemented.Compatibility:  Improved the exception when an -S file is not found.  Removed the message from exceptions raised by bare raise to better match MRI #1487.  TracePoint now handles the :class event.Note that GraalVM 1.0-RC13 implementation of Ruby is built on Ruby 2.4.4, and itis still vulnerable to CVE-2018-16395. This will be fixed in the next release.PythonNew feature:  Allow installation of NumPy in a venv. Just run e.g. bin/graalpython -m venv numpy_env; source numpy_env/bin/activate; graalpython -m ginstall install numpy. Note that not all NumPy features work at the moment.To see a complete list of changes, please refer to the project changelog.API Changes for GraalVM Integrators (SDK + Truffle)  Added Debugger.getSessionCount() to return the number of active debugger sessions.  TruffleLanguage class now can register additional services. This change also deprecates the automatic registration of the language class as a service.  OptionCategory.DEBUG has been renamed to OptionCategory.INTERNAL for clarity.  Added static member to class objects that provides access to the class’s static members.  OptionStabilityhas been added for specifying the stability of an option.All GraalVM SDK and Truffle changes between GraalVM versions are summarized in the project changelogs:  GraalVM SDK changelog  GraalVM Truffle changelog1.0-RC12(2019-02-04)Native Image GenerationNative images now check the remaining available stack size on every method call,and throw a StackOverflowError on stack overflows.We continued the work on the support of incomplete classpaths. There were no big changes,but only small bug fixes based on users feedback. The support for incomplete classpathsnow allows to run the native image generator with bytecode verification,i.e., the option --no-verify is no longer passed to the Java HotSpot VMwhen running the native image generator.RAn extensive list of changes to GraalVM implementation of R is available on GitHub. Here is a short list of most notable ones:  FastR now uses the R base function print to implement TruffleLanguage#toString, so that tools and debuggers (like the Chrome Dev Tools console) format values (e.g., data.frame objects) in a familiar, R-like, way.  GraalVM implementation of R provides GNU-R compatible parseData for expressions parsed via parse(...,keep.source=T), which enables packages that use this functionality (like lambda.r and plumber) to work.  Added a dummy implementation of the ALTREP framework to avoid linking problems.JavaScript  Updated Node.js from 10.9.0 to version 10.15.0.  A new option js.experimental-array-prototype added to set prototype of array-like non-JS objects (like ProxyArray or Java List) to Array.prototype. It makes it possible to use functions like map or forEach on these objects directly.More details can be found in the project changelog on GitHub.LLVM Runtime  In order to streamline the polyglot APIs in LLVM Runtime, we deprecated the truffle_* builtin functions. We also broke binary compatibility to bitcode compiled with polyglot.h from version 1.0.0-RC2 (or older).  Read-only globals are now placed in read-only memory. This was necessary to accommodate some changes in mac OS Mojave’s libc that raise errors when format strings are placed in the writable memory.The project changelog is available on GitHub.RubyThis version came with the compatibility improvements:  Change to a new system for handling Ruby objects in C extensions which greatly increases compatibility with MRI.  Support for BigDecimal#to_r was implemented (See #1521).A complete project changelog is available on GitHub.PythonTo see a complete list of changes, please refer to the project changelog.  Added support for the __class__ variable in the class scope.  Initial support of the venv standard-library tool, the built-in _bz2 module and the pandas package was started up.API Changes for GraalVM Integrators (SDK + Truffle)GraalVM SDK and Truffle changes between GraalVM versions are summarized in the project changelogs:  GraalVM SDK changelog  GraalVM Truffle changelogToolsGraal VisualVM  Added the ability to create native image heap dump directly from Graal VisualVM interface.  Improved heap dump support in the native image.1.0-RC11(2019-01-14)Native Image GenerationWe improved the handling of incomplete classpaths, i.e., code that references classes that are not provided on the classpath. The approach we took for RC10 caused problems in corner cases that would have been difficult to fix, therefore we implemented a different approach. Thanks to everyone who tried our initial approach and reported problems on GitHub. We attempted to verify that all reported problems are solved with the new approach.JavaScript  Graal.js only supports ECMAScript 5 (ES5) and newer, and enforces that rule.  Added support for sharing Java objects using the experimental Node.js Worker Threads API.  Added support for ScriptEngine GLOBAL_SCOPE bindings.  Added options to enable/disable several extension features e.g., print() or load().  Added options to disable features for security reasons e.g., eval().More details can be found in the project changelog on GitHub.LLVM RuntimeGraalVM now reports source filenames and line numbers for LLVM functions in stack traces if the bitcode is compiled with debug information, even if the original source is not available.Find a complete changelog on GitHub.RubyA complete project changelog is available on GitHub. Here is a short list of most notable changes:  Allowed signal 0 to be used with Process.kill (see #1474).  Implemented Dir.each_child.  Added missing support for the close_others option to exec and spawn.  Implemented the missing MatchData#named_captures method (see #1512).  Process::CLOCK_ constants have been given the same value as in standard Ruby.  All core files now make use of frozen String literals, reducing the number of String allocations for core methods.PythonThe changelog is available on GitHub.  Added the ginstall custom module to install known packages such as NumPy and setup tools using graalpython -m ginstall.  Added support for the yield from syntax.  Added more built-in methods to the time module.  Added support for the standard zipfile module.  Added the built-in _cvs module.  Various bug fixes and performance improvements.  Removed the exposure of internal languages through polyglot.eval.R  The R version was upgraded to R-3.5.1.  R does not print or log any details for internal errors unless it is run with  --jvm.DR:+PrintErrorStacktracesToFile.  Newly implemented R native API functions:  Rf_duplicated, Rf_setVar, norm_rand, exp_rand.  Numerous bug fixes.More details can be found in the project changelog on GitHub.API Changes for GraalVM Integrators (SDK + Truffle)Please refer to the project changelogs for a list of APIs changes:  GraalVM SDK changelog  GraalVM Truffle changelogToolsGraal VisualVM  Added CPU monitoring of native-image processes.  Improved the search feature in text views - thread dumps, OQL console results, etc..  Heap viewer is now displaying JVM arguments, has improved performance and memory management.1.0-RC10(2018-12-05)Bug fixes and performance improvements across all GraalVM components.Native Image GenerationAdded a new option --allow-incomplete-classpath with GraalVM 1.0-rc10. By default (without specifying this option), classes that are reachable, but missing on the class path, are reported at native image generation time. When specifying this new option, missing classes are only reported at run time. The option provides support for, e.g., libraries that probe the existence of classes, catch the class loading error, and then fall back to a different behavior. This should result in more applications being able to compile to a GraalVM native image.JavaScriptThe project changelog is available on GitHub.  Added the ability to construct the Java classpath programmatically. If you know at runtime where the classes and jar files are located – you can add them to the classpath and use Java code from them.  Compatibility: added support for several proposals which might become parts of ECMAScript 2019: Array.prototype.{flat,flatMap}, well-formed JSON.stringify, globalThis.  Compatibility: moved several non-standard builtins behind flags (see the  changelog).LLVM Runtime  Improved the debugging experience: internal functions (originating from the GraalVM LLVM interpreter implementation) are now hidden in the stack traces by default and can be debugged with --inspect.Internal; and unhandled exceptions are now output to stderr instead of stdout.More details can be found in the project changelog on GitHub.RubyGraalVM 1.0-rc10 implementation of Ruby comes with several new features and multiple bug fixeswhich can be found in the project changelog on GitHub.  Compatibility: implemented the following API and added libraries:          The nkf and kconv standard libraries were added.      Queue and SizedQueue, #close and #closed?, have been implemented.      Kernel#clone(freeze) has been implemented.      Warning.warn has been implemented.      Thread.report_on_exception has been implemented.        Compatibility: ArgumentError messages now better match MRI.Python  Several users-facing improvements were made to the embedding interfaces: getting/setting the current working directory in Python now uses the appropriate Truffle APIs, Python will report side effects in the KEY_INFO message, and the KEYS message now responds with attributes and methods (not with dict keys).  The interactive help() builtin now works, including asking about language and syntax.A complete project changelog is available on GitHub.RMade important steps for compatibility with the R ecosystem:  Improved the support for popular packages: Rcpp modules, dplyr now mostly works,and FastR provides its own version of data.table (work in progress).  A new builtin function install.fastr.packages(pkgs) can be used to install FastR-specific versions of the rJava and data.table packages.  Fixed linking problems on MacOS when installing R packages and using Fortran code.The full changelogis available on GitHub.API Changes for GraalVM Integrators (SDK + Truffle)To see the list of changes to the APIs please refer to the project changelogs:  GraalVM SDK changelog  GraalVM Truffle changelogToolsGraal VisualVMSeveral quality of life improvements:  Added the display of system properties for SVM heap dumps.  Added support for the fields histogram and merged references for guest languages: JavaScript, Ruby, and so on.  Improved CPU Sampler accuracy.Ideal Graph Visualizer  The tool understands mx project structure now, e.g. the GraalVM compiler project when opening sources.  Improved performance when laying out large graphs.1.0-RC9(2018-11-05)GraalVM for Java Developers (GraalVM + compiler)  Updated based JDK to 8u192. You can find the JDK release notes at the Oracle Technology Network website.RubyGraalVM 1.0-rc9 implementation of Ruby features security updates and multiple bug fixeswhich can be found in the project changelog on GitHub.  Here is a short list of most notable changes:  LLVM for Oracle Linux 7 can now be installed without building from source.  The supported version of LLVM for Oracle Linux has been updated from 3.8 to 4.0.  mysql2 is now patched to avoid a bug in passing NULL to rb_scan_args, and now passes the majority of its test suite.  The post-install script now automatically detects if recompiling the OpenSSL C extension is needed. The post-install script should always be run in TravisCI as well, see the documentation.  Detect when the system libssl is incompatible more accurately and add instructions on how to recompile the extension.Python  Added the support help in the builtin Python shell.  Added readline to enable history and autocompletion in the Python shell.  Add support for the -q, -E, -s, and -S Python launcher flags.  Improved support for string and bytes regular expressions using our TRegex engine.  Started the initial support for the binascii module.A complete project changelog is available on GitHub.R  Various improvements in handling of foreign objects in R.  Added missing R builtins and C API: eapply builtin and rapply builtin.More details can be found in the project changelog on GitHub.JavaScriptA complete changelog is available on GitHub.LLVM RuntimeThe project changelog is available on GitHub.API Changes for GraalVM Integrators (SDK + Truffle)  Added SourceElement.ROOT and StepConfig.suspendAnchors() to tune debugger stepping.  Added Context.Builder.logHandler and Engine.Builder.logHandler methods to install a logging handler writing into a given OutputStream.  Primitives, host and Proxy values can now be shared between multiple context and engine instances. They no longer throw an IllegalArgumentException when shared.The major GraalVM SDK and Truffle changes between GraalVM versions are summarized in the project changelogs:  GraalVM SDK changelog  GraalVM Truffle changelogToolsGraal VisualVM  Improved Python heapwalker by fixing class names and adding support for PString.  Fixed handling Page Up/Down in ProfilerTreeTable. See GH-109 for details.1.0-RC8(2018-10-19)GraalVM for Java Developers (GraalVM + compiler)  Added the support for Intel bit manipulation instructions. For more details, see #666.  Virtualize unsafe compare and swap calls on non-escaping objects. See #636.Maven Artifacts  The com.oracle.truffle group ID was renamed to org.graalvm.truffle.  The graal-sdk, launcher-common and polyglot-tck artifacts were moved from the org.graalvm group ID to org.graalvm.sdk.  New artifacts that are now available:          org.graalvm.compiler:compiler      org.graalvm.js:js      org.graalvm.js:js-launcher      org.graalvm.js:js-scriptengine      org.graalvm.regex:regex      org.graalvm.tools:chromeinspector      org.graalvm.tools:profiler      org.graalvm.truffle:truffle-nfi      com.oracle.substratevm:library-support      com.oracle.substratevm:objectfile      com.oracle.substratevm:pointsto      com.oracle.substratevm:svm-driver      com.oracle.substratevm:svm        The artifacts that are now modular JARs:          truffle-api      graal-sdk      js      js-scriptengine      compiler        The compiler artifact provides the jdk.internal.vm.compiler module and can be used to upgrade that module in JDK 11. Unlike the module present in the JDK, this version contains the optimizing Truffle runtime.Native Image Generation  The native image generator now has automatic support for services loaded using ServiceLoader.All service implementation classes, listed in the META-INF directory, are available automatically as soon as the service interface is used. This eliminates the need to manually register resources and reflection support for such classes. The automatic registration can be disabled with the -H:-UseServiceLoaderFeature option.  Finished the support for isolates (starting multiple independent VM instances at run time) and compressed references (to reduce memory footprint; Enterprise Edition only). More details are in an upcoming blog article.  A new Maven plugin allows native image generation from within a Maven build.  All components necessary for native image generation (Substrate VM and the GraalVM compiler) are now available on Maven Central. The dependency for that is:      &amp;lt;dependency&amp;gt;    &amp;lt;groupId&amp;gt;com.oracle.substratevm&amp;lt;/groupId&amp;gt;    &amp;lt;artifactId&amp;gt;svm&amp;lt;/artifactId&amp;gt;    &amp;lt;version&amp;gt;1.0.0-rc8&amp;lt;/version&amp;gt;    &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;  &amp;lt;/dependency&amp;gt;  JavaScript  Updated Node.js to version 10.9.0.A complete changelog is available on GitHub.LLVM RuntimeThe project changelog is available on GitHub.Ruby  Ubuntu 18.04 LTS, Fedora 28, and macOS 10.14 (Mojave) now supported.  Java.synchronized(object) { } and TruffleRuby.synchronized(object) { } methods have been added.  Added a TruffleRuby::AtomicReference class.  Performance of setting the last exception on a thread has now been improved.A complete project changelog is available on GitHub.Python  Python now supports the allocation profiler (--memtracer) to analyze the heap usage of applications.The changelog is available on GitHub.RGraalVM 1.0-rc8 implementation of R came up with multiple bug fixes which can be found in the project changelog on GitHub.ToolsGraal VisualVM  Introduced the CPU and Memory Sampler for guest languages.  Submitted improvements in the R language heapwalker.API Changes for GraalVM Integrators (SDK + Truffle)The major GraalVM SDK and Truffle changes between GraalVM versions are summarized in the project changelogs:  GraalVM SDK changelog  GraalVM Truffle changelog1.0-RC7(2018-10-03)GraalVM for Java Developers (GraalVM + compiler)  Added the virtualization of Unsafe compare and swap calls, for more details see GH-636.Native Image Generation  Support for the Java security framework, see JCA-SECURITY-SERVICES.md for the details.  Support for https URL connections, see URL-PROTOCOLS.md for more details.JavaScript  Improved support for sharing of shapes between Contexts with the same Engine, which allows to reuse ASTs and objects across different manually created contexts.  Support for BigInteger typed TypedArrays.More details can be found in the project changelog on GitHub.LLVM RuntimeThe full changelog is available on GitHub.  New polyglot builtin polyglot_has_member.  Removed support for implicit polyglot types for local variables as the availability of type information is not guaranteed. Explicit polyglot casts are now strictly required (polyglot_as_typed). See docs/INTEROP.md and polyglot.h for more details.  Support for IR-level (textual representation of bitcode files) tracing, i.e., creating an execution log of all bitcodes that were executed, for debugging purposes.  Preliminary support for LLVM 7.RubyThe complete changelog is available on GitHub. Here is a short list of most notable changes.  Useful inspect strings have been added for more foreign objects.  Added the rbconfig/sizeof native extension for better MRI compatibility.  Support for pg 1.1. The extension now compiles successfully, but may still have issues with some datatypes.  readline can now be interrupted by the interrupt signal (Ctrl+C). This fixes Ctrl+C to work in IRB.  Fixed version check preventing TruffleRuby from working with Bundler 2.0 and later.  Removed obsoleted patches for Bundler compatibility now that Bundler 1.16.5 has built-in support for TruffleRuby.  Fixed problem with Kernel.public_send not tracking its caller properlyrb_thread_call_without_gvl() no longer holds the C-extensions lock.  Fixed caller_locations when called inside method_added.  Fixed mon_initialize when called inside initialize_copy.Python  Added support for the re.split builtin.  Enhanced the java interop builtin module with introspection utility methods.  Changes in C extension interface to reduce overhead.The changelogis available on GitHub.R  AWT based graphics devices (jpg, png, X11, …) is supported when running FastR as a native image.  eval.polyglot: the parameter source was renamed to code.  New builtin as.data.frame.polyglot.value creates R data frames from Polyglot objects (KEYS are used as column names, the values must be homogenous arrays, e.g. respond to HAS_SIZE).  Paths in eval.polyglot are resolved relative to the current working directory.  Various fixes necessary to pass dplyr tests (GitHub version of dplyr).More details can be found in the project changelog on GitHub.ToolsIdeal Graph Visualizer  User can navigate to Javascript (guest language) source from the graph nodes.  Ideal Graph Visualizer prompts to download plugins to support Javascript editing.  Simple scripts (written in Javascript) can be applied on graph data.API Changes for GraalVM Integrators (SDK + Truffle)  GraalVM SDK and Truffle license changes from GPL2 with Class Path Exception to the Universal Permissive License (UPL). Please refer to the license files for more information: GraalVM Truffle license, GraalVM SDK license.To see the list of changes to the APIs, please refer to the project changelogs:  GraalVM SDK changelog  GraalVM Truffle changelog1.0-RC6(2018-08-31)GraalVM for Java Developers (GraalVM + compiler)  New optimization to remove unnecessary allocation in some calls to Enum.values().  See calls to Enum.values() don’t optimise away as expected for the details.Native Image Generation  Delay class initialization to runtime: By default, all classes that are seen asreachable for a native image are initialized during image building, i.e., theclass initialization method is executed during image building and is not seen asa reachable method at runtime. But for some classes, it is necessary to executethe class initialization method at runtime. This is now possible using the newoption --delay-class-initialization-to-runtime=&amp;lt;comma separate list of classnames&amp;gt; or using the new API RuntimeClassInitialization class.  Direct byte buffer are no longer allowed in the image heap: We added a new verification during image generation to ensure that no direct or mapped byte buffers (MappedByteBuffer instances) are in the image heap. Such buffers have either a pointer to C memory or reference a file descriptor, i.e., native resources that are available during image generation but no longer at image runtime. Using such a buffer would lead to a segfault at runtime. We discovered this issue because Netty has a few direct buffers that are created in class initializers. It is necessary to delay the initialization of such classes to runtime.  Better automatic discovery of classes, methods, and fields accessed via reflection. When String parameters of Class.forName, Class.getMethod, Class.getField, and other similar classes can be constant folded during image generation, then these classes, methods, and fields are automatically registered for reflection usage and do not need to be registered manually on the command line. Constant String parameters are a common pattern to support, e.g., different JDK versions or different library versions where a class, method, or field is not present in all cases and therefore cannot be used directly.LLVM RuntimeThe full changelogis available on GitHub.  Support for LLVM IR-level debugging, i.e., debugging at the level of *.ll instead of *.c files.  New polyglot cast functions for primitive array types, which allows object from other languages to be used like primitive arrays.  Support for function pointer members in polyglot_as_typed, which allows objects from other languages to be used in expressions like obj-&amp;gt;func(args).RubyThe complete changelog is available on GitHub. Here is a short list of most notable changes.  TruffleRuby is now usable as a JSR 223 (javax.script) language;  A migration guide from JRuby is now included.  The embedded configuration -Xembedded can now be set set on the launcher command line.  Polyglot.export can now be used with primitives and converts strings to Java, when Polyglot.import converts them from Java.  Foreign objects optimisations such as unboxing foreign strings on to_s, to_str, and inspect.  Optimized performance and keyword rest arguments (def foo(**kwrest)).  Multiple bug fixes from user reports.PythonThe full changelog is available on GitHub.  Improved compatibility with regular expressions by including CPython’s sre module as a fallback engine (in addition to Truffle’s regular expression engine).  C extension modules can now be compiled with LLVM 5+, which was prevented by internal incompatibilities before.  Introduced lazy string concatenation to significantly speed up code patterns that repeatedly concatenated strings.  Numerous C-API improvements to extend support for scikit-learn.  Extensions and fixes in various areas: behavior of function and code objects, collections, exception handling during import, type ids, documentation and generators.  Update standard library to CPython 3.6.5.  Enable reuse of ASTs in multiple Contexts (requires the contexts to be created in the same polyglot Engine).RThe full changelogis available on GitHub.  Support for reading/writing graphical parameters via par.  Added numerous builtins to the C API, enabling support for packages like RCurl, rjson, compare, naivebayes, etc.  Added support for formulas that include ....  Various bug fixes: attributes of NULL objects, of CR/LF handling in readLine, La_chol with pivot, warnings/errors in vector coercion.API Changes for GraalVM Integrators (SDK + Truffle)To see the list of changes to the APIs please refer to the project changelogs:  GraalVM SDK changelog  GraalVM Truffle changelog1.0-RC5(2018-07-31)GraalVM 1.0-rc5 is the first release where we provide pre-built binaries for GraalVM CE on macOS. As always all binaries are available from the downloads page.KNOWN ISSUES  The GraalVM CE image for MacOS currently depends on some libraries that are not installed by default on current MacOS versions.This might cause issues with UI-related functionality:    Library not loaded: /usr/X11/lib/libfreetype.6.dylib    The necessary components can be added, e.g., by installing https://www.xquartz.org. We will remove this dependency in upcoming versions of GraalVM CE for MacOS.  GraalVM for Java Developers (GraalVM + compiler)  1.0-RC5 includes JVMCI changes necessary to support compiling the GraalVM compiler ahead of time and deploying as a shared library alongside libjvm.so (i.e., libgraal). Note that the implementation of libgraal itself is not a part of this release as it is still under development.Native Image Generation  Added API that allows an application to distinguish between native image building, native image runtime, and regular Java execution. For more information and documentation, look at the class  ImageInfo.JavaScript  Removed legacy NashornExtensions option, use --js.nashorn-compat instead.  Added support for Symbol.prototype.description.  Added support for String.prototype.matchAll.More details can be found in the project changelog on GitHub.RubyThe full changelog is available in the GitHub repository, but here are some of the most notable changes.  Simpler installation on macOS: it is no longer needed to add LLVM (/usr/local/opt/llvm@4/bin) to PATH on macOS.  --log.ruby.level= can be used to set the log level from any language launcher.  String#unpack1 has been implemented.  Optimized required and optional keyword arguments.  -Dtruffleruby.log and TRUFFLERUBY_LOG have been removed - use -Dpolyglot.log.ruby.level.  The custom log levels PERFORMANCE and PATCH have been removed.Python  Generator expressions now properly evaluate their first iterator in the definition scope at definition time.  Fixes for embedders to ensure top scopes are stable and local scopes always contain TruffleObjects.  C-API improvements to support simple Cython modules.  Support recognition of Python source files with the polyglot launcher, so that now --language python is not necessary when starting Python scripts with the polyglot launcher (note that the polyglot launcher still needs to be rebuilt using bin/gu rebuild-images polyglot after installing Python).Full changelog is available on GitHub CHANGELOG.md.RSee CHANGELOG for the list of changes.LLVM RuntimeThe project changelog is available on GitHub.  Support the __builtin_debugtrap function based on LLVM’s @llvmn.debugtrap intrinsic, which can be used to drop into the debugger (e.g., Chrome Inspector).  Support “zero-length array at end of struct” pattern when accessing polyglot values as structs.  Improved performance of global variable access.  Improved support for vectorized bitcode operations generated by clang.API Changes for GraalVM Integrators (SDK + Truffle)  Added new execution listener API that allows for simple, efficient and fine-grained introspection of executed code.  Changed the default language context policy from SHARED to EXCLUSIVE, i.e. by default there is one exclusive language instance per polyglot or inner context. This can be configured by the language using the context policy.To see the full list of changes to the APIs please refer to the project changelogs:  GraalVM SDK changelog  GraalVM Truffle changelogToolsGraal VisualVM  Graal VisualVM was added to the GraalVM CE distribution.1.0-RC4(2018-07-13)General RemarksWhile we provide updated components for all languages for this rc4 release, only the JavaScript component received fixes from its upstream repository. All other languages are unchanged in terms of functionality.The next release, rc5, is planned for the beginning of August and will provide updates for all components.JavaScriptThe GraalVM JavaScript component has been updated to provide better compatibility with the Nashorn engine. There now is a --nashorn-compat flag to enable backwards compatibility functionality. This flag is highly discouraged for new applications, but can simplify the migration from Nashorn to GraalVM for existing code.  Access getters and setters like fields  Provide Java.extend, Java.super, JavaImporter, JSAdapter  Allow to construct Interfaces or AbstractClasses      Provide top-level package globals java, javafx, javax, com, org, edu    Provide Java.isScriptFunction, Java.isScriptObject, Java.isJavaMethod and Java.isJavaFunctionSome global functions and objects have been added for the scripting mode and can be enabled with the --scripting flag:  Provide $EXEC, $ENV, $ARG, $OPTIONS1.0-RC3(2018-06-29)GraalVM for Java Developers (GraalVM + compiler)  Updated the underlying JDK version to “1.8.0_172” from “1.8.0_171”. You can find the JDK release notes at the Oracle Technology Network website.  Fixed a rare NullPointerException during JVMCI initialization.Native Image Generation  Added support for java.lang.reflect.Proxy supporting both automatic detection and manual configuration. Please refer to the documentation on GitHub for the details.  Added support for Classloader.getResource() and similar methods.  Added support for loading services through theServiceLoader.  Fixed a ClassCastException on generating native images for profile-guided-optimizations (with the --pgo-instrument command line option).JavaScript  Enabled code sharing between Contexts with the same Engine.  Added support for BigInt arithmetic expressions.  Added a flag for the Nashorn compatibility mode --js.nashorn-compat, for the details and migration from Nashorn please refer to the documentation.  Rename the flag for the V8 compatibility mode to js.v8-compat.More details can be found in the project changelog on GitHub.RubyThe full changelog is available in the GitHub repository, but here are some of the most notable changes.  Added ability to call is_a? on foreign objects.  Fixed: Qnil/Qtrue/Qfalse/Qundef can now be used as initial value for global variables in C extensions.  Fixed: SIGPIPE is correctly caught on SubstrateVM, and the corresponding write() raises Errno::EPIPE when the read end of a pipe or socket is closed.  Fixed determining the source encoding for eval() based on the magic encoding comment.Additionally, we implemented a number of performance improvements for stat() related calls, eval(), String substitutions, reading from IO and more.PythonGraalVM Python implementation is still in the early stages, but we’re making progress towards the goal of running applications which use SciPy.  Various C-API improvements allow to run simple NumPy examples.  Implemented buffered I/O and more encodings support, which enables working with files through the standard open function without having to force unbuffered access, and enables working with files that have encodings other than utf-8.  Most math module functions are now implemented and work correctly.  The random module substitute was removed and we now run the standard library random module to be fully compatible.  Improved thread-safety in the embedded scenarios when using Python contexts from multiple threads.More details are available in the project’s changelog on GitHub.R  Added more missing R builtins and C API functions, see CHANGELOG for a complete list.  Simplified installation, the script that configures FastR for the current system  jre/languages/R/bin/configure_fastr does not require Autotools anymore.  Added configuration files to allow users to build a native image of the FastR runtime, which reduces the startup time. Run jre/languages/R/bin/install_r_native_image to build the image.  Fixed an issue with the plotting window not displaying anything after it was closed and reopened.LLVM Runtime  New builtins polyglot_from_typed and polyglot_as_typed, which can be used to dynamically attach types to polyglot objects.  Implementers of TruffleObject can now respond to the GetDynamicType message to provide a type when an object is accessed from LLVM code.More details are available in the project changelog.API Changes for GraalVM Integrators (SDK + Truffle)  Added support for logging in Truffle languages and instruments.  Removed deprecated ResultVerifier.getDefaultResultVerifier API.To see the list of changes to the APIs please refer to the project changelogs:  GraalVM SDK changelog  GraalVM Truffle changelogToolsGraal VisualVMWe improved memory footprint and introduced several UI improvements for cleaner more responsive experience of Graal VisualVM. In addition to that, there are the following improvements:  Added recognition of the LLVM Runtime processes.  Improved displaying logical values of guest languages’ objects.  Improved the Object Query Language (OQL) Console for inspecting memory dumps functionality — sorting, filtering, aggregation, unlimited number of results now work.Chrome inspector  Multiple inspector sessions for multiple polyglot engines can run on the same port now.1.0-RC2(2018-06-05)GraalVM for Java Developers  Updated the underlying JDK version to “1.8.0_171” from “1.8.0_161”. You can find the JDK release notes at the Oracle Technology Network website.  Improved support for the Java Microbenchmark harness. Since JMH 1.21, GraalVM is a recognized and supported JVM.  Fixed a StackOverflow exception an improved performance when recursively inlining of invokedynamic instructions.  Fixed a compiler error causing incorrect code generation while building the scalac compiler.Native Image Generation  Added support for building statically linked native images. Now you can pass --static, and if you have static libc and zlib installed, it generates a standalone executable that will not require libc for running.  Added Classpath exception to the license of SubstrateVM and the Graal compiler components to make sure all GraalVM code ending up in a native image is subject to this clause.  Fixed the handling of implicit exceptions (NullPointerExeption, ArrayIndexOutOfBoundsException, ClassCastException, …): all exceptions now have correct stack traces and can be caught as expected. Previously, implicit exceptions were sometimes not caught by an exception handler within the same method.  Fixed a number of exceptions during the generation of native images that were reported by early adopters.JavaScript  Updated Node.js to 8.11.1 (from 8.9.4), it is not a breaking change, but it brings numerous improvements, including CVE-listed security fixes.LLVM Runtime  Added a new API for accessing Java types and instantiating foreign objects from LLVM languages.Now it is possible to easily call Java code from native programs compiled to the LLVM bitcode. The example below shows how you can access Java’s BigInteger long math operations from C.#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;polyglot.h&amp;gt;int main() {    void *bigInteger = polyglot_java_type(&quot;java.math.BigInteger&quot;);    void *(*BigInteger_valueOf)(long) = polyglot_get_member(bigInteger, &quot;valueOf&quot;);    void *bi = BigInteger_valueOf(2);    void *result = polyglot_invoke(bi, &quot;pow&quot;, 256);    char buffer[100];    polyglot_as_string(polyglot_invoke(result, &quot;toString&quot;),                       buffer,                       sizeof(buffer),                       &quot;ascii&quot;);    printf(&quot;%sn&quot;, buffer);}If we compile it to the LLVM bitcode, we can execute it with GraalVM. You can see that it computes the value of2^256 which isn’t that easy to do in C otherwise.# shelajev at shrimp.local in /tmp→ clang -c -O1 -emit-llvm -I$GRAALVM_HOME/jre/languages/llvm big-integer-demo.c# shelajev at shrimp.local in /tmp→ lli --jvm big-integer-demo.bc115792089237316195423570985008687907853269984665640564039457584007913129639936A more detailed list of changes to the LLVM interpreter can be found in the full changelog.Ruby  We are now compatible with Ruby 2.4.4.  Java.import name imports Java classes as top-level constants.  Coercion of foreign numbers to Ruby numbers now works.  to_s works on all foreign objects and calls the Java toString.  to_str will try to UNBOX and then re-try to_str, in order to provoke the unboxing of foreign strings.Much more details can be found in the full changelog.RAmong the other changes, we improved the stability of GraalVM’s R implementation.  Added a /jre/languages/R/bin/configure_fastr script that allows FastR’s native build scripts to adopt to the current system, which makes installing R packages much more stable.  The fastr_errors.log file was renamed to fastr_errors_pidXYZ.log and is stored in either initial working directory, the user home directory, /tmp, or the FastR home directory (picking the first location that is writeable). Please add it to the bug reports if you submit issues.Python  Added support for the Python unittest framework.  Python now supports breaking on exceptions and unwinding to stack frames in Chrome inspector.API Changes for GraalVM Integrators (SDK + Truffle)Both GraalVM SDK and Truffle are offering API for developers trying to build things on top of GraalVM, language implementations, embedding GraalVM, and so on.  Enabled code sharing between guest language Contexts with the same Engine, speeding up the repeated evaluation of the code.To see the list of changes to the APIs please refer to the project changelogs:  GraalVM SDK changelog  GraalVM Truffle changelogToolsVisualVM  Fixed the issues with loading polyglot heap dumps  fixed executing of scripts in R console  improved recognition of R REPL  fixed loop to nodes  fixed memory leak in child nodes  improved appearance on MacOS  Applicability fixes  added roots histogram for classGraalVM Updater gu  The default operation mode changed from “install from local files” to “install from catalog”.  -c option for installing from the catalog, can be omitted (installing from the catalog the default), but specifying -c still works.  Use -F to install from local files, i.e. bin/gu -F /tmp/ruby-installable.jar.Chrome InspectorFixed a number of issues:  fixed the initial suspend of node scripts with no statement on the first line  fixed tooltip issues and representation of the functions  fixed issues with re-connection of Chrome inspector client",
                    "url": " /docs/release-notes/release-candidates/"
                  },
                  
                  "docs-release-notes":  {
                    "title": "Release Notes",
                    "content": "In this section, we would like to highlight the most important changes in theGraalVM releases. There are different components to GraalVM, so we highlightthe changes to these separately.Since GraalVM advances fast and has many different components, we believe we worked out an appropriate versioning scheme, described on Version Roadmap page.GraalVM evolved from a project into a mature product. We previously onlypublished “release candidates” builds of GraalVM and gathered the mostsignificant improvements in Release Candidatessummary.In May 2019, GraalVM 19.0 was released as a production-ready software.Currently, there is one release branch of GraalVM: 19. Next year, we willrelease GraalVM 20, and so on. During the year, there are several releases fromthe main line of the project, e.g. 19.1, 19.2, to follow the updates to theplatforms GraalVM depends upon: OpenJDK, Node.js, LLVM, Ruby, R, Python. Wegrouped the release notes to major releases in descending order for usability reasons.Please choose a release you are interested at and proceed to its page.If you find an issue or want to submit a feature request please use therepositories for the project closest related to the issue:  GraalVM, the GraalVM compiler, Native Image, LLVM Runtime, Truffle framework, Tools, Regular Expressions  JavaScript  Ruby  R  PythonIf in doubt, the main repository will work, we would be happy to hear any feedback: oracle/graal. Known issues with the components GraalVM uses are listed here.",
                    "url": " /docs/release-notes/"
                  },
                  
                  "scala":  {
                    "title": "Scala",
                    "content": "",
                    "url": " /scala/"
                  },
                  
                  "docs-search":  {
                    "title": "Search",
                    "content": "",
                    "url": " /docs/search/"
                  },
                  
                  "docs-reference-manual-security-guide":  {
                    "title": "Security Guide",
                    "content": "Security GuideThis security guide provides developers and embedders with information on thesecurity model and features of GraalVM, such that they can build a secureapplication on top of it. It assumes that readers are familiar with the GraalVMarchitecture.  This guide does not replace but rather supplements the Javasecurity documentation with aspects unique to GraalVM. It also provides securityresearchers with information on GraalVM’s security model.This guide does not (yet) cover security aspects specific to a languageimplementation, usage of the Instrument API or any APIs other than the PolyglotAPI.Security ModelGraalVM is a shared runtime. It accepts instructions in a higher-levelprogramming language (or an intermediate representation thereof) as input, whichis executed at some point. Developers that implement security controls for theirapplications (such as access control) in code that is being run by GraalVM canrely on the correct execution of instructions. Incorrect execution ofsecurity-critical code running on top of GraalVM that allows to bypass such asecurity control is regarded a security vulnerability.Using the Truffle Language Implementation framework,interpreters for guest languages can be implemented to execute guestapplications written in languages such as Javascript, Python, Ruby or R on top ofGraalVM. The execution context for these guest applications can be created withrestricted privileges, to allow for the execution of less trusted guestapplications. For example, an embedder writes an application server (the hostapplication) that runs JavaScript guest applications from a less trusted source.GraalVM offers features to limit the privileges of the guestapplication to some extent.For every guest language shipped with GraalVM, a launcher, e.g. (interactive)shell, is provided. These launchers behave in the same way and come with thesame security guarantees as their “original” counterparts.Warning: GraalVM provides only experimental support for Python, R and Ruby languages. Experimental features might never be included in a production version, or might change significantly before being considered production-ready.We appreciate reports of bugs that break the security model via the processoutlined in the Reporting Vulnerabilities guide.Guest Application ContextGraalVM allows a host application written in a JVM-based language to create anexecution context to run code written in one or multiple guest language(s). Whencreating a context, the host application can control which resources the guestcan access. By default access to all managed resources is denied and needs to begranted explicitly.Beyond controlling access to these resources, the execution context also enablestimeboxing of guest applications: a watchdog thread that runs in the hostapplication can be configured to close a context after a given amount of timespecified by the host application, freeing up the computing resources used bythe context.File I/OAccess to files can be controlled via two means. The allowIO privilege grantsthe guest application unrestricted access to the host file system:Context context = Context.newBuilder().allowIO(true).build();Alternatively the Truffle framework virtual file system that all guest file I/O will be routed through can be installed:Context context = Context.newBuilder().fileSystem(FileSystem fs).build();ThreadingA guest application can only create new threads, if the context is created with the corresponding privilege:Context context = Context.newBuilder().allowCreateThread(true).build()Native AccessThe Truffle framework native interface allows access to privileged native code.It needs to be granted to a guest application context via:Context context = Context.newBuilder().allowNativeAccess(true).build()Host InteroperabilityGraalVM allows exchanging objects between the host and the guestapplication. Since the guest application is potentially less trusted than thehost application, multiple controls exist to tune the degree of interoperabilitybetween the guest and the host:  allowHostAccess(policy) – configures which public constructors, methods or fields of public classes of the host can be accessed by the guest  allowHostClassLookup(Predicate&amp;lt;String&amp;gt; classFilter) – allows the guest application to look up the host application classes specified in the classFilter via Java.type. For example, a Javascript context can create a Java ArrayList, provided that ArrayList is whitelisted by the classFilter and access is permitted by the host access policy: context.eval(&quot;js&quot;, &quot;var array = Java.type(&#39;java.util.ArrayList&#39;)&quot;)  allowHostClassLoading(true/false) - allows the guest application to access the host’s class loader to load new classes. Classes are only accessible if access to them is granted by the host access policy.The host access policy has three different options:  ALL - all public constructors, methods or fields of public classes of the host can be accessed by the guest.  NONE - no constructors, methods or fields of the host can be accessed by the guest.  EXPLICIT - only public constructors, methods and fields of public classes that are annotated with @HostAccess.Export can be accessed by the guest.The following example demonstrates how these configuration options work together: public class MyClass {     @HostAccess.Export     public int accessibleMethod() {         return 42;     }     public static void main(String[] args) {         try (Context context = Context.newBuilder() //                         .allowHostClassLookup(c -&amp;gt; c.equals(&quot;myPackage.MyClass&quot;)) //                         .build()) {             int result = context.eval(&quot;js&quot;, &quot;&quot; +                             &quot;var MyClass = Java.type(&#39;myPackage.MyClass&#39;);&quot; +                             &quot;new MyClass().accessibleMethod()&quot;).asInt();             assert result == 42;         }     } }This Java/JavaScript example  creates a new context with the permission to look up the class myPackage.MyClass in the guest applicationevaluates a JavaScript code snippet that accesses the Java class myPackage.MyClass using the Java.type builtin provided by the JavaScript language implementation  creates a new instance of the Java class MyClass by using the JavaScript new keyword  calls the method accessibleMethod() which returns “42”. The method is accessible to the guest language because because the enclosing class and the declared method are public, as well as annotated with the @HostAccess.Export annotation.The guest can also pass objects back to the host. This is implemented by functions that return a value. For example,Value a = Context.create().eval(&quot;js&quot;, &quot;21 + 21&quot;);returns a guest object representing the value “42”. When executing less trustedguest code, application developers need to take care when processing objectsreturned from the guest application – the host application should treat them asless trusted input and sanitize accordingly.Managed Execution of Native CodeThe Truffle framework also supports the LLVM intermediate representation (IR) asa guest language. Several native system programming languages, above all C/C++,can be compiled to LLVM IR with the LLVM compiler toolchain. Typically, theselanguages are not memory safe by themselves and violations of memory safetybeing a frequent cause for security vulnerabilities.The GraalVM Enterprise Edition adds support for a managed execution mode for LLVM IRcode. In managed mode, all ties to the native level are abstracted and routedthrough GraalVM. In particular this means that:  Temporal and spatial memory safety. Memory is allocated from the Java heap. Thismeans that memory allocations are managed objects and all accesses are performedin a memory-safe manner (no arbitrary pointer arithmetics, no uncheckedout-of-bounds accesses).  Type safety. It is not possible to reinterpret a data pointer into a functionpointer and execute arbitrary instructions (since these are distinct pointertypes for LLVM Runtime).  System calls are intercepted and routed to the corresponding Truffle frameworkAPIs. For example, file IO is mapped to the Truffle framework FileSystem API.The set of currently supported system calls is very limited – only syscallsthat can safely be mapped to the Truffle API level are available. Since LLVMruntime in managed mode always runs bitcode compiled for Linux/x86, it onlyneeds to implement system calls for this platform.  All dependent libraries are executed in managed mode as well, removing allreferences to natively executed system libraries. This includes libraries thatare provided by the LLVM Runtime, such as muslibc.Managed mode can be selected when creating a context (Context.create()) orwhen calling the bin/lli binary by specifying the --llvm.managed option. A“managed” context will adhere to any restrictions (e.g., allowIO) passedduring context creation and does not need the allowNativeAccess privilege.Security CaveatsIn this section we address security caveats that are specific to GraalVM Enterprise Edition.Sharing Execution EnginesApplication developers may choose to share execution engines among executioncontexts for performance reasons. While the context holds the state of theexecuted code, the engine holds the code itself. Sharing of an execution engineamong multiple contexts needs to be set up explicitly and can increaseperformance in scenarios where a number of contexts execute the same code. Inscenarios where contexts that share an execution engine for common code alsoexecute sensitive (i.e., private) code, the corresponding source objects can optout from code sharing with:Source.newBuilder(…).cached(false).build()ScriptEngine CompatibilityFor reasons of backward compatibility, certain guest languages also supportJava’s ScriptEngine interface. For example, this allows GraalVM JavaScript to beused as a drop-in replacement for Nashorn. However, to maintain compatibility,the Nashorn GraalVM JavaScript ScriptEngine interface will create a context withall privileges granted to the script and should be used with extreme caution andonly for trusted code.Security Manager and Untrusted CodeThe OpenJDK vulnerability group strongly discourages to running untrusted codeunder a security manager. This also applies to GraalVM, which does not supportuntrusted code execution in Java – GraalVM Native Image does not support asecurity manager in general. While GraalVM’s ability to restrict the executionof guest languages (languages implemented with Truffle framework) applicationsto a certain extent is not dependent on a security manager, it is also notsuited to be used as a sandbox for running untrusted code.If untrusted and potentially malicious code is to be executed, we recommendGraalVM customers who have an immediate requirement to execute untrusted andpotentially adversarial code, adopt the appropriate isolation primitives toensure the confidentiality and integrity of their application data.GraalVM Enterprise to GraalVM Community DowngradeGraalVM’s managed execution of native code is only available in GraalVMEnterprise. When downgrading to GraalVM Community, native code execution is onlyavailable with the allowNativeAccess privilege. This also applies to languagesimplemented with Truffle framework that allow for native code extensions, suchas Python and Ruby.Configuring Host AccessRunning less trusted applications requires special attention to which hostmethods are exposed to the guest application. For example, if a Java method isexposed that calls System.exit then the guest application will be able to exitthe host process. In order to avoid accidentally exposed methods, no host accessis allowed by default and every public method or field needs to be annotatedwith @HostAccess.Export explicitly.public class Employee {    private final String name;    Employee(String name) {this.name = name;}    @HostAccess.Export    public String getName() {        return name;    }}public class Services {    @HostAccess.Export    public Employee createEmployee(String name) {        return new Employee(name);    }    public void exitVM() {        System.exit(1);    }}public static void main(String[] args) {    try (Context context = Context.create()) {        Services services = new Services();        context.getBindings(&quot;js&quot;).putMember(&quot;services&quot;, services);        String name = context.eval(&quot;js&quot;,                &quot;let emp = services.createEmployee(&#39;John Doe&#39;);&quot; +                &quot;emp.getName()&quot;).asString();        assert name.equals(&quot;John Doe&quot;);        try {            context.eval(&quot;js&quot;, &quot;services.exitVM()&quot;);            assert false;        } catch (PolyglotException e) {            assert e.getMessage().endsWith(                    &quot;Unknown identifier: exitVM&quot;);        }    }}In this code:  The class Employee is declared with a field name of type String. Access tothe getName method is explicitly allowed by annotating the method with@HostAccess.Export.  The Services class exposes two methods: createEmployee and exitVM. ThecreateEmployee method takes the name of the employee as an argument and createsa new Employee instance. The createEmployee method is annotated with@HostAccess.Export and therefore accessible to the guest application. The exitVMmethod is not explicitly exported and therefore not accessible.  The main method first creates new polyglot context in default configuration.It therefore evaluates code in less trusted mode.  A new Services instance is created and put into the context as global variable services.  The first evaluated script creates a new employee using the services object and returns its name.  The returned name is asserted to equal the expected name John Doe.  A second script is evaluated that calls the exitVM method on the services object. This fails with a PolyglotException as the exitVM method is not exposed to the guest application.Host access is fully customizable by creating a custom HostAccess policy described in Host Interoperability section above.Access Privilege ConfigurationIt is possible to configure fine-grained access privileges for guestapplications. The configuration can be provided using the Context.Builderclass when constructing a new context. The following access parameters may beconfigured:  Allow access to other languages using allowPolyglotAccess.  Allow and customize access to host objects using allowHostAccess.  Allow and customize host lookup to host types using allowHostLookup.  Allow host class loading using allowHostClassLoading.  Allow the creation of threads using allowCreateThread.  Allow access to native APIs using allowNativeAccess.  Allow access to IO using allowIO and proxy file accesses using fileSystem.Important: Allowing access to class loading, native APIs or host IO must not be enabled forless trusted code as these privileges effectively allow all access.",
                    "url": " /docs/reference-manual/security-guide/"
                  },
                  
                  "docs-support":  {
                    "title": "GraalVM EE",
                    "content": "Oracle GraalVM Enterprise Edition is available:      for non-production and evaluation purposes under the OTN License Agreement Oracle GraalVM Enterprise Edition Including License for Early Adopter Versions license terms.        for on-premises use under the terms of the Oracle Master License Agreement. Please consult the Oracle global price list for information on GraalVM Enterprise subscription offerings. This includes the 24x7x365 Oracle premier support by the Oracle GraalVM team and the access to My Oracle Support (MOS).  For Oracle Cloud customers, GraalVM Enterprisesupport is included in the Oracle Cloud subscription. Please verify if support servicesare activated with your account. Alternatively, contact your salesrepresentative to discuss subscription licensing and support terms.GraalVM Community Edition is community supported as it is an open source project.Subscribe and post to graalvm-users@oss.oracle.com for usability questions.To report a bug or an enhancement request for GraalVM Community, useGitHub Issues. GraalVM Enterprise bugsor enhancement requests should be reported using My Oracle Support (MOS).Any security vulnerabilities in either GraalVM Community or GraalVM Enterprise should only be reported via email to secalert_us@oracle.com.",
                    "url": " /docs/support/"
                  },
                  
                  "docs-release-notes-version-roadmap":  {
                    "title": "Version Roadmap",
                    "content": "Version RoadmapWe release new major versions of GraalVM every 3 months on a predictable schedule, always to the closest Tuesday to the 17th of the month of February, May, August, and November. Major releases become inactive once a new release is published. Only the last major release of the year continues to be updated for the full next year.Critical Patch Updates (CPU) for GraalVM follow the schedule for all CPU releases of Oracle as described here. The release happens quarterly always on the closest Tuesday to the 17th of the month of January, April, July, and October. All active releases receive patch updates.Find below a graphical visualizations of the release road map and the dates and version numbers of upcoming releases.",
                    "url": " /docs/release-notes/version-roadmap/"
                  },
                  
                  "community-videos":  {
                    "title": "Videos",
                    "content": "How GraalVM Executes LanguagesTurning the JVM into a Polyglot VM with Graal with Chris SeatonThis video shows the techniques we use to execute languages such as Ruby with high performance in GraalVM. It demonstrates an example of mixing JavaScript and Ruby within one program and how GraalVM can execute the result with zero overheads when crossing language boundaries.                              watch  video                                                Polyglot Overview and DemoOne VM to Rule Them All by Thomas WuerthingerAn overview presentation of GraalVM including a demonstration of polyglot capabilities and the abilities to improve Java performance and footprint.                      watch  video                            Polyglot NativePolyglot Native: Java, Scala, Kotlin, and JVM languages with Christian WimmerGraalVM can create native images for JVM-based applications, even mixing different languages like Java,Scala, or Kotlin in a single image. This presentation gives an overview of how image generation inGraalVM work and demonstrates how this can be used for obtaining low footprint and fast startup forJVM-based languages.                      watch  video                            GraalVM in the Oracle DatabaseOracle Database Multilingual Engine JavaScript in the Database by D. McGhan and M. BrantnerThe Oracle Database Multilingual Engine enables execution of JavaScript code via GraalVM. This video gives a demonstration of how Node.js modules can be used in the context of database queries and stored procedures.                      watch  video                            Theory How GraalVM Executes LanguagesPractical Partial Evaluation for High-Performance Dynamic Language Runtimes by Thomas WuerthingerThis video gives a deep dive into the theory behind GraalVM. It summarizes the research paper Practical Partial Evaluation for High-performance Dynamic Language Runtimes about how high-perforamnce machine code is derived from interpreter definitions. This approach allows GraalVM minimize the effort for each individual language and keeps the core of GraalVM completely language-agnostic.                      watch  video                            How to Build Your Own Language Implementation with GraalVMOne VM to Rule Them All, One VM to Bind Them by Christian WimmerGraalVM provides a language implementation framework called Truffle. This tutorial is both for newcomers who want to learn the basic principles of Truffle and for people with Truffle experience who want to learn about recently added features. It presents the basic principles of the partial evaluation used by Truffle and the Truffle DSL used for type specializations, as well as features that were added recently such as the language-agnostic object model, language integration, and debugging support. There have already been a wide variety of languages implemented with Truffle including JavaScript, Ruby, R, Python 3, LLVM-based languages, and Smalltalk. Video and Slides are available.                      watch  video                            GraalVM Compiler TutorialThe GraalVM compiler ensures that all our languages run at full speed.It is a dynamic compiler for Java written in Java with a clean API that separates the compiler from the VM.This tutorial is for compiler engineers who want to learn more about GraalVM and,due to its volume, recorded in two parts. It introduces the GraalVM intermediaterepresentation and its basic properties, instructions, and optimization phases.The tutorial also delves into first-class support for speculative optimizationsand deoptimization, snippets (expressing high-level semantics in low-level Javacode), and intrinsics (using all hardware instructions with Graal).Recordings:Part 1Part 2Slides",
                    "url": " /community/videos/"
                  },
                  
                  "docs-why-graal":  {
                    "title": "Why GraalVM",
                    "content": "GraalVM offers a comprehensive ecosystem supporting a large set of languages (Java and other JVM-based languages, JavaScript, Ruby, Python, R, and C/C++ and other LLVM-based languages) and running them in different deployment scenarios (OpenJDK, Node.js, Oracle Database, or standalone). This page provides an overview of different scenarios in which GraalVM can make a difference for your applications.Some of versatile GraalVM capabilities, that might be missing on this page are thoroughly summarized and disclosed in Top 10 Things To Do With GraalVM blog post.For Java ProgramsFor existing Java applications, GraalVM can provide benefits by running them faster, providing extensibility via scripting languages, or creating ahead-of-time compiled native images.Run Java FasterGraalVM can run in the context of OpenJDK to make Java applications run faster with a new just-in-time compilation technology. GraalVM takes over the compilation of Java bytecode to machine code. In particular for other JVM-based languages such as Scala, this configuration can achieve benefits, as for example experienced by Twitter running GraalVM in production.            The compiler of GraalVM provides performance advantages for highly abstracted programs due to its ability to remove costly object allocations in many scenarios. You can find details in this research paper and try [an example]({{ “/docs/examples/java-performance-examples”      relative_url }}). Better inlining and more aggressive speculative optimizations can lead to additional benefits for complex long-running applications, see a [Stream API example]({{“/docs/examples/java-simple-stream-benchmark/”      relative_url }}).      Whether and how much of a difference GraalVM makes in terms of performance depends of course on the concrete workload. We are interested in receiving any kind of benchmarking results that can help us make GraalVM even faster.Make Your Application Extensible            GraalVM enables running JavaScript, R, Python, or Ruby in the context of Java applications. It offers the ability to expose Java data structures to those languages and offers secure managed mechanisms (e.g., time boxing or memory boxing). The integration is language-agnostic, i.e., an integration for JavaScript can at the later point be also used to execute any other GraalVM-based language. Proxy mechanisms allow mocking up dynamic objects from Java data structures and expose them to the embedded scripts. Take a look at [the description]({{“/docs/graalvm-as-a-platform/embed/”      relative_url }}) on how to make your JVM-based application extensible with GraalVM.      Create a Native Image            Running your application inside a Java VM comes with startup and footprint costs. GraalVM has a feature to create native images for existing JVM-based applications. The image generation process employs static analysis to find any code reachable from the main Java method and then performs full ahead-of-time (AOT) compilation. The resulting native binary contains the whole program in machine code form for its immediate execution. It can be linked with other native programs and can optionally include the GraalVM compiler for complementary just-in-time (JIT) compilation support to run any GraalVM-based language with high performance. For additional performance, native images can be built with profile guided optimizations gathered in a previous run of the application. See an example of how to build native images [here]({{“/docs/reference-manual/aot-compilation/”      relative_url }}).      For Node.js ProgramsGraalVM can run in the context of Node.js by replacing V8 with GraalVM for executing JavaScript. The main benefits of doing so is to enable polyglot applications (e.g., use Java, R, or Python libraries), run Node.js with large heap configurations and Java’s garbage collectors, or use GraalVM’s interoperability to define data structures in C/C++ and use them from JavaScript.Reuse Libraries from Java, R, or Python            GraalVM enables the use of existing Java libraries or Java frameworks (like Spark or Flink) directly from Node.js. Also, one can use for example R or Python for data science or plotting directly from a JavaScript application. Find an example of a polyglot application [here]({{“/docs/examples/polyglot-javascript-java-r/”      relative_url }}).      Run with Large HeapsThe V8 JavaScript engine included in the standard Node.js distribution is tuned for browser configurations and designed to work effectively in small heap scenarios. We enable running Node.js with the heap management of the JVM, opening the ability for large heap configurations and suitable garbage collection settings. The maximum configurable heap size is 32 Gb with compressed 32-bit pointers, and terabytes of heap are supported in the 64-bit pointer configuration.Define Data Structures in C/C++            GraalVM allows efficient combination of native code (e.g., written in C/C++) and JavaScript. Native data structures can be directly accessed and the compiler can inline across any boundary. This can be beneficial in a scenario where efficient data structures are managed and allocated in C while other parts of the application are written in Node.js. Find an example of such scenario in the [reference manual]({{ “/docs/reference-manual/languages/llvm/#interoperability”      relative_url }} ).      For Ruby, R, or PythonWarning: Support for Ruby, R, or Python is experimental in GraalVM. Experimental features might never be included in a production version, or might change significantly before being considered production-ready.We are actively working on stability and support for all modules for those languages. At this point in time, we can run simpler applications of Ruby and R, but we do not have the same full compatibility we provide for Java and Node.js applications. Our Python implementation was just recently started and can only run small examples.Apart from the standard GraalVM benefits such as language interoperability (e.g., use Java or JavaScript from those applications), GraalVM can achieve high speedups of 10x or more for those languages. We are happy to assist with making existing Ruby and R applications work with GraalVM, but we cannot guarantee out-of-the-box compatibility for these languages yet.Running in Oracle DatabaseGraalVM is designed for embeddability and can be executed in databases. Ourprototype of the Oracle Database Multilingual Engine (MLE) is availablehere. It allows Oracle Database usersto run JavaScript, using browserify to execute Node.js modules, and to writeextensions in Python.For Microservices FrameworksGraalVM Native Image, currently available as an Early Adopter technology, works with many different Java microservices frameworks.Several projects have already accepted this technology as a platform for theirapplications: Quarkus, Micronaut, Helidon. For these frameworks GraalVM nativeimages significantly reduce the runtime memory requirements compared to runningon HotSpot. We believe that GraalVM Native Image technology can become the bestway for deploying cloud native applications.            ![microservices]({{ “/resources/img/ms_memory_footprint.png”      relative_url }})                  ![microservices]({{ “/resources/img/ms_startup_time.png”      relative_url }})      For Your PlatformWe encourage the development of GraalVM embeddings similar to our ownintegrations in the Oracle Database, OpenJDK, or Node.js. Together with researchcollaboration partners, we already explored ideas of embedding in Spark orFlink. Find a description on how to embed GraalVM in your existing JVM-basedapplication or native application here.For Your Languages and ToolsGraalVM is an open ecosystem and we invite third party systems to participatevia connecting their own programming languages, tools, or platforms.Implement Your Own LanguageThe Truffle Language Implementation framework allows running programming languages efficiently on GraalVM. It simplifies language implementation by automatically deriving high-performance code from interpreters. You can find details about the approach in this research paper.Implementing your own language using GraalVM will not only give you high performance. More importantly, it allows your language to connect with the rich tooling provided by the GraalVM ecosystem. Also, it enables your language to run in the context of any GraalVM embedding.            We developed a demonstration language called “SimpleLanguage” to show the use of GraalVM’s language implementation framework. Find out how to [get started]({{“/docs/graalvm-as-a-platform/implement-language/”      relative_url }}) implementing a language.      Create Language-agnostic ToolsGraalVM provides a framework for creating language-agnostic tools like debuggers, profilers, or other instrumentations. GraalVM provides a standardized way to express and run program code enabling cross-language research and the development of tools that are developed once and then can be applied to any language.",
                    "url": " /docs/why-graal/"
                  },
                  
                  "assets-main-css":  {
                    "title": "",
                    "content": "@import “minima”;",
                    "url": " /assets/main.css"
                  },
                  
                  "redirects-json":  {
                    "title": "",
                    "content": "{“/docs/graalvm-as-a-platform/embed/”:”https://www.graalvm.org/docs/reference-manual/embed/”}",
                    "url": " /redirects.json"
                  },
                  
              };
              </script>

              <div role="button" class="menu-btn menu-btn--sidebar js-show-sidebar" title="sweet hamburger">
                <div class="hamburger"><div class="inner"></div></div>
              </div>
            </div>
          </div>
        </div>
    </div>
  </div>
</article>

<!-- JavaScript libraries -->
<script src="/resources/js/lunr.min.js"></script>
<script src="/resources/lib/jquery/jquery-3.4.1.min.js"></script>

</div>

      </main>

      <footer class="footer">
  <div class="container-fluid container-fluid--custom-sm">
    <div class="row">
      <div class="col-12 col-sm-12 col-md-12 col-lg-10 offset-lg-1">
        <div class="row">
          <div class="col-md-3 col-sm-12">
            <a href="/" class="logo-footer">
              <img src="/resources/img/logo.svg" alt="graalvm_logo">
            </a>
          </div>

          <div class="col-md-3 col-sm-6 col-6">
            <h6 class="title-footer">GraalVM</h6>
            <ul class="footer-list">
              <li class="footer-list__item"><a href="/docs/getting-started">Getting Started</a></li>
              <li class="footer-list__item"><a href="/docs/reference-manual">Reference Manual</a></li>
              <li class="footer-list__item"><a href="https://www.graalvm.org/sdk/javadoc/">GraalVM SDK Javadoc</a></li>
              <li class="footer-list__item"><a href="/docs/release-notes/">Release Notes</a></li>
              <li class="footer-list__item"><a href="/downloads">Downloads</a></li>
            </ul>
          </div>

          <div class="col-md-2 col-sm-6 col-6">
            <h6 class="title-footer">Community</h6>
            <ul class="footer-list">
              <li class="footer-list__item"><a href="/blog/">Team Blog</a></li>
              <li class="footer-list__item"><a href="/community/press/">In the Press</a></li>
              <li class="footer-list__item"><a href="/community/">Get Support</a></li>
              <li class="footer-list__item"><a href="/docs/faq/">FAQ</a></li>
            </ul>
          </div>

          <div class="col-md-2 col-sm-6 col-6">
            <h6 class="title-footer">Stay Tuned</h6>
            <ul class="footer-list">
              <li class="footer-list__item"><a href="https://github.com/oracle/graal">GitHub</a></li>
              <li class="footer-list__item"><a href="https://twitter.com/graalvm">Twitter</a></li>
              <li class="footer-list__item"><a href="https://gitter.im/graalvm/graal-core">Gitter</a></li>
              <li class="footer-list__item"><a href="/community/events/">Events</a></li>
            </ul>
          </div>

          <div class="col-md-2 col-sm-6 col-6">
            <h6 class="title-footer">Useful Links</h6>
            <ul class="footer-list">
              <li class="footer-list__item"><a href="https://docs.oracle.com/en/graalvm/">Oracle Help Center</a></li>
              <li class="footer-list__item"><a href="https://www.oracle.com/tools/graalvm-enterprise-edition.html">Oracle GraalVM</a></li>
              <li class="footer-list__item"><a href="https://labs.oracle.com/">Oracle Labs</a></li>
              <li class="footer-list__item"><a href="/docs/support/">Support</a></li>
            </ul>
          </div>
        </div>

        <div class="row">
          <div class="col-sm-12">
            <p class="copyright">
              Copyright © 2018, 2019, Oracle and/or its affiliates. All rights reserved.
            </p>
          </div>
        </div>
      </div>
    </div>
  </div>
</footer>

    </div>
    <div class="overlay"></div>

    <script src='/resources/lib/twitter-fetcher.js'></script>
    <script src='/resources/lib/slick-slider/slick.min.js'></script>
    <script src='/resources/js/main.js'></script>
  </body>
</html>
